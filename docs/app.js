var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module) => () => {
  if (!module) {
    module = {exports: {}};
    callback(module.exports, module);
  }
  return module.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/workbox-window/build/workbox-window.prod.es5.mjs
var require_workbox_window_prod_es5 = __commonJS((exports) => {
  __markAsModule(exports);
  __export(exports, {
    Workbox: () => v,
    messageSW: () => n
  });
  try {
    self["workbox:window:6.1.5"] && _();
  } catch (n2) {
  }
  function n(n2, t2) {
    return new Promise(function(r2) {
      var e2 = new MessageChannel();
      e2.port1.onmessage = function(n3) {
        r2(n3.data);
      }, n2.postMessage(t2, [e2.port2]);
    });
  }
  function t(n2, t2) {
    for (var r2 = 0; r2 < t2.length; r2++) {
      var e2 = t2[r2];
      e2.enumerable = e2.enumerable || false, e2.configurable = true, "value" in e2 && (e2.writable = true), Object.defineProperty(n2, e2.key, e2);
    }
  }
  function r(n2, t2) {
    (t2 == null || t2 > n2.length) && (t2 = n2.length);
    for (var r2 = 0, e2 = new Array(t2); r2 < t2; r2++)
      e2[r2] = n2[r2];
    return e2;
  }
  function e(n2, t2) {
    var e2;
    if (typeof Symbol == "undefined" || n2[Symbol.iterator] == null) {
      if (Array.isArray(n2) || (e2 = function(n3, t3) {
        if (n3) {
          if (typeof n3 == "string")
            return r(n3, t3);
          var e3 = Object.prototype.toString.call(n3).slice(8, -1);
          return e3 === "Object" && n3.constructor && (e3 = n3.constructor.name), e3 === "Map" || e3 === "Set" ? Array.from(n3) : e3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e3) ? r(n3, t3) : void 0;
        }
      }(n2)) || t2 && n2 && typeof n2.length == "number") {
        e2 && (n2 = e2);
        var i2 = 0;
        return function() {
          return i2 >= n2.length ? {done: true} : {done: false, value: n2[i2++]};
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    return (e2 = n2[Symbol.iterator]()).next.bind(e2);
  }
  try {
    self["workbox:core:6.1.5"] && _();
  } catch (n2) {
  }
  var i = function() {
    var n2 = this;
    this.promise = new Promise(function(t2, r2) {
      n2.resolve = t2, n2.reject = r2;
    });
  };
  function o(n2, t2) {
    var r2 = location.href;
    return new URL(n2, r2).href === new URL(t2, r2).href;
  }
  var u = function(n2, t2) {
    this.type = n2, Object.assign(this, t2);
  };
  function a(n2, t2, r2) {
    return r2 ? t2 ? t2(n2) : n2 : (n2 && n2.then || (n2 = Promise.resolve(n2)), t2 ? n2.then(t2) : n2);
  }
  function c() {
  }
  var f = {type: "SKIP_WAITING"};
  function s(n2, t2) {
    if (!t2)
      return n2 && n2.then ? n2.then(c) : Promise.resolve();
  }
  var v = function(r2) {
    var e2, c2;
    function v2(n2, t2) {
      var e3, c3;
      return t2 === void 0 && (t2 = {}), (e3 = r2.call(this) || this).nn = {}, e3.tn = 0, e3.rn = new i(), e3.en = new i(), e3.on = new i(), e3.un = 0, e3.an = new Set(), e3.cn = function() {
        var n3 = e3.fn, t3 = n3.installing;
        e3.tn > 0 || !o(t3.scriptURL, e3.sn) || performance.now() > e3.un + 6e4 ? (e3.vn = t3, n3.removeEventListener("updatefound", e3.cn)) : (e3.hn = t3, e3.an.add(t3), e3.rn.resolve(t3)), ++e3.tn, t3.addEventListener("statechange", e3.ln);
      }, e3.ln = function(n3) {
        var t3 = e3.fn, r3 = n3.target, i2 = r3.state, o2 = r3 === e3.vn, a2 = {sw: r3, isExternal: o2, originalEvent: n3};
        !o2 && e3.mn && (a2.isUpdate = true), e3.dispatchEvent(new u(i2, a2)), i2 === "installed" ? e3.wn = self.setTimeout(function() {
          i2 === "installed" && t3.waiting === r3 && e3.dispatchEvent(new u("waiting", a2));
        }, 200) : i2 === "activating" && (clearTimeout(e3.wn), o2 || e3.en.resolve(r3));
      }, e3.dn = function(n3) {
        var t3 = e3.hn, r3 = t3 !== navigator.serviceWorker.controller;
        e3.dispatchEvent(new u("controlling", {isExternal: r3, originalEvent: n3, sw: t3, isUpdate: e3.mn})), r3 || e3.on.resolve(t3);
      }, e3.gn = (c3 = function(n3) {
        var t3 = n3.data, r3 = n3.source;
        return a(e3.getSW(), function() {
          e3.an.has(r3) && e3.dispatchEvent(new u("message", {data: t3, sw: r3, originalEvent: n3}));
        });
      }, function() {
        for (var n3 = [], t3 = 0; t3 < arguments.length; t3++)
          n3[t3] = arguments[t3];
        try {
          return Promise.resolve(c3.apply(this, n3));
        } catch (n4) {
          return Promise.reject(n4);
        }
      }), e3.sn = n2, e3.nn = t2, navigator.serviceWorker.addEventListener("message", e3.gn), e3;
    }
    c2 = r2, (e2 = v2).prototype = Object.create(c2.prototype), e2.prototype.constructor = e2, e2.__proto__ = c2;
    var h, l2, m, w = v2.prototype;
    return w.register = function(n2) {
      var t2 = (n2 === void 0 ? {} : n2).immediate, r3 = t2 !== void 0 && t2;
      try {
        var e3 = this;
        return function(n3, t3) {
          var r4 = n3();
          if (r4 && r4.then)
            return r4.then(t3);
          return t3(r4);
        }(function() {
          if (!r3 && document.readyState !== "complete")
            return s(new Promise(function(n3) {
              return window.addEventListener("load", n3);
            }));
        }, function() {
          return e3.mn = Boolean(navigator.serviceWorker.controller), e3.yn = e3.pn(), a(e3.bn(), function(n3) {
            e3.fn = n3, e3.yn && (e3.hn = e3.yn, e3.en.resolve(e3.yn), e3.on.resolve(e3.yn), e3.yn.addEventListener("statechange", e3.ln, {once: true}));
            var t3 = e3.fn.waiting;
            return t3 && o(t3.scriptURL, e3.sn) && (e3.hn = t3, Promise.resolve().then(function() {
              e3.dispatchEvent(new u("waiting", {sw: t3, wasWaitingBeforeRegister: true}));
            }).then(function() {
            })), e3.hn && (e3.rn.resolve(e3.hn), e3.an.add(e3.hn)), e3.fn.addEventListener("updatefound", e3.cn), navigator.serviceWorker.addEventListener("controllerchange", e3.dn, {once: true}), e3.fn;
          });
        });
      } catch (n3) {
        return Promise.reject(n3);
      }
    }, w.update = function() {
      try {
        return this.fn ? s(this.fn.update()) : void 0;
      } catch (n2) {
        return Promise.reject(n2);
      }
    }, w.getSW = function() {
      return this.hn !== void 0 ? Promise.resolve(this.hn) : this.rn.promise;
    }, w.messageSW = function(t2) {
      try {
        return a(this.getSW(), function(r3) {
          return n(r3, t2);
        });
      } catch (n2) {
        return Promise.reject(n2);
      }
    }, w.messageSkipWaiting = function() {
      this.fn && this.fn.waiting && n(this.fn.waiting, f);
    }, w.pn = function() {
      var n2 = navigator.serviceWorker.controller;
      return n2 && o(n2.scriptURL, this.sn) ? n2 : void 0;
    }, w.bn = function() {
      try {
        var n2 = this;
        return function(n3, t2) {
          try {
            var r3 = n3();
          } catch (n4) {
            return t2(n4);
          }
          if (r3 && r3.then)
            return r3.then(void 0, t2);
          return r3;
        }(function() {
          return a(navigator.serviceWorker.register(n2.sn, n2.nn), function(t2) {
            return n2.un = performance.now(), t2;
          });
        }, function(n3) {
          throw n3;
        });
      } catch (n3) {
        return Promise.reject(n3);
      }
    }, h = v2, (l2 = [{key: "active", get: function() {
      return this.en.promise;
    }}, {key: "controlling", get: function() {
      return this.on.promise;
    }}]) && t(h.prototype, l2), m && t(h, m), v2;
  }(function() {
    function n2() {
      this.Pn = new Map();
    }
    var t2 = n2.prototype;
    return t2.addEventListener = function(n3, t3) {
      this.Sn(n3).add(t3);
    }, t2.removeEventListener = function(n3, t3) {
      this.Sn(n3).delete(t3);
    }, t2.dispatchEvent = function(n3) {
      n3.target = this;
      for (var t3, r2 = e(this.Sn(n3.type)); !(t3 = r2()).done; ) {
        (0, t3.value)(n3);
      }
    }, t2.Sn = function(n3) {
      return this.Pn.has(n3) || this.Pn.set(n3, new Set()), this.Pn.get(n3);
    }, n2;
  }());
});

// src/log.js
var LOG_ALL = true;
var Warning = class extends Error {
  constructor(...params) {
    super(...params);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Warning);
    }
    this.name = "Warning";
  }
};
async function mylog_entry(_level, _desc, ...additional) {
  return;
}
async function mywarn(_desc, ...additional) {
  if (LOG_ALL) {
    let msg = _desc;
    try {
      let e = new Warning(_desc);
      msg = e.stack;
    } catch (e) {
    }
    console.warn(_desc, ...additional);
    mylog_entry("W", msg, ...additional);
  }
}
async function myerror(_desc, ...additional) {
  let msg = _desc;
  try {
    let e = new Error(_desc);
    msg = e.stack;
  } catch (e) {
  }
  console.error(msg, ...additional);
  mylog_entry("E", msg, ...additional);
}
async function recentLogs() {
  return void 0;
}
async function clearLogs() {
  return;
}
var log = {
  mywarn,
  myerror,
  recentLogs,
  clearLogs
};

// src/router.js
var pages = new Map();
function route(pageName, classInstance) {
  console.log("ROUTER: register page:", pageName);
  pages.set(pageName, classInstance);
}
var homePage;
function setHomePage(page) {
  homePage = page;
}
window.addEventListener("popstate", async function(event) {
  var pageName = homePage;
  var pageData = void 0;
  var state = event.state;
  if (state != null) {
    pageName = state.pageName;
    pageData = state.pageData;
  }
  console.log("Popstate: ", pageName);
  await processPageEntered(pageName, pageData, true);
});
async function processPageEntered(pageName, pageData, historyData) {
  try {
    for (let [name, classInstance] of pages) {
      classInstance.domElem.style.display = "none";
      if (name !== pageName && classInstance.exit) {
        await classInstance.exit();
      }
    }
  } catch (error) {
    log.myerror("Trying to call exit", error);
    return;
  }
  let targetPage = pages.get(pageName);
  if (targetPage === void 0) {
    pageName = "page404";
  }
  window.scrollTo(0, 0);
  try {
    if (targetPage.enter) {
      await targetPage.enter(pageData, historyData);
    } else {
      targetPage.style.display = "block";
    }
  } catch (error) {
    log.myerror("Calling enter()", error);
    return;
  }
}
async function goHome() {
  await gotoPage(homePage);
}
async function gotoPage(pageName, pageData) {
  if (!pageData) {
    pageData = {};
  }
  if (pages.get(pageName) === void 0) {
    log.myerror("Target page does not exist: ", pageName);
    pageName = "page404";
  }
  window.history.pushState({pageName, pageData}, `${pageName}`);
  await processPageEntered(pageName, pageData);
}

// node_modules/lit-html/lib/directive.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var directives = new WeakMap();
var isDirective = (o) => {
  return typeof o === "function" && directives.has(o);
};

// node_modules/lit-html/lib/dom.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var isCEPolyfill = typeof window !== "undefined" && window.customElements != null && window.customElements.polyfillWrapFlushCallback !== void 0;
var reparentNodes = (container, start, end = null, before = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.insertBefore(start, before);
    start = n;
  }
};
var removeNodes = (container, start, end = null) => {
  while (start !== end) {
    const n = start.nextSibling;
    container.removeChild(start);
    start = n;
  }
};

// node_modules/lit-html/lib/part.js
/**
 * @license
 * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var noChange = {};
var nothing = {};

// node_modules/lit-html/lib/template.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var marker = `{{lit-${String(Math.random()).slice(2)}}}`;
var nodeMarker = `<!--${marker}-->`;
var markerRegex = new RegExp(`${marker}|${nodeMarker}`);
var boundAttributeSuffix = "$lit$";
var Template = class {
  constructor(result, element) {
    this.parts = [];
    this.element = element;
    const nodesToRemove = [];
    const stack = [];
    const walker = document.createTreeWalker(element.content, 133, null, false);
    let lastPartIndex = 0;
    let index = -1;
    let partIndex = 0;
    const {strings: strings2, values: {length}} = result;
    while (partIndex < length) {
      const node = walker.nextNode();
      if (node === null) {
        walker.currentNode = stack.pop();
        continue;
      }
      index++;
      if (node.nodeType === 1) {
        if (node.hasAttributes()) {
          const attributes = node.attributes;
          const {length: length2} = attributes;
          let count = 0;
          for (let i = 0; i < length2; i++) {
            if (endsWith(attributes[i].name, boundAttributeSuffix)) {
              count++;
            }
          }
          while (count-- > 0) {
            const stringForPart = strings2[partIndex];
            const name = lastAttributeNameRegex.exec(stringForPart)[2];
            const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;
            const attributeValue = node.getAttribute(attributeLookupName);
            node.removeAttribute(attributeLookupName);
            const statics = attributeValue.split(markerRegex);
            this.parts.push({type: "attribute", index, name, strings: statics});
            partIndex += statics.length - 1;
          }
        }
        if (node.tagName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
      } else if (node.nodeType === 3) {
        const data = node.data;
        if (data.indexOf(marker) >= 0) {
          const parent = node.parentNode;
          const strings3 = data.split(markerRegex);
          const lastIndex = strings3.length - 1;
          for (let i = 0; i < lastIndex; i++) {
            let insert;
            let s = strings3[i];
            if (s === "") {
              insert = createMarker();
            } else {
              const match = lastAttributeNameRegex.exec(s);
              if (match !== null && endsWith(match[2], boundAttributeSuffix)) {
                s = s.slice(0, match.index) + match[1] + match[2].slice(0, -boundAttributeSuffix.length) + match[3];
              }
              insert = document.createTextNode(s);
            }
            parent.insertBefore(insert, node);
            this.parts.push({type: "node", index: ++index});
          }
          if (strings3[lastIndex] === "") {
            parent.insertBefore(createMarker(), node);
            nodesToRemove.push(node);
          } else {
            node.data = strings3[lastIndex];
          }
          partIndex += lastIndex;
        }
      } else if (node.nodeType === 8) {
        if (node.data === marker) {
          const parent = node.parentNode;
          if (node.previousSibling === null || index === lastPartIndex) {
            index++;
            parent.insertBefore(createMarker(), node);
          }
          lastPartIndex = index;
          this.parts.push({type: "node", index});
          if (node.nextSibling === null) {
            node.data = "";
          } else {
            nodesToRemove.push(node);
            index--;
          }
          partIndex++;
        } else {
          let i = -1;
          while ((i = node.data.indexOf(marker, i + 1)) !== -1) {
            this.parts.push({type: "node", index: -1});
            partIndex++;
          }
        }
      }
    }
    for (const n of nodesToRemove) {
      n.parentNode.removeChild(n);
    }
  }
};
var endsWith = (str, suffix) => {
  const index = str.length - suffix.length;
  return index >= 0 && str.slice(index) === suffix;
};
var isTemplatePartActive = (part) => part.index !== -1;
var createMarker = () => document.createComment("");
var lastAttributeNameRegex = /([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;

// node_modules/lit-html/lib/template-instance.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var TemplateInstance = class {
  constructor(template, processor, options) {
    this.__parts = [];
    this.template = template;
    this.processor = processor;
    this.options = options;
  }
  update(values) {
    let i = 0;
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.setValue(values[i]);
      }
      i++;
    }
    for (const part of this.__parts) {
      if (part !== void 0) {
        part.commit();
      }
    }
  }
  _clone() {
    const fragment = isCEPolyfill ? this.template.element.content.cloneNode(true) : document.importNode(this.template.element.content, true);
    const stack = [];
    const parts2 = this.template.parts;
    const walker = document.createTreeWalker(fragment, 133, null, false);
    let partIndex = 0;
    let nodeIndex = 0;
    let part;
    let node = walker.nextNode();
    while (partIndex < parts2.length) {
      part = parts2[partIndex];
      if (!isTemplatePartActive(part)) {
        this.__parts.push(void 0);
        partIndex++;
        continue;
      }
      while (nodeIndex < part.index) {
        nodeIndex++;
        if (node.nodeName === "TEMPLATE") {
          stack.push(node);
          walker.currentNode = node.content;
        }
        if ((node = walker.nextNode()) === null) {
          walker.currentNode = stack.pop();
          node = walker.nextNode();
        }
      }
      if (part.type === "node") {
        const part2 = this.processor.handleTextExpression(this.options);
        part2.insertAfterNode(node.previousSibling);
        this.__parts.push(part2);
      } else {
        this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));
      }
      partIndex++;
    }
    if (isCEPolyfill) {
      document.adoptNode(fragment);
      customElements.upgrade(fragment);
    }
    return fragment;
  }
};

// node_modules/lit-html/lib/template-result.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var policy = window.trustedTypes && trustedTypes.createPolicy("lit-html", {createHTML: (s) => s});
var commentMarker = ` ${marker} `;
var TemplateResult = class {
  constructor(strings2, values, type, processor) {
    this.strings = strings2;
    this.values = values;
    this.type = type;
    this.processor = processor;
  }
  getHTML() {
    const l2 = this.strings.length - 1;
    let html2 = "";
    let isCommentBinding = false;
    for (let i = 0; i < l2; i++) {
      const s = this.strings[i];
      const commentOpen = s.lastIndexOf("<!--");
      isCommentBinding = (commentOpen > -1 || isCommentBinding) && s.indexOf("-->", commentOpen + 1) === -1;
      const attributeMatch = lastAttributeNameRegex.exec(s);
      if (attributeMatch === null) {
        html2 += s + (isCommentBinding ? commentMarker : nodeMarker);
      } else {
        html2 += s.substr(0, attributeMatch.index) + attributeMatch[1] + attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] + marker;
      }
    }
    html2 += this.strings[l2];
    return html2;
  }
  getTemplateElement() {
    const template = document.createElement("template");
    let value = this.getHTML();
    if (policy !== void 0) {
      value = policy.createHTML(value);
    }
    template.innerHTML = value;
    return template;
  }
};
var SVGTemplateResult = class extends TemplateResult {
  getHTML() {
    return `<svg>${super.getHTML()}</svg>`;
  }
  getTemplateElement() {
    const template = super.getTemplateElement();
    const content = template.content;
    const svgElement = content.firstChild;
    content.removeChild(svgElement);
    reparentNodes(content, svgElement.firstChild);
    return template;
  }
};

// node_modules/lit-html/lib/parts.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var isPrimitive = (value) => {
  return value === null || !(typeof value === "object" || typeof value === "function");
};
var isIterable = (value) => {
  return Array.isArray(value) || !!(value && value[Symbol.iterator]);
};
var AttributeCommitter = class {
  constructor(element, name, strings2) {
    this.dirty = true;
    this.element = element;
    this.name = name;
    this.strings = strings2;
    this.parts = [];
    for (let i = 0; i < strings2.length - 1; i++) {
      this.parts[i] = this._createPart();
    }
  }
  _createPart() {
    return new AttributePart(this);
  }
  _getValue() {
    const strings2 = this.strings;
    const l2 = strings2.length - 1;
    const parts2 = this.parts;
    if (l2 === 1 && strings2[0] === "" && strings2[1] === "") {
      const v = parts2[0].value;
      if (typeof v === "symbol") {
        return String(v);
      }
      if (typeof v === "string" || !isIterable(v)) {
        return v;
      }
    }
    let text = "";
    for (let i = 0; i < l2; i++) {
      text += strings2[i];
      const part = parts2[i];
      if (part !== void 0) {
        const v = part.value;
        if (isPrimitive(v) || !isIterable(v)) {
          text += typeof v === "string" ? v : String(v);
        } else {
          for (const t of v) {
            text += typeof t === "string" ? t : String(t);
          }
        }
      }
    }
    text += strings2[l2];
    return text;
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element.setAttribute(this.name, this._getValue());
    }
  }
};
var AttributePart = class {
  constructor(committer) {
    this.value = void 0;
    this.committer = committer;
  }
  setValue(value) {
    if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {
      this.value = value;
      if (!isDirective(value)) {
        this.committer.dirty = true;
      }
    }
  }
  commit() {
    while (isDirective(this.value)) {
      const directive2 = this.value;
      this.value = noChange;
      directive2(this);
    }
    if (this.value === noChange) {
      return;
    }
    this.committer.commit();
  }
};
var NodePart = class {
  constructor(options) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.options = options;
  }
  appendInto(container) {
    this.startNode = container.appendChild(createMarker());
    this.endNode = container.appendChild(createMarker());
  }
  insertAfterNode(ref) {
    this.startNode = ref;
    this.endNode = ref.nextSibling;
  }
  appendIntoPart(part) {
    part.__insert(this.startNode = createMarker());
    part.__insert(this.endNode = createMarker());
  }
  insertAfterPart(ref) {
    ref.__insert(this.startNode = createMarker());
    this.endNode = ref.endNode;
    ref.endNode = this.startNode;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    if (this.startNode.parentNode === null) {
      return;
    }
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    const value = this.__pendingValue;
    if (value === noChange) {
      return;
    }
    if (isPrimitive(value)) {
      if (value !== this.value) {
        this.__commitText(value);
      }
    } else if (value instanceof TemplateResult) {
      this.__commitTemplateResult(value);
    } else if (value instanceof Node) {
      this.__commitNode(value);
    } else if (isIterable(value)) {
      this.__commitIterable(value);
    } else if (value === nothing) {
      this.value = nothing;
      this.clear();
    } else {
      this.__commitText(value);
    }
  }
  __insert(node) {
    this.endNode.parentNode.insertBefore(node, this.endNode);
  }
  __commitNode(value) {
    if (this.value === value) {
      return;
    }
    this.clear();
    this.__insert(value);
    this.value = value;
  }
  __commitText(value) {
    const node = this.startNode.nextSibling;
    value = value == null ? "" : value;
    const valueAsString = typeof value === "string" ? value : String(value);
    if (node === this.endNode.previousSibling && node.nodeType === 3) {
      node.data = valueAsString;
    } else {
      this.__commitNode(document.createTextNode(valueAsString));
    }
    this.value = value;
  }
  __commitTemplateResult(value) {
    const template = this.options.templateFactory(value);
    if (this.value instanceof TemplateInstance && this.value.template === template) {
      this.value.update(value.values);
    } else {
      const instance = new TemplateInstance(template, value.processor, this.options);
      const fragment = instance._clone();
      instance.update(value.values);
      this.__commitNode(fragment);
      this.value = instance;
    }
  }
  __commitIterable(value) {
    if (!Array.isArray(this.value)) {
      this.value = [];
      this.clear();
    }
    const itemParts = this.value;
    let partIndex = 0;
    let itemPart;
    for (const item of value) {
      itemPart = itemParts[partIndex];
      if (itemPart === void 0) {
        itemPart = new NodePart(this.options);
        itemParts.push(itemPart);
        if (partIndex === 0) {
          itemPart.appendIntoPart(this);
        } else {
          itemPart.insertAfterPart(itemParts[partIndex - 1]);
        }
      }
      itemPart.setValue(item);
      itemPart.commit();
      partIndex++;
    }
    if (partIndex < itemParts.length) {
      itemParts.length = partIndex;
      this.clear(itemPart && itemPart.endNode);
    }
  }
  clear(startNode = this.startNode) {
    removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);
  }
};
var BooleanAttributePart = class {
  constructor(element, name, strings2) {
    this.value = void 0;
    this.__pendingValue = void 0;
    if (strings2.length !== 2 || strings2[0] !== "" || strings2[1] !== "") {
      throw new Error("Boolean attributes can only contain a single expression");
    }
    this.element = element;
    this.name = name;
    this.strings = strings2;
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const value = !!this.__pendingValue;
    if (this.value !== value) {
      if (value) {
        this.element.setAttribute(this.name, "");
      } else {
        this.element.removeAttribute(this.name);
      }
      this.value = value;
    }
    this.__pendingValue = noChange;
  }
};
var PropertyCommitter = class extends AttributeCommitter {
  constructor(element, name, strings2) {
    super(element, name, strings2);
    this.single = strings2.length === 2 && strings2[0] === "" && strings2[1] === "";
  }
  _createPart() {
    return new PropertyPart(this);
  }
  _getValue() {
    if (this.single) {
      return this.parts[0].value;
    }
    return super._getValue();
  }
  commit() {
    if (this.dirty) {
      this.dirty = false;
      this.element[this.name] = this._getValue();
    }
  }
};
var PropertyPart = class extends AttributePart {
};
var eventOptionsSupported = false;
(() => {
  try {
    const options = {
      get capture() {
        eventOptionsSupported = true;
        return false;
      }
    };
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (_e) {
  }
})();
var EventPart = class {
  constructor(element, eventName, eventContext) {
    this.value = void 0;
    this.__pendingValue = void 0;
    this.element = element;
    this.eventName = eventName;
    this.eventContext = eventContext;
    this.__boundHandleEvent = (e) => this.handleEvent(e);
  }
  setValue(value) {
    this.__pendingValue = value;
  }
  commit() {
    while (isDirective(this.__pendingValue)) {
      const directive2 = this.__pendingValue;
      this.__pendingValue = noChange;
      directive2(this);
    }
    if (this.__pendingValue === noChange) {
      return;
    }
    const newListener = this.__pendingValue;
    const oldListener = this.value;
    const shouldRemoveListener = newListener == null || oldListener != null && (newListener.capture !== oldListener.capture || newListener.once !== oldListener.once || newListener.passive !== oldListener.passive);
    const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);
    if (shouldRemoveListener) {
      this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    if (shouldAddListener) {
      this.__options = getOptions(newListener);
      this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);
    }
    this.value = newListener;
    this.__pendingValue = noChange;
  }
  handleEvent(event) {
    if (typeof this.value === "function") {
      this.value.call(this.eventContext || this.element, event);
    } else {
      this.value.handleEvent(event);
    }
  }
};
var getOptions = (o) => o && (eventOptionsSupported ? {capture: o.capture, passive: o.passive, once: o.once} : o.capture);

// node_modules/lit-html/lib/default-template-processor.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var DefaultTemplateProcessor = class {
  handleAttributeExpressions(element, name, strings2, options) {
    const prefix = name[0];
    if (prefix === ".") {
      const committer2 = new PropertyCommitter(element, name.slice(1), strings2);
      return committer2.parts;
    }
    if (prefix === "@") {
      return [new EventPart(element, name.slice(1), options.eventContext)];
    }
    if (prefix === "?") {
      return [new BooleanAttributePart(element, name.slice(1), strings2)];
    }
    const committer = new AttributeCommitter(element, name, strings2);
    return committer.parts;
  }
  handleTextExpression(options) {
    return new NodePart(options);
  }
};
var defaultTemplateProcessor = new DefaultTemplateProcessor();

// node_modules/lit-html/lib/template-factory.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
function templateFactory(result) {
  let templateCache = templateCaches.get(result.type);
  if (templateCache === void 0) {
    templateCache = {
      stringsArray: new WeakMap(),
      keyString: new Map()
    };
    templateCaches.set(result.type, templateCache);
  }
  let template = templateCache.stringsArray.get(result.strings);
  if (template !== void 0) {
    return template;
  }
  const key = result.strings.join(marker);
  template = templateCache.keyString.get(key);
  if (template === void 0) {
    template = new Template(result, result.getTemplateElement());
    templateCache.keyString.set(key, template);
  }
  templateCache.stringsArray.set(result.strings, template);
  return template;
}
var templateCaches = new Map();

// node_modules/lit-html/lib/render.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
var parts = new WeakMap();
var render = (result, container, options) => {
  let part = parts.get(container);
  if (part === void 0) {
    removeNodes(container, container.firstChild);
    parts.set(container, part = new NodePart(Object.assign({templateFactory}, options)));
    part.appendInto(container);
  }
  part.setValue(result);
  part.commit();
};

// node_modules/lit-html/lit-html.js
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
if (typeof window !== "undefined") {
  (window["litHtmlVersions"] || (window["litHtmlVersions"] = [])).push("1.4.1");
}
var html = (strings2, ...values) => new TemplateResult(strings2, values, "html", defaultTemplateProcessor);
var svg = (strings2, ...values) => new SVGTemplateResult(strings2, values, "svg", defaultTemplateProcessor);

// src/i18n/translations.json
var $intro01 = {
  en: "This application allows the verification of COVID certificates issued by EU Member States and also certificates issued by the UK Government with the same format as the EU Digital COVID Certificate",
  es: "Esta aplicaci\xF3n permite la verificaci\xF3n de certificados COVID emitidos por los Estados Miembro de la UE y tambi\xE9n los certificados emitidos por el Reino Unido con el mismo formato que el Certificado COVID Digital de la UE",
  ca: "Aquesta aplicaci\xF3 permet la verificaci\xF3 dels certificats COVID emesos pels Estats membres de la UE i tamb\xE9 els certificats emesos pel Regne Unit en el mateix format que el Certificat COVID digital de la UE",
  fr: "Cette application permet de v\xE9rifier les certificats COVID \xE9mis par les \xC9tats membres de l'UE, ainsi que les certificats \xE9mis par le gouvernement britannique sous le m\xEAme format que le certificat COVID num\xE9rique de l'UE.",
  de: "Diese Anwendung erm\xF6glicht die \xDCberpr\xFCfung von COVID-Zertifikaten, die von EU-Mitgliedstaaten ausgestellt wurden, sowie von Zertifikaten, die von der britischen Regierung ausgestellt wurden und dasselbe Format wie das digitale COVID-Zertifikat der EU haben.",
  it: "Questa applicazione consente di verificare i certificati COVID rilasciati dagli stati membri dell'UE nonch\xE9 i certificati rilasciati dal governo del Regno Unito con lo stesso formato del certificato digitale COVID UE"
};
var EU_Digital_COVID_Credential_Verifier = {
  es: "Verificador de Credenciales COVID",
  ca: "Verificador de Credencials COVID",
  fr: "Outil de v\xE9rification num\xE9rique des justificatifs COVID de l'UE",
  de: "EU Digital COVID Credential Verifier",
  it: "Strumento di verifica del certificato digitale COVID UE"
};
var Start_verifying = {
  es: "Comenzar a verificar",
  ca: "Comen\xE7a a verificar",
  fr: "Commencer la v\xE9rification",
  de: "\xDCberpr\xFCfung beginnen",
  it: "Avvia la verifica"
};
var Verify_another = {
  es: "Verificar otro",
  ca: "Verifica'ne un altre",
  fr: "Effectuer une autre v\xE9rification",
  de: "Ein weiteres \xFCberpr\xFCfen",
  it: "Verifica un altro documento"
};
var Privacy_policy = {
  es: "Pol\xEDtica de privacidad",
  ca: "Pol\xEDtica de privacitat",
  fr: "Politique de confidentialit\xE9",
  de: "Datenschutzbestimmungen",
  it: "Informativa sulla privacy"
};
var Terms___Conditions = {
  es: "T\xE9rminos y condiciones",
  ca: "Termes d'\xFAs",
  fr: "Conditions g\xE9n\xE9rales",
  de: "Allgemeine Gesch\xE4ftsbedingungen",
  it: "Condizioni d'uso"
};
var Language = {
  es: "Idioma",
  ca: "Llengua",
  fr: "Langue",
  de: "Sprache",
  it: "Lingua"
};
var Update_public_keys = {
  es: "Actualizar llaves p\xFAblicas",
  ca: "Actualitza claus p\xFAbliques",
  fr: "Mise \xE0 jour des cl\xE9s publiques",
  de: "\xD6ffentliche Schl\xFCssel aktualisieren",
  it: "Aggiorna chiavi pubbliche"
};
var Easy___Secure = {
  es: "F\xE1cil y Seguro",
  ca: "F\xE0cil i Segur",
  fr: "Simple et s\xE9curis\xE9",
  de: "Einfach und sicher",
  it: "Facile e sicuro"
};
var We_don_t_save_data = {
  es: "No guardamos ning\xFAn dato",
  ca: "No emmagatzemem cap dada",
  fr: "Nous ne conservons pas les donn\xE9es",
  de: "Wir speichern keine Daten",
  it: "I dati non vengono memorizzati"
};
var No_installs = {
  es: "Sin instalaci\xF3n",
  ca: "Sense instal\xB7laci\xF3",
  fr: "Pas d'installation n\xE9cessaire",
  de: "Keine Installationen",
  it: "No installazioni"
};
var Free_of_cookies = {
  es: "Libre de cookies",
  ca: "Sense cookies",
  fr: "Sans cookie",
  de: "Frei von Cookies",
  it: "Senza cookie"
};
var $callus = {
  en: "If you are a public or private organization and want more information about this or similar solutions from Evidence Ledger, you can contact us via email",
  es: "Si usted es una entidad p\xFAblica o privada y desea m\xE1s informaci\xF3n sobre esta soluci\xF3n o similares de Evidence Ledger, puede contactarnos via email",
  ca: "Si ets una entitat p\xFAblica o privada i vols m\xE9s informaci\xF3 sobre aquesta soluci\xF3 o similars Evidence Ledger, pots contactar amb nosaltres per correu electr\xF2nic",
  fr: "Si vous \xEAtes une organisation publique ou une entreprise priv\xE9e et que vous souhaitez en savoir plus sur cette solution ou d'autres solutions similaires d'Evidence Ledger, vous pouvez nous contacter par e-mail.",
  de: "Wenn Sie eine \xF6ffentliche oder private Organisation sind und weitere Informationen \xFCber diese oder \xE4hnliche L\xF6sungen von Evidence Ledger w\xFCnschen, k\xF6nnen Sie uns per E-Mail kontaktieren.",
  it: "Che rappresentiate organizzazioni pubbliche o private, non esitate a contattarci per maggiori informazioni su questa o altre soluzioni fornite da Evidence Ledger."
};
var Application_updated = {
  es: "Aplicaci\xF3n actualizada",
  ca: "Aplicaci\xF3 actualitzada",
  fr: "Application mise \xE0 jour",
  de: "Anwendung aktualisiert",
  it: "L'applicazione \xE8 stata aggiornata"
};
var There_is_a_new_version_of_the_application_and_it_has_already_been_updated_ = {
  es: "Se ha actualizado con una nueva versi\xF3n de la aplicaci\xF3n.",
  ca: "Actualitzat amb una nova versi\xF3 de l'aplicaci\xF3.",
  fr: "Il existe une nouvelle version de l'application et elle a d\xE9j\xE0 \xE9t\xE9 mise \xE0 jour.",
  de: "Es gibt eine neue Version der Anwendung und sie ist bereits aktualisiert worden.",
  it: "Una nuova versione dell'applicazione \xE8 disponibile ed \xE8 gi\xE0 stata aggiornata."
};
var Please_click_Accept_to_refresh_the_page_ = {
  es: "Por favor presione Aceptar para refrescar la p\xE1gina",
  ca: "Premeu Acceptar per actualitzar la p\xE0gina",
  fr: "Veuillez cliquer sur Accepter pour rafra\xEEchir la page.",
  de: "Bitte klicken Sie auf Akzeptieren, um die Seite zu aktualisieren.",
  it: "Fare click su Accetta per aggiornare la pagina."
};
var Accept = {
  es: "Aceptar",
  ca: "Acceptar",
  fr: "Accepter",
  de: "Akzeptieren",
  it: "Accetta"
};
var Failed_ = {
  es: "Error",
  ca: "Failed!",
  fr: "\xC9chec !",
  de: "Fehlgeschlagen!",
  it: "Errore"
};
var Signature_validation_failed__The_certificate_is_not_valid_ = {
  es: "Error en verificaci\xF3n de firma. Certificado inv\xE1lido",
  ca: "Signature validation failed. The certificate is not valid.",
  fr: "La validation de la signature a \xE9chou\xE9. Le certificat n'est pas valable.",
  de: "Signatur\xFCberpr\xFCfung fehlgeschlagen. Das Zertifikat ist ung\xFCltig.",
  it: "La verifica della firma non \xE8 andata a buon fine. Il certificato non risulta valido."
};
var Warning_ = {
  es: "Atenci\xF3n",
  ca: "Atenci\xF3",
  fr: "Attention !",
  de: "Warnung!",
  it: "Attenzione!"
};
var $warningmsg = {
  en: "The certificate is not valid for travel, even if it is correctly signed with a PRE key.",
  es: "EL certificado no es v\xE1lido para viajar, aunque est\xE1 correctamente firmado con una llave de PRE.",
  ca: "El certificat no \xE9s v\xE0lid per viatjar tot i que est\xE0 correctament signat amb una clau de PRE.",
  fr: "Le certificat n'est pas valable pour voyager, m\xEAme s'il est sign\xE9 en bonne et due forme avec une cl\xE9 pr\xE9-partag\xE9e.",
  de: "Das Zertifikat ist f\xFCr Reisen ung\xFCltig, auch wenn es korrekt mit einem PRE-Schl\xFCssel signiert ist.",
  it: "Il certificato non risulta valido per viaggiare, sebbene sia stato firmato correttamente con la chiave PRE."
};
var Validated_ = {
  es: "Validado!",
  ca: "Validat",
  fr: "Valid\xE9 !",
  de: "Validiert!",
  it: "Verificato con successo!"
};
var The_certificate_is_valid_ = {
  es: "El certificado es v\xE1lido",
  ca: "El certificat \xE9s v\xE0lid",
  fr: "Le certificat est valable.",
  de: "Das Zertifikat ist g\xFCltig.",
  it: "Il certificato \xE8 valido."
};
var EU_DIGITAL_COVID_CERTIFICATE = {
  es: "CERTIFICADO COVID DIGITAL DE LA EU",
  ca: "CERTIFICAT COVID DIGITAL DE LA EU",
  fr: "CERTIFICAT NUM\xC9RIQUE COVID DE L'UE",
  de: "EU DIGITALES COVID ZERTIFIKAT",
  it: "CERTIFICATO DIGITALE COVID UE"
};
var Vaccination = {
  es: "Vacunaci\xF3n",
  ca: "Vacunaci\xF3",
  fr: "Vaccination",
  de: "Impfung",
  it: "Vaccino"
};
var Surname_and_forename = {
  es: "Apellidos y Nombre",
  ca: "Cognoms i nom",
  fr: "Nom et pr\xE9nom",
  de: "Nachname und Vorname",
  it: "Cognome e nome"
};
var Date_of_birth = {
  es: "Fecha de nacimiento",
  ca: "Data de naixement",
  fr: "Date de naissance",
  de: "Geburtsdatum",
  it: "Data di nascita"
};
var Certificate_identifier = {
  es: "Identificador del certificado",
  ca: "Identificador del certificat",
  fr: "Identifiant du certificat",
  de: "Kennung des Zertifikats",
  it: "Numero di identificazione del certificato"
};
var Certificate_issuer = {
  es: "Emisor del certificado",
  ca: "Emissor del certificat",
  fr: "\xC9metteur du certificat",
  de: "Zertifikatsaussteller",
  it: "Ente che ha rilasciato il certificato"
};
var Disease_targeted = {
  es: "Enfermedad que se previene",
  ca: "Malaltia que prev\xE9",
  fr: "Maladie cibl\xE9e",
  de: "Zielgerichtete Krankheit",
  it: "Patologia"
};
var Vaccine_prophylaxis = {
  es: "Tipo de vacuna",
  ca: "Tipus de vacuna",
  fr: "Vaccin/prophylaxie",
  de: "Impfung/Prophylaxe",
  it: "Vaccino/profilassi"
};
var Vaccine_medicinal_product = {
  es: "Vacuna administrada",
  ca: "Vacuna administrada",
  fr: "M\xE9dicament vaccinal",
  de: "Impfstoff-Medizinprodukt",
  it: "Prodotto medico per la vaccinazione"
};
var Manufacturer = {
  es: "Fabricante",
  ca: "Fabricant",
  fr: "Fabricant",
  de: "Hersteller",
  it: "Produttore"
};
var Dose_number_Total_doses = {
  es: "N\xFAmero de dosis/Total",
  ca: "N\xFAmero dosi/Total",
  fr: "Nombre de doses/Doses totales",
  de: "Anzahl der Dosen/Gesamtdosen",
  it: "Numero di dosi/Dosi totali"
};
var Date_of_vaccination = {
  es: "Fecha de vacunaci\xF3n",
  ca: "Data de vacunaci\xF3",
  fr: "Date de la vaccination",
  de: "Datum der Impfung",
  it: "Data della vaccinazione"
};
var Member_State_of_vaccination = {
  es: "Estado miembro de la vacunaci\xF3n",
  ca: "Estat membre de la vacunaci\xF3",
  fr: "\xC9tat membre o\xF9 a \xE9t\xE9 effectu\xE9e la vaccination",
  de: "Mitgliedstaat der Impfung",
  it: "Paese membro in cui \xE8 stata effettuata la vaccinazione"
};
var translations_default = {
  $intro01,
  "EU Digital COVID Credential Verifier": EU_Digital_COVID_Credential_Verifier,
  "Start verifying": Start_verifying,
  "Verify another": Verify_another,
  "Privacy policy": Privacy_policy,
  "Terms & Conditions": Terms___Conditions,
  Language,
  "Update public keys": Update_public_keys,
  "Easy & Secure": Easy___Secure,
  "We don't save data": We_don_t_save_data,
  "No installs": No_installs,
  "Free of cookies": Free_of_cookies,
  $callus,
  "Application updated": Application_updated,
  "There is a new version of the application and it has already been updated.": There_is_a_new_version_of_the_application_and_it_has_already_been_updated_,
  "Please click Accept to refresh the page.": Please_click_Accept_to_refresh_the_page_,
  Accept,
  "Failed!": Failed_,
  "Signature validation failed. The certificate is not valid.": Signature_validation_failed__The_certificate_is_not_valid_,
  "Warning!": Warning_,
  $warningmsg,
  "Validated!": Validated_,
  "The certificate is valid.": The_certificate_is_valid_,
  "EU DIGITAL COVID CERTIFICATE": EU_DIGITAL_COVID_CERTIFICATE,
  Vaccination,
  "Surname and forename": Surname_and_forename,
  "Date of birth": Date_of_birth,
  "Certificate identifier": Certificate_identifier,
  "Certificate issuer": Certificate_issuer,
  "Disease targeted": Disease_targeted,
  "Vaccine/prophylaxis": Vaccine_prophylaxis,
  "Vaccine medicinal product": Vaccine_medicinal_product,
  Manufacturer,
  "Dose number/Total doses": Dose_number_Total_doses,
  "Date of vaccination": Date_of_vaccination,
  "Member State of vaccination": Member_State_of_vaccination
};

// src/i18n/translate.js
var preferredLanguage = navigator.language.substring(0, 2);
var l = localStorage.getItem("preferredLanguage");
if (l) {
  preferredLanguage = l;
}
window.preferredLanguage = preferredLanguage;
function T(key) {
  if (window.preferredLanguage === "en" && key.charAt(0) != "$") {
    return key;
  }
  let entry = translations_default[key];
  if (entry === void 0) {
    return key;
  }
  let translated = entry[window.preferredLanguage];
  if (translated === void 0) {
    return key;
  }
  return translated;
}

// src/img/evidenceLogo60.png
var evidenceLogo60_default = "data:image/png;base64,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";

// src/components/header.js
var domElem = void 0;
var x = void 0;
function HeaderBar() {
  function toggleMenu(e) {
    x = e.target.parentNode.nextElementSibling;
    x.classList.toggle("w3-show");
  }
  function goHome2(e) {
    x = e.target.parentNode.nextElementSibling;
    x.classList.remove("w3-show");
    goHome();
  }
  if (!domElem) {
    console.log("HEADERBAR: Creating DOM element");
    domElem = document.createElement("div");
    domElem.id = "headerbar";
    document.body.append(domElem);
  }
  if (x) {
    x.classList.remove("w3-show");
  }
  let theHtml = html`
    <div class="w3-bar w3-xlarge color-primary">
        <img class="w3-bar-item" style="padding:0" @click=${goHome2} href="javascript:void(0)" src=${evidenceLogo60_default} alt="">
        <a href="javascript:void(0)" class="w3-bar-item btn-menu w3-right" @click=${toggleMenu}>&#9776;</a>
    </div>
    
    <div class="w3-bar-block w3-xlarge color-white w3-hide">
        <a @click=${() => gotoPage("spinner")} href="javascript:void(0)" class="w3-bar-item w3-large btn-menu">${T("Update public keys")}</a>
        <a @click=${() => gotoPage("selectLanguage")} href="javascript:void(0)" class="w3-bar-item w3-large btn-menu">${T("Language")}</a>
        <a href="#" class="w3-bar-item w3-large btn-menu">${T("Privacy policy")}</a>
        <a href="#" class="w3-bar-item w3-large btn-menu">${T("Terms & Conditions")}</a>
    </div>
    `;
  render(theHtml, domElem);
}

// node_modules/pako/dist/pako.esm.mjs
/*! pako 2.0.3 https://github.com/nodeca/pako @license (MIT AND Zlib) */
var Z_FIXED = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN = 2;
function zero(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
var base_length = new Array(LENGTH_CODES);
zero(base_length);
var base_dist = new Array(D_CODES);
zero(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var copy_block = (s, buf, len, header) => {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let lx = 0;
  let code;
  let extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let black_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
};
var _tr_align = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally = (s, dist, lc) => {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1 = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var {_tr_init: _tr_init$1, _tr_stored_block: _tr_stored_block$1, _tr_flush_block: _tr_flush_block$1, _tr_tally: _tr_tally$1, _tr_align: _tr_align$1} = trees;
var {
  Z_NO_FLUSH,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH,
  Z_BLOCK,
  Z_OK,
  Z_STREAM_END,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED: Z_FIXED$1,
  Z_DEFAULT_STRATEGY,
  Z_UNKNOWN: Z_UNKNOWN$1,
  Z_DEFLATED
} = constants;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return (f << 1) - (f > 4 ? 9 : 0);
};
var zero$1 = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block$1(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
var putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH$1;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let p, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    const max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally$1(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$1) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      bflush = _tr_tally$1(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH$1 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally$1(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally$1(s, 1, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally$1(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero$1(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
  this.heap = new Uint16Array(2 * L_CODES$1 + 1);
  zero$1(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES$1 + 1);
  zero$1(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$1;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH;
  _tr_init$1(s);
  return Z_OK;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};
var deflate = (strm, flush) => {
  let beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  const s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s.strm = strm;
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align$1(s);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block$1(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero$1(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
};
var deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero$1(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH$1 - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2 = deflate;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l2 = chunks.length; i < l2; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l2 = chunks.length; i < l2; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  let i, out;
  const len = max || buf.length;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$1,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_DEFLATED: Z_DEFLATED$1
} = constants;
function Deflate(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$1,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$1
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize2 = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize2);
      strm.next_out = 0;
      strm.avail_out = chunkSize2;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$1) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$1;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function(status) {
  if (status === Z_OK$1) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
var BAD = 30;
var TYPE = 12;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base = extra = work;
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var {
  Z_FINISH: Z_FINISH$2,
  Z_BLOCK: Z_BLOCK$1,
  Z_TREES,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_NEED_DICT,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFLATED: Z_DEFLATED$2
} = constants;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE$1 = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD$1 = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var MAX_WBITS$1 = 15;
var DEF_WBITS = MAX_WBITS$1;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);
  state.sane = 1;
  state.back = -1;
  return Z_OK$2;
};
var inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$2) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS$1, state.lens, 0, 288, lenfix, 0, state.work, {bits: 9});
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS$1, state.lens, 0, 32, distfix, 0, state.work, {bits: 5});
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE$1) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$2;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$1;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$2) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$1;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE$1;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$2) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$1;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(input.subarray(next, next + copy), len);
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$1;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$1;
        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$1;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$1;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$1;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = {bits: state.lenbits};
          ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$1;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$1;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD$1) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$1;
            break;
          }
          state.lenbits = 9;
          opts = {bits: state.lenbits};
          ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$1;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = {bits: state.distbits};
          ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$1;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$1) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$1;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$1;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$1;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$1;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$2;
          break inf_leave;
        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$1 && (state.mode < CHECK || flush !== Z_FINISH$2)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$2) && ret === Z_OK$2) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$2;
};
var inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$2;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK$2;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2 = inflate;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_FINISH: Z_FINISH$3,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_MEM_ERROR: Z_MEM_ERROR$1
} = constants;
function Inflate(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK$3) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$3) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize2 = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2;
  if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize2);
      strm.next_out = 0;
      strm.avail_out = chunkSize2;
    }
    status = inflate_1.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT$1 && dictionary) {
      status = inflate_1.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK$3) {
        status = inflate_1.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$2) {
        status = Z_NEED_DICT$1;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END$3 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1.inflateReset(strm);
      status = inflate_1.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR$2:
      case Z_DATA_ERROR$2:
      case Z_NEED_DICT$1:
      case Z_MEM_ERROR$1:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$3) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize2 - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK$3 && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END$3) {
      status = inflate_1.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function(status) {
  if (status === Z_OK$3) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1 = Inflate;
var inflate_2$1 = inflate$1;
var inflateRaw_1 = inflateRaw;
var ungzip = inflate$1;
var constants$2 = constants;
var inflate_1$1 = {
  Inflate: Inflate_1,
  inflate: inflate_2$1,
  inflateRaw: inflateRaw_1,
  ungzip,
  constants: constants$2
};
var {Inflate: Inflate$1, inflate: inflate$2, inflateRaw: inflateRaw$1, ungzip: ungzip$1} = inflate_1$1;
var inflate_1$2 = inflate$2;

// src/json/all_jwk_keys.json
var _L7AaIwu_EY_ = {
  co: "DE",
  kid: "0L7AaIwu+EY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "0L7AaIwu-EbkrTSIRA5WLXt7ylS-tCXSLfXKTu-wMH4",
    use: "sig",
    crv: "P-256",
    kid: "0L7AaIwu+EY=",
    x: "UdPPsk9xzY1vM1zdjgvHDsRCST55Y9SJBJUXI5uqGb4",
    y: "nJKU-8UBRm5vlhkLhSfRNMN2csqm_T_27DCUJiZK6ZI"
  }
};
var __da8dKEjlE_ = {
  co: "DE",
  kid: "1+da8dKEjlE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "1-da8dKEjlG3e33N-3hzXGwTVPpwtE6ZO-0MR6W3XLY",
    use: "sig",
    crv: "P-256",
    kid: "1+da8dKEjlE=",
    x: "qD56CIMWer5HDRhCpUrq5lZ6F8WrFPy_IDwjgb44oE0",
    y: "gRC5NcQW4178-5Ej6X946ePMDyO1li3Mf1eStQOqGzQ"
  }
};
var _BGoyFIyYPs_ = {
  co: "DE",
  kid: "2BGoyFIyYPs=",
  jwk: {
    kty: "EC",
    "x5t#S256": "2BGoyFIyYPvvSNrVQKxtVzAxLVXJJcAvsrb-bgk45kg",
    use: "sig",
    crv: "P-256",
    kid: "2BGoyFIyYPs=",
    x: "tGEETBc2arnjxxBWO3aDW-rwFgwmhqPbxhaUuOEC6kk",
    y: "Hdxj4ZlzxWCrZhTOCEA49Qn6rtmyB2ukahfbhDG7ccE"
  }
};
var _JelGO_ymxQ_ = {
  co: "DE",
  kid: "2JelGO/ymxQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "2JelGO_ymxTkn_NAT7T9ump9DpveX44uzauJdlTvNUM",
    use: "sig",
    crv: "P-256",
    kid: "2JelGO/ymxQ=",
    x: "eL12fn7-nUNW-9T9zJLaiZF18rfzL1I735fT-3zuKrw",
    y: "kdytqDCDAQxW66y1b2t1HjhGWs_rFMFClhzINh4ELbY"
  }
};
var _LCRmucB9kU_ = {
  co: "DE",
  kid: "3LCRmucB9kU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3LCRmucB9kXIskHtE2CqQuz82j7x1mtN60qYFeJN2Tg",
    use: "sig",
    crv: "P-256",
    kid: "3LCRmucB9kU=",
    x: "tgz2ifmTj_vZbBaz6xlNCdQlw4FQU7v3dUrJYQEigk4",
    y: "C8_HWNXN6Rs2Dt90464Df0J_sh2mDB5evtOhpOwLlus"
  }
};
var _jqajzfHpKE_ = {
  co: "DE",
  kid: "3jqajzfHpKE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3jqajzfHpKHtVFGoUOJWH-tzuACc061HQ4vH5bBhomE",
    use: "sig",
    crv: "P-256",
    kid: "3jqajzfHpKE=",
    x: "8nZrLqMlw5EvdfvJXgxb2rXj9OBT2UWBqAFLeCoQXuY",
    y: "PmDmSaVLS-MBUBzBj278qFr73H1ra892Vx8GmooEBvw"
  }
};
var _lrBUHc4iQE_ = {
  co: "DE",
  kid: "3lrBUHc4iQE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3lrBUHc4iQFFT4ijNwQ0XQ3JBXYGflkGmvw8IPBqCqE",
    use: "sig",
    crv: "P-256",
    kid: "3lrBUHc4iQE=",
    x: "71N2pH6YyC6gfUHwiEJDzIxwMIW_Hs-Cgn_gPQbZAkE",
    y: "XMl_y0xNo9oGQ_IS7OeUxK00yqJLx5KxDlrR2JCA4ck"
  }
};
var _oYtiEZ9wp4_ = {
  co: "DE",
  kid: "3oYtiEZ9wp4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3oYtiEZ9wp7-LJlqmCoXomD__1zifwmgzNUYOy4DrH0",
    use: "sig",
    crv: "P-256",
    kid: "3oYtiEZ9wp4=",
    x: "5sqOpW4x66Hmcposox406LFRWyGIvH2CA-Di7pgvWYI",
    y: "CS1-7KExN-mCsed7z2EVISrc3sSe5yPdDLQpYOjbEwM"
  }
};
var _xtSr6KkAGA_ = {
  co: "DE",
  kid: "5xtSr6KkAGA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "5xtSr6KkAGCKZUV0K9U2AYQPgxpC8Tfgkpum3cs7vxg",
    use: "sig",
    crv: "P-256",
    kid: "5xtSr6KkAGA=",
    x: "zma5iz5ZBIh1KDZhj9fSnqJoKK9weOGB_91w6FpdAUg",
    y: "xRChg6YY_zHRkX1a6P4Esh0YaWkIIWSV0QxAjrkgM6k"
  }
};
var _FNkACSMLEc_ = {
  co: "DE",
  kid: "6FNkACSMLEc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "6FNkACSMLEcjKozFVKIjAQ7G0cCj3LxgjtX_hEnNmQc",
    use: "sig",
    crv: "P-256",
    kid: "6FNkACSMLEc=",
    x: "8xghqNrE21susvTQHV9fwN3RWhBIdCYBu3laCz66Nas",
    y: "Ksqrk-OzyV7jon0lIjWNv6jsg7rtAHvDCiB3lJjecHQ"
  }
};
var _VdOPLF8_Fg_ = {
  co: "DE",
  kid: "6VdOPLF8/Fg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "6VdOPLF8_Fh3xVqjvoX56hVYN3YXa7WtPE0A5S9-ibI",
    use: "sig",
    crv: "P-256",
    kid: "6VdOPLF8/Fg=",
    x: "HrXK9pJSpMrEB4xUrXTTnb7RakIRzDtNh6ugnjfV510",
    y: "zRbLuayqKSWGAzpPwX8uTMjboOpw95EklFMucnj64Jg"
  }
};
var _XLhQx1KXdQ_ = {
  co: "DE",
  kid: "7XLhQx1KXdQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "7XLhQx1KXdTDHuhabTJrmpuyrTe1wyGo7BUYX-nTCVA",
    use: "sig",
    crv: "P-256",
    kid: "7XLhQx1KXdQ=",
    x: "kkxNdS0EZvjP8j17j2k92vHZpX3qSNMDbCqBYPvmqzg",
    y: "9Y5zRKrAGUqfLqacKEoYJkD3VEpguY70miND4iEVCYY"
  }
};
var _AnF_hcilSo_ = {
  co: "DE",
  kid: "8AnF/hcilSo=",
  jwk: {
    kty: "EC",
    "x5t#S256": "8AnF_hcilSrBZdnzWKGe0JqqYbbN_fBXjLDJUrGhb48",
    use: "sig",
    crv: "P-256",
    kid: "8AnF/hcilSo=",
    x: "Ol2NFM-2gkakrrAa7g-F7KOXRziS4ydbxiNbm3XTu-I",
    y: "_Sz_qEijCzniTgXIyQN0aq6gIln6DK4lhndC0WDOk1k"
  }
};
var _IZVOkJRZPQ_ = {
  co: "DE",
  kid: "9IZVOkJRZPQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "9IZVOkJRZPQlcH_i8mu2ajp4NFhgQ35P4zUfZxac8W0",
    use: "sig",
    crv: "P-256",
    kid: "9IZVOkJRZPQ=",
    x: "65QJlG4NQ1UKM3_5Yf6n9u430S0gtEarOF4e-WrILwU",
    y: "GppLDtsyX0oAMFyVdmc83pzUZpdYhX33X-Fe8sc4C1M"
  }
};
var _v3FozjKAUo_ = {
  co: "DE",
  kid: "9v3FozjKAUo=",
  jwk: {
    kty: "EC",
    "x5t#S256": "9v3FozjKAUqiedlFvFFydFBz-_VipHqOFZO__LkTZk4",
    use: "sig",
    crv: "P-256",
    kid: "9v3FozjKAUo=",
    x: "zIzHRqk76vDGIUAj3dIo3UVev41tak5P5oxO-zaOlsI",
    y: "p8VDW6PcqiHKTqO7LSPFi64n-EUWomaENLb2oUhx9os"
  }
};
var AQCGDydsS1Q_ = {
  co: "DE",
  kid: "AQCGDydsS1Q=",
  jwk: {
    kty: "EC",
    "x5t#S256": "AQCGDydsS1SrTLpOO4BoDq4Bkkp4MzKODdwPiXVRH58",
    use: "sig",
    crv: "P-256",
    kid: "AQCGDydsS1Q=",
    x: "M7zYPRk1r4viA_oG6BxLec1shhb0JoDGjLAUuPxmGSM",
    y: "MPmgkGVHGOTLVKp1Q98f_5L4rhWQ7pn-uYtFdaOxrHs"
  }
};
var CvktK3hdjeY_ = {
  co: "DE",
  kid: "CvktK3hdjeY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "CvktK3hdjebD5OXrksqfmu5lko49q3X8_0-SzucpccE",
    use: "sig",
    crv: "P-256",
    kid: "CvktK3hdjeY=",
    x: "uCgNX5VUmp7_lN7_UDF5kRDz7qvWnpgFOKwv1AxJXbQ",
    y: "r8CY-QAzj_cBgLKHKEibT69y2425qgKp3a4K9_N9frY"
  }
};
var DusseXrzqO8_ = {
  co: "DE",
  kid: "DusseXrzqO8=",
  jwk: {
    kty: "EC",
    "x5t#S256": "DusseXrzqO84DsUlO-upPN6-Rgnup9BpT31nHd771rw",
    use: "sig",
    crv: "P-256",
    kid: "DusseXrzqO8=",
    x: "xfciFuh1jL3LBPzaNAVmmVTL87eJ6wVctSg393nUcXw",
    y: "VS9b-bwoKeo1pUXSYJVSY_I0RtE3xdzi4w1BwD59qwM"
  }
};
var IZftFLRmKGY_ = {
  co: "DE",
  kid: "IZftFLRmKGY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "IZftFLRmKGZivlPYjwzMZvLYCIne8epGsiBrUiXDRGM",
    use: "sig",
    crv: "P-256",
    kid: "IZftFLRmKGY=",
    x: "yxW76RQrbDUSOEHxYksWk5CaGGygxDJJ7A9jRiop-Fk",
    y: "acJj0XhU5iTVUTAoxOesystaMXYuClwhyP8iSLsOM1s"
  }
};
var L7XIA2gi2ps_ = {
  co: "DE",
  kid: "L7XIA2gi2ps=",
  jwk: {
    kty: "EC",
    "x5t#S256": "L7XIA2gi2ptXxahyfyOWtEHjbMlLN4Ij_XEM-Uj5Z7Y",
    use: "sig",
    crv: "P-256",
    kid: "L7XIA2gi2ps=",
    x: "orGGRfEic2GL5o9XnITdq3nd9d7pWDvy6waSkDMI630",
    y: "_sLwpbkgVd61kf0JC9xXX6XC9hTglmgEef7FzooaX68"
  }
};
var M8bcnysCMj4_ = {
  co: "DE",
  kid: "M8bcnysCMj4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "M8bcnysCMj6GRnB8f2wQAW2eGX2NJFnHZHLwV_ZzdPQ",
    use: "sig",
    crv: "P-256",
    kid: "M8bcnysCMj4=",
    x: "qXPIlxahww0kgegwTgRNQWpChqH2PfXelyd1D77uo8c",
    y: "ctPLZQ4bBO86cs1l32U1ADMT7YMPiU6omi9RULb3ZMg"
  }
};
var MxhfdcoHinc_ = {
  co: "DE",
  kid: "MxhfdcoHinc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "MxhfdcoHiner068ldBnuRylgVUMKNrXnx58fGyxqUPE",
    use: "sig",
    crv: "P-256",
    kid: "MxhfdcoHinc=",
    x: "KPuGAJsDLPU7vw4aDg52nFxuxz3AsJtWUmtsY7tQegw",
    y: "AlX5ZfnubECbusuQmZzg_oCnTCn547ge9fc_7RfagfY"
  }
};
var NCdyt3s_cak_ = {
  co: "DE",
  kid: "NCdyt3s+cak=",
  jwk: {
    kty: "EC",
    "x5t#S256": "NCdyt3s-cakVp9DHZFZRcrCgZ2K_ZXME1fbQVwnFEQg",
    use: "sig",
    crv: "P-256",
    kid: "NCdyt3s+cak=",
    x: "szk-l0BVoDOXZg5SKeeNbLUAggqLKB2a3NlMXWfxfdc",
    y: "HR7D6qpSlnBU2Qcw9_5CMsSYua5cZNVJNibBTRG47e8"
  }
};
var OKpEjMo_2MY_ = {
  co: "DE",
  kid: "OKpEjMo/2MY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "OKpEjMo_2Mb-DavBfrmMZdjHQuDUv10q0KSwqDCFhSg",
    use: "sig",
    crv: "P-256",
    kid: "OKpEjMo/2MY=",
    x: "UCSPQOg4hIgEJzD2PHFjccnQzSQIvYs-gbBuJqHxv7s",
    y: "QgBKchI-VyH443zIzcQPrKPgHWchH8LM4Sq9gNf51Uk"
  }
};
var R7q7yd90ZPU_ = {
  co: "DE",
  kid: "R7q7yd90ZPU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "R7q7yd90ZPUuLc9kHTVh8zzVx9aCfIAv5k2i-6rlx8s",
    use: "sig",
    crv: "P-256",
    kid: "R7q7yd90ZPU=",
    x: "_eGWuKcNV_od7Eh4EJuiqBPv-0yP4q-qzhOlNFdkzus",
    y: "lsupfoYY1R8XX8aeFw1bzlFdg_cH3_Nf7TXwbnOKQpg"
  }
};
var TGjTR_Re_yk_ = {
  co: "DE",
  kid: "TGjTR+Re+yk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "TGjTR-Re-ylVtGGlp2kxyH-dzipfuMVRxauV7VAGkVg",
    use: "sig",
    crv: "P-256",
    kid: "TGjTR+Re+yk=",
    x: "h4UMl8PsQUsu36Hq7xK-dyGWGrELxsfzVOny20ZnkHg",
    y: "cgWMQVCBqBxGJe9G6c4xQSTeFixrYpWQ_9Gi1hP_spM"
  }
};
var TpQIkAHAym4_ = {
  co: "DE",
  kid: "TpQIkAHAym4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "TpQIkAHAym6d8Ydd8vJXs1olxVD1hxo1c2OO8yx4qpY",
    use: "sig",
    crv: "P-256",
    kid: "TpQIkAHAym4=",
    x: "s77Dr92zb-HOBL9gdfCWOwkna-9D3Kdq0HgUqpVByi4",
    y: "5KspETwBSj2QQO-9asqActLhxYXWCMzQD83R4-yqz7A"
  }
};
var Uj77p_qIQNs_ = {
  co: "DE",
  kid: "Uj77p+qIQNs=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Uj77p-qIQNu6AVowa4D5pty5y_tgjNbdxJ-xvOdkiic",
    use: "sig",
    crv: "P-256",
    kid: "Uj77p+qIQNs=",
    x: "opaKkUUE4nCgNpRBE9ugmShuJd907aOocVvFvxPLxiI",
    y: "eaqkNqavxlbKuVX_9Ff29Vd6wKCjvGzL8T-I5E1k8ak"
  }
};
var XkVWZqUeeFc_ = {
  co: "DE",
  kid: "XkVWZqUeeFc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "XkVWZqUeeFc0suP6qTJGG-C723_K_z2geLisE5wmluI",
    use: "sig",
    crv: "P-256",
    kid: "XkVWZqUeeFc=",
    x: "h934IiMCsXp977pDeG7Wi11S-uGGoem6nSNbtCILcSQ",
    y: "-PvxahpSzgSbyGT0od4Ux8dle1fty86oukdnWoTp6P4"
  }
};
var XuCERkHu8kY_ = {
  co: "DE",
  kid: "XuCERkHu8kY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "XuCERkHu8kYEmcX5BsPTeizGD9m6v8WAeVrRNXGUiMM",
    use: "sig",
    crv: "P-256",
    kid: "XuCERkHu8kY=",
    x: "yV_EBSORniEE7SMMNmvSWT3dOAuDuviDHFv7rvnrcZ0",
    y: "sMn0JCI8mD5K7VaxsIjXcDnGxyq3gdnlupYv_nw0DxA"
  }
};
var Yr8a8Rd_zqI_ = {
  co: "DE",
  kid: "Yr8a8Rd+zqI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Yr8a8Rd-zqJs00pi4eXOLYCEtNmQvtqv6gjDTY-HHa4",
    use: "sig",
    crv: "P-256",
    kid: "Yr8a8Rd+zqI=",
    x: "5eOmRsTsPlyUVzKnWK3xYlY04-DOffgg07nWx4FTa4k",
    y: "qLl0PZ3wsZjB4Kbmb9kcW1Us2M3sI3JimpJzRGA3QnU"
  }
};
var ZDoFfkn_yhY_ = {
  co: "DE",
  kid: "ZDoFfkn+yhY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ZDoFfkn-yhaz3n8XD9R3y3dJeQj_dusOVbWxVzKzAWs",
    use: "sig",
    crv: "P-256",
    kid: "ZDoFfkn+yhY=",
    x: "HZM5AMBImcqdKPFM6P5xx0LmZxo81NcnuydrdPUQaaY",
    y: "tDYbEXLbl-KgfGEndqRtdopcEknxHII7vCOwLBSUgDk"
  }
};
var bKmas9wa5tc_ = {
  co: "DE",
  kid: "bKmas9wa5tc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "bKmas9wa5tdCg-Mqip2wZ4NF2HwirVKeBee36ose3WM",
    use: "sig",
    crv: "P-256",
    kid: "bKmas9wa5tc=",
    x: "aOhuajeY34pPu_12SnuMv2qlG8ErMOj7s0eAEM2679Y",
    y: "Fc7ImViyKdUtYzVrKCCSUxIi1lLY9ZqgrDDkd4AOwgQ"
  }
};
var c1XrnEBoj_c_ = {
  co: "DE",
  kid: "c1XrnEBoj/c=",
  jwk: {
    kty: "EC",
    "x5t#S256": "c1XrnEBoj_ee3RFQDz8mlpbduar3rP65U0Lvwq44GJs",
    use: "sig",
    crv: "P-256",
    kid: "c1XrnEBoj/c=",
    x: "UtMktlZKpvOfwhumIvsvpKMWE1LyMq32RkRCbVM5TBA",
    y: "cR7AlGHV0o26jyt3GfLWJApHGJcpbim0Dvvh2krBo0k"
  }
};
var dhSzPDr4G2M_ = {
  co: "DE",
  kid: "dhSzPDr4G2M=",
  jwk: {
    kty: "EC",
    "x5t#S256": "dhSzPDr4G2ONgZYpJtfqI5rADFSfd---DA8BZR7VAZQ",
    use: "sig",
    crv: "P-256",
    kid: "dhSzPDr4G2M=",
    x: "sLa_zRhSxxsmrPE_RwPNKXGblvI4JrdqfPNYpuPn3To",
    y: "ZBMW_76HddTLluwYrJphK2XCQvqFriLVtVB_sHFxyXE"
  }
};
var i5SVuCsR5TA_ = {
  co: "DE",
  kid: "i5SVuCsR5TA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "i5SVuCsR5TDDPk16KDqH_zQdgG6gOMvAPkT6OEA-USA",
    use: "sig",
    crv: "P-256",
    kid: "i5SVuCsR5TA=",
    x: "5D4cdY3G91kHagLyAGon0ufC2jqzQ17V1wjvYHOLxZQ",
    y: "mNXr5kFYaLyFVEvQFOWe92nlvvtmcjVBYOy__WZNRO4"
  }
};
var izUDZjGtHWY_ = {
  co: "DE",
  kid: "izUDZjGtHWY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "izUDZjGtHWZQQ-NkNguubTegCFdkFabjEbbro4Pay2I",
    use: "sig",
    crv: "P-256",
    kid: "izUDZjGtHWY=",
    x: "pobykjScOX2uy-5C_BYBXDRcVUVOBDWLUgUaIhP2q0E",
    y: "qBfBQQQ2AY8daXloX-DXfq7YwYr6-Vg3BZozFZ_hVc4"
  }
};
var juskqrNQf6k_ = {
  co: "DE",
  kid: "juskqrNQf6k=",
  jwk: {
    kty: "EC",
    "x5t#S256": "juskqrNQf6mMkFceGXcgvv__vSiwbjuqI-eSJXZJi8Q",
    use: "sig",
    crv: "P-256",
    kid: "juskqrNQf6k=",
    x: "gxLpjMDX1_tMRghYLQKMI0nK4UkZuK9pnAAJTC7BeQU",
    y: "Gh2BaeKSZAvM_1R3Fu-AqcE3k0SE87ODGX5ZDf1h7ak"
  }
};
var kjEx2H7huNE_ = {
  co: "DE",
  kid: "kjEx2H7huNE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "kjEx2H7huNFl-233AhNFUd1KiMYFvaZFehoCjZJ8WQs",
    use: "sig",
    crv: "P-256",
    kid: "kjEx2H7huNE=",
    x: "tLZ1N2Y7UQHgRO3yKGyRTsJWdYFGDld5kbglFGHrMvY",
    y: "UMGuV6AXJR_cU6z93V3E7II55pex8eWGTpxh4STK3p8"
  }
};
var nHmZ5K96UY4_ = {
  co: "DE",
  kid: "nHmZ5K96UY4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "nHmZ5K96UY4Dod3mgs9fFIoY30K8gw34rwYoUmEJsyw",
    use: "sig",
    crv: "P-256",
    kid: "nHmZ5K96UY4=",
    x: "x4HHLyxeH1wp_aPCCwyRxWVEcfUALP66kgwanudG4b8",
    y: "LqbxhTLFV6c4NKIRD2q1WvddgPVAbgpIwzOoxQLIGSE"
  }
};
var nPKEYm3gXzU_ = {
  co: "DE",
  kid: "nPKEYm3gXzU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "nPKEYm3gXzWH_yQisF1kcwMY6eJHqqWQRs2FQuo0Ej0",
    use: "sig",
    crv: "P-256",
    kid: "nPKEYm3gXzU=",
    x: "Jmki-G1pd9DNiLX_eT709p_ZeCd_mcjrmRLoTgP6nlA",
    y: "6icVL2dK0OuMvy49lZOXoRh7blf0ZsrjVyWMRQefG3Q"
  }
};
var nTrG8glLUls_ = {
  co: "DE",
  kid: "nTrG8glLUls=",
  jwk: {
    kty: "EC",
    "x5t#S256": "nTrG8glLUlvrsSR5KvYKPiIPR_rsm-AyFNSW8JPsHew",
    use: "sig",
    crv: "P-256",
    kid: "nTrG8glLUls=",
    x: "d-grPnJ58prZvOeLC3vi9P2mnqlvvGNfsbT0HmxAVHA",
    y: "KDQe9z09ePSIRloTWRUjBUXpe77vL4uMD6GkriI62j8"
  }
};
var npo0ZWgdQSY_ = {
  co: "DE",
  kid: "npo0ZWgdQSY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "npo0ZWgdQSa0UGAmDwQhIZnHdMwZkbd1KqrPir6cyCI",
    use: "sig",
    crv: "P-256",
    kid: "npo0ZWgdQSY=",
    x: "PdriVdFsidKrE0nr7S-75iO7-8LOtzFp99--4BLqKKM",
    y: "Cp_5gF74JCJxDecarIn02BVpPSpi3FBmw_XbcEJWgPs"
  }
};
var r9YkEJZgi9k_ = {
  co: "DE",
  kid: "r9YkEJZgi9k=",
  jwk: {
    kty: "EC",
    "x5t#S256": "r9YkEJZgi9mQZtiTcH3d-8vueMJfg1ItE9Qib3Hp_ZU",
    use: "sig",
    crv: "P-256",
    kid: "r9YkEJZgi9k=",
    x: "7f4SNNst1BMsb6Ub0yVCz01aDWB9I2_ajVbLyJpTr2o",
    y: "SsEqHEKYjNJnMvV1_nTGGJVGkFQTpraBP_358PMNrww"
  }
};
var rKMDA66RiLE_ = {
  co: "DE",
  kid: "rKMDA66RiLE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "rKMDA66RiLEWKx3M1CG-cypSfMYddvS1roloyb71bV0",
    use: "sig",
    crv: "P-256",
    kid: "rKMDA66RiLE=",
    x: "bQZPoqfjpTx8m_wAZZWk3uoDxzfpiISsNSuZg_-9VN8",
    y: "3Enn6xBxUb0MDNgIzerzo4c1THY2deDEkSVDCRLvOS8"
  }
};
var rXP9L7xddL8_ = {
  co: "DE",
  kid: "rXP9L7xddL8=",
  jwk: {
    kty: "EC",
    "x5t#S256": "rXP9L7xddL8yTzBblruK_cJIN-FiRMJ_pfTRXwfdBt8",
    use: "sig",
    crv: "P-256",
    kid: "rXP9L7xddL8=",
    x: "-fBKs9tgAlGoiBIglL4JDLpguDzBcXqCuIulrUkBy_w",
    y: "Gaybb-37Iq1P2Ar3J-9Kz8zApaKnjxKAzwn9cFl_A6c"
  }
};
var sYXcYixrOGA_ = {
  co: "DE",
  kid: "sYXcYixrOGA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "sYXcYixrOGAFoeElmKAYYmal4KvzrtFr2lg22sOz60o",
    use: "sig",
    crv: "P-256",
    kid: "sYXcYixrOGA=",
    x: "40rFr8baZEDNvONEE-Rxf5ePnZLLmqR-5Uwx_S5I2yk",
    y: "TIo2cmeHNpA9zskx5X0zWtZktPc151zSSqmcqotxhkM"
  }
};
var vjm0I2ATJ_Y_ = {
  co: "DE",
  kid: "vjm0I2ATJ+Y=",
  jwk: {
    kty: "EC",
    "x5t#S256": "vjm0I2ATJ-aFG04BjW-oSvUAOyECTAaOD33dp0c4TRI",
    use: "sig",
    crv: "P-256",
    kid: "vjm0I2ATJ+Y=",
    x: "2TqSv2wB9nB0Ev3u5VmckxWzq_L0fvl1HVI3ZBXCF-4",
    y: "5OeW6NM1AAVDwc-v3tT2g8QwiEvPjcm626VE98OQ9yM"
  }
};
var vq08l_LTxhk_ = {
  co: "DE",
  kid: "vq08l/LTxhk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "vq08l_LTxhmTdGB2otiLSrhMTuKX_Y8UmAuUnTRDsG8",
    use: "sig",
    crv: "P-256",
    kid: "vq08l/LTxhk=",
    x: "DRVIqu7uo4HOgXlXyxYBl2L1arxxvDfwfgnYHjgVKQo",
    y: "RRI_oVfWBI0hAiUvmK4Rq-UV2VO3kcyr3yrUSNTzmsM"
  }
};
var wb_2450PPrc_ = {
  co: "DE",
  kid: "wb/2450PPrc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "wb_2450PPrfgoBgStK78QjyEa_DQz2Z2TT6GxE2mVKU",
    use: "sig",
    crv: "P-256",
    kid: "wb/2450PPrc=",
    x: "lGYxcioPZFzAfJHtsB07FzUDpJlc6C18W2kcnCGEE1s",
    y: "o2oYrCumbxPlKEhoeAARjUDl_EcqTKeLfG84-1QKiO8"
  }
};
var wtYpyAmNmdk_ = {
  co: "DE",
  kid: "wtYpyAmNmdk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "wtYpyAmNmdl5iVmp-87jCSfcj8B2O2wylC7fkk9Jrs4",
    use: "sig",
    crv: "P-256",
    kid: "wtYpyAmNmdk=",
    x: "6_QS0f7r433yqdq7XKh3OOKhOEigg-VVixYEToozbg8",
    y: "UIAKgAyGWA3t1hEJzvLvH6nc3dqLlWaOePxnNd4LM2A"
  }
};
var yWCRdph8XJs_ = {
  co: "DE",
  kid: "yWCRdph8XJs=",
  jwk: {
    kty: "EC",
    "x5t#S256": "yWCRdph8XJsbsnzH7bDul9pZsflGDL_dLNWbPkP0cUU",
    use: "sig",
    crv: "P-256",
    kid: "yWCRdph8XJs=",
    x: "gMhpOktfDD7Vn7Wm-BlHabFbpOs2UmCVrtIpcOFpIlo",
    y: "_PtsBz-f1UlGbJRMUqNvOH6cLqCeXinIw7r5Qj42TYU"
  }
};
var _z8_6oww2a8_ = {
  co: "NO",
  kid: "7z8+6oww2a8=",
  jwk: {
    kty: "EC",
    "x5t#S256": "7z8-6oww2a-UMGx64UCO1I7OD-OGAWtfPDYd_AzqMd8",
    crv: "P-256",
    kid: "7z8+6oww2a8=",
    x: "rbWQM5hj5SeR23DzCV0TVKrFhfYsmNVVSbPFxwyw4ZE",
    y: "H3q7Gd26dofq8NgYWy281R2SMFn54Wime9viXIlJLBU"
  }
};
var Er5OTMwLd78_ = {
  co: "NO",
  kid: "Er5OTMwLd78=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Er5OTMwLd7_5zgX6kmv_WBiAyYesn6UnTpKQdqa-EeA",
    crv: "P-256",
    kid: "Er5OTMwLd78=",
    x: "fBeQBQBjyKpvjsCujqi15xnygRMyhjNsEy198LzTYuA",
    y: "fjI3tZcSLz2JHzvzxB0BYAOdoJ9umxwlxO-RlqqulDM"
  }
};
var cdm9Ymfwn2I_ = {
  co: "NO",
  kid: "cdm9Ymfwn2I=",
  jwk: {
    kty: "EC",
    "x5t#S256": "cdm9Ymfwn2IdP75j53-pa8iFnG3fziNR8_vG2I7UIxQ",
    crv: "P-256",
    kid: "cdm9Ymfwn2I=",
    x: "lH46JUamhvfj2ocSTxw9Eq7nVdP9OzBOxQ_zaWNXN5s",
    y: "nGoJWup67janw4mV0DHM-IKWeqXI7SZfsa2tgE82fT8"
  }
};
var BKBFhNFXWAU_ = {
  co: "FI",
  kid: "BKBFhNFXWAU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "BKBFhNFXWAXpNBeRrjYnzNa6_qBqchgpbpS9oXn-FNM",
    use: "sig",
    crv: "P-256",
    kid: "BKBFhNFXWAU=",
    x: "epKcLfnTZIej9gSNJVmR8sRYMMgztnG9h0ZGWx7D1X0",
    y: "YN9lfxrSXOeR5KB_r6pG5ISiZ7wwSdSXbG5CipgSW9k"
  }
};
var ODqaG8mnbro_ = {
  co: "BE",
  kid: "ODqaG8mnbro=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ODqaG8mnbroTgFCocQOAs0JYAh5GgBqHf6Mgp22ETNQ",
    crv: "P-256",
    kid: "ODqaG8mnbro=",
    x: "U_f_KsmP3NasU_jZo7aulTrd9GHoznfnwWvX8xmHtK4",
    y: "PRKKGzABuy4V56S0PmkcJpp0jHCFsvMD8TPEAzAVLcg"
  }
};
var KG9lzdohSY0_ = {
  co: "PT",
  kid: "KG9lzdohSY0=",
  jwk: {
    kty: "EC",
    "x5t#S256": "KG9lzdohSY3NIqr8IxfKJSFBX-svQMeALqy-rgoTpTs",
    crv: "P-256",
    kid: "KG9lzdohSY0=",
    x: "njK8A8ato900a-wQ1IaxJyaeUGQ5lwsYOCRlq47X4DI",
    y: "hnvj9y9trrWHBk1rQnpAamq3BM80hx_1_rOWnhEIGGA"
  }
};
var Jjql9rBrjHI_ = {
  co: "BG",
  kid: "Jjql9rBrjHI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Jjql9rBrjHLQMj5L09VoNRyb32McfGVQPT93jCLQ5lo",
    crv: "P-256",
    kid: "Jjql9rBrjHI=",
    x: "myxlsE2inBusapxY7LvRiPN0s-dsHnakaaa9M_5NDZY",
    y: "U5Y0mQs3iu-31jvTBUXBgl600GlzRNxYZFePmvdoUWs"
  }
};
var NAyCKly_hCg_ = {
  co: "DK",
  kid: "NAyCKly+hCg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "NAyCKly-hCi4iWbIctz-PDhNvI3hpJZlcvsdX8DfyDA",
    crv: "P-256",
    kid: "NAyCKly+hCg=",
    x: "BmdgY_VORsecXxY_0xNNOzoJNRaVnMMmHs5jiXrGvaA",
    y: "zstY8w1Dsr0fvicYH9PmLhsqef1AGNECIe-W_iUJ5Rw"
  }
};
var _AfAwcpWOv0_ = {
  co: "LT",
  kid: "7AfAwcpWOv0=",
  jwk: {
    kty: "RSA",
    "x5t#S256": "7AfAwcpWOv3Yzs6M0T1pLauzkl4EoOLZ47KmcP-lg8Q",
    e: "AQAB",
    kid: "7AfAwcpWOv0=",
    n: "sIcppmCVhq96vMc4NtW8X-yV6O1oC7hfKnewK1_pxfByqlVTPpETDLAjNq9knNQpCs7vGjadCbDAylsQRK7qfU3sUUKamh6FgDhFo1dzC4mUHCy3XBL04XJie2eT_a6Wgjrn6NjEFk5M4Jl4N8u_RbfaVxqaOjUM0hBfuzfZeL2LT30POqDHj1hcyod1fIbG4vv2Upqxe3OX_WLr-WzSPbRkPwxcJjmYeNYODT0rEcd9VSzJpljaK-eDVwxT0wMRnCH2QLxdw8sR-oDYDTZBaabeHYyZ0CfYzSoBOZT3fVMAbjkVAl8GFyH8tUm4lMQbYEMbl_FkftcZQicaqvRdQQ"
  }
};
var lshLbYfCWRg_ = {
  co: "LT",
  kid: "lshLbYfCWRg=",
  jwk: {
    kty: "RSA",
    "x5t#S256": "lshLbYfCWRh3u6SgX7hMRwaahK1SSpscpRRNqleCix4",
    e: "AQAB",
    kid: "lshLbYfCWRg=",
    n: "nhBpxzeGXNlQs7U-j_Av1BUZ6CCgMR3bFLT4rRjO8KQ4IpAKqSCQ3j57MJqdumk3AUfHO5zhMZF4Awy0wqV3oFlyP49_56KKZxGARe5UkyfPjVbl8AZpLmgYoS_Ior53TLrwmT_-zvXynzFYbOi2OtCtqanG-9OUhSVRrXEEB-56PpCltE31wemX1behxDuCbE4tuqyTYODFw9Le3dGCbHWdjxi5W3XIUNo8j2u2PKue0KS76Xv0zAYItTgChgv7mM55_G109m4MfeU7AHah43bJth8K8y-SxG3RYHskmNZ7sfn3w8w7WyW7D3_tKHcMt3hgIh9z3DuWeR1C296JyQ"
  }
};
var _2vdAOY__gI_ = {
  co: "LU",
  kid: "02vdAOY/+gI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "02vdAOY_-gKmnwVyS8JSbr0SeMhaGsNpKTlxF-VgMXE",
    crv: "P-256",
    kid: "02vdAOY/+gI=",
    x: "5EtYbOu-RuUcFAu1NN1rqsuKqNzpl0Y6bgg9wNKcmVI",
    y: "83wTvNYx9nXLqR7SpaezMuShowsgQCr4yVEhP35w3eY"
  }
};
var _kAwFy_vLpg_ = {
  co: "LU",
  kid: "0kAwFy+vLpg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "0kAwFy-vLpiPZ7c145j7J-2K9HgoEu9TdVqwOwCC50k",
    crv: "P-256",
    kid: "0kAwFy+vLpg=",
    x: "vIs_H8NhtE23q5tR84V9WwbbdGDc3hh7mjrXom4PRzg",
    y: "xkbkr3wvTiBS7UczqIbHZ23BOthVjfhc9PboCXGqobQ"
  }
};
var bBnmkeVMV6A_ = {
  co: "LU",
  kid: "bBnmkeVMV6A=",
  jwk: {
    kty: "EC",
    "x5t#S256": "bBnmkeVMV6BQTvnKKOUMvtFNkuhrJRUsdWYUgvUwQsk",
    crv: "P-256",
    kid: "bBnmkeVMV6A=",
    x: "HTBJY0Z-T5I8EmqQmrbZAr8equIcKKE-YriIGw_AKJw",
    y: "sNGQI9Q3djEUzN_gBIjQEcVyBdPGtq4VLxQsshwidgw"
  }
};
var ln8K_9SqfuA_ = {
  co: "LU",
  kid: "ln8K+9SqfuA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ln8K-9SqfuDXnhld3cqBgP_xScoV_pHHZdGKsDEQuYU",
    crv: "P-256",
    kid: "ln8K+9SqfuA=",
    x: "ExXQauou3f3g77qOsZ0rSPFjoTDiKQDhG-Bpf34Yyoc",
    y: "hZGDATC_PdCmqpmS-LnswXPMcYNX9e9KnGVhyC46eKs"
  }
};
var _5QCxBrBJvA_ = {
  co: "HR",
  kid: "25QCxBrBJvA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "25QCxBrBJvBBALjD4A0vE9it6S_EOnuAU4l0vQbPwmU",
    crv: "P-256",
    kid: "25QCxBrBJvA=",
    x: "t5hwD0cJUB5TeQIAaE7nLjeef0vV5mamR30kjErGOcQ",
    y: "Xhnt-3Q65hQHjqiC2o0E4gV83Jz2jMVlHfUivWUXsc0"
  }
};
var MrT00mhDxLQ_ = {
  co: "LV",
  kid: "MrT00mhDxLQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "MrT00mhDxLSKKsuPfK3tumLbTbH-9-TT9ZjfgQJFevc",
    crv: "P-256",
    kid: "MrT00mhDxLQ=",
    x: "5_m2YdN8L81Ajoi-2brFJbul628alfXRXU26t7hRYEs",
    y: "77G--LUlZtg5vXG7oa4BSfv8F3nHcYdLU0hwpDHwdIU"
  }
};
var hFpY_ySOrwI_ = {
  co: "LV",
  kid: "hFpY/ySOrwI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "hFpY_ySOrwJ3CHBv31aUeAOJpHV2R4WK5KVg6iWfkC0",
    crv: "P-256",
    kid: "hFpY/ySOrwI=",
    x: "PUwE7htr-kD1eVnJBfRf5tx0kA17qu4p1wRz3EKPxsI",
    y: "csiM5yKq_fh7JzHe5PSA_39HXqoz_Hbpc0tnBa1VZxU"
  }
};
var CvmI4xOoMj4_ = {
  co: "FR",
  kid: "CvmI4xOoMj4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "CvmI4xOoMj5qGN9oHxdUlyJN94VP0t8CBLwXEdpc7Ng",
    crv: "P-256",
    kid: "CvmI4xOoMj4=",
    x: "sNCxAUi67vlLEBaGIqAk259l-dk6_Yw7hZL4JFqT6M8",
    y: "5gVyHOz_pmbSvdNyl4lWXpW6BAjjqExv_tp1RBYWmbg"
  }
};
var G3jDFQ1oK0Q_ = {
  co: "FR",
  kid: "G3jDFQ1oK0Q=",
  jwk: {
    kty: "EC",
    "x5t#S256": "G3jDFQ1oK0TFTZH73fI4Pqf5jaqrgqpWbURX9kQkGCg",
    crv: "P-256",
    kid: "G3jDFQ1oK0Q=",
    x: "EGSSdtJPZeYWU3QrR2cR4M2Cv6sYKuY870qkBKKREtk",
    y: "UnpeAsaX5vBJz2fjj1VQ18QK1nWEdDKCyujsfWhCJJs"
  }
};
var IMgNr10pfPQ_ = {
  co: "FR",
  kid: "IMgNr10pfPQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "IMgNr10pfPR2uyENjReGb2roflG5VgtJHyi4Ss6alJg",
    crv: "P-256",
    kid: "IMgNr10pfPQ=",
    x: "Cmvd9b56sHucHEi7GBjqapZy6IAZ4MFIFg7Acr85jXo",
    y: "f6AUjcxQT_Qp5LMC0eb8Jq_N-rkvSS-bHXcy0-CuPuQ"
  }
};
var YVpBYnLh1Hs_ = {
  co: "FR",
  kid: "YVpBYnLh1Hs=",
  jwk: {
    kty: "EC",
    "x5t#S256": "YVpBYnLh1Hu5lKpwfXKMPA7U0WaOo7xXLQ_9yicwvHU",
    crv: "P-256",
    kid: "YVpBYnLh1Hs=",
    x: "8SjDdFFGxTunJ0RQyxdGDbBKVUjHz9gKydhpKuTZAvY",
    y: "GTMxlVVezWISRkKjqeDsesFN8vs2Ouup3wHmgD3CDUc"
  }
};
var e_bFdywyJQE_ = {
  co: "FR",
  kid: "e+bFdywyJQE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "e-bFdywyJQFs9jVxPy4gfyHW8eqMMGDE04puvDqkMXo",
    crv: "P-256",
    kid: "e+bFdywyJQE=",
    x: "RuPqA8PXwAZlb3MnIn-3UajY2JjRkt4v3rI4nUuQjh0",
    y: "t52Wf96w6mifCW6MPqShYHVgOdbGeqUCMiF--sGH6wo"
  }
};
var eQOY6BDp_vM_ = {
  co: "FR",
  kid: "eQOY6BDp+vM=",
  jwk: {
    kty: "EC",
    "x5t#S256": "eQOY6BDp-vNhfby793-jYrh53j3w7EKc8H--NBY7gdI",
    crv: "P-256",
    kid: "eQOY6BDp+vM=",
    x: "x2sQ7slwQ-IQrSLZwgIfafTa2g144vB8OXnI5WU67BE",
    y: "302s7D3HzW1lI-bqv3xQeRBG5WkhKUQOWMIcnwBCLeI"
  }
};
var fGLuvg6n5wk_ = {
  co: "FR",
  kid: "fGLuvg6n5wk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "fGLuvg6n5wkxhiuHx3qRTCmFHOEcu1b_Yqkf4dShYg4",
    crv: "P-256",
    kid: "fGLuvg6n5wk=",
    x: "ImIFaugzwB5f_VyfQ3KTfTSoukwAPVSgHZWrtrc2j4E",
    y: "bgFKcPzm0ZwPaQYzfx3VHNc3JfUjv77AhJx5F4cY8-E"
  }
};
var lrxgMs2Duac_ = {
  co: "FR",
  kid: "lrxgMs2Duac=",
  jwk: {
    kty: "EC",
    "x5t#S256": "lrxgMs2DuacfGrkjdqhA1Fb4FZZhUJi0x-IH_TDWXCw",
    crv: "P-256",
    kid: "lrxgMs2Duac=",
    x: "7jO1wt-KJfoKi9O5dydU--nfENeQWdVACVEwAdquyYQ",
    y: "-ghFn6NcRtbVHDISiCO-1yWxivh9p8gLgrCdIE30-ZU"
  }
};
var _GkJs9YsYS4_ = {
  co: "HU",
  kid: "4GkJs9YsYS4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "4GkJs9YsYS5Xhqs7YqGwjuJIF7eYjY-P9lXONAkWcD8",
    crv: "P-256",
    kid: "4GkJs9YsYS4=",
    x: "yN8tlsHEJlHHmms_54jGukHiHadMS0ckg70EQkyDuX4",
    y: "wNNN7ggomU6JCrqyEtfRDgJUBS0wi61Se9gnEk-_h_w"
  }
};
var Z7k1XpIWZOE_ = {
  co: "SE",
  kid: "Z7k1XpIWZOE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Z7k1XpIWZOHPEXBg3qNQHkGEOrdXrefPiS6ghhje2mk",
    use: "enc",
    crv: "P-256",
    kid: "Z7k1XpIWZOE=",
    x: "aLOo1IGTspZSdr2BqdAvKjZjHfW_Zq8VDrI6nEhBlXU",
    y: "K91Qg5c4616Ob-osdqhfUQskibB4GcVK6lkKRUG62zM"
  }
};
var _0CNG8dcdn0_ = {
  co: "SI",
  kid: "90CNG8dcdn0=",
  jwk: {
    kty: "EC",
    "x5t#S256": "90CNG8dcdn1gEIm_D82XAsQ9eOd7XE9urjXV0MZyuCU",
    crv: "P-256",
    kid: "90CNG8dcdn0=",
    x: "EmxEg2iFDaol9DVnrqIY5zkPXrBANQlakmUfrBhogaA",
    y: "wtmWe35ENiHDiYBBeK0Esm9-IOYw8PPIO0GiJJ2iyjM"
  }
};
var _CDB1hL_uKU_ = {
  co: "SK",
  kid: "6CDB1hL+uKU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "6CDB1hL-uKWVBtXsXk3Oiz_L5ozZgTsG5dPxG9YoWMY",
    crv: "P-256",
    kid: "6CDB1hL+uKU=",
    x: "6qxT6sSK3TDheWFHTBkfveooRhtUWqEqrELD9B7aAk4",
    y: "8Yz0tzARE7Zp1m-J0cwSDbxcKyw8UAqk1_CXr6d93OE"
  }
};
var PBpDVqnJ7Us_ = {
  co: "IE",
  kid: "PBpDVqnJ7Us=",
  jwk: {
    kty: "EC",
    "x5t#S256": "PBpDVqnJ7UubC6KtAsZiBINQLJPN0TylSWFH9AgYkxE",
    crv: "P-256",
    kid: "PBpDVqnJ7Us=",
    x: "TPE5ItolrGzLQLPqYxOT-orVmYJusLDsPWLwrK-bbJI",
    y: "gQbVwbKw9j8v6LFmK_SxeX3zkac8ZgVEJs6eyuLj4iM"
  }
};
var eNNsg2jd4wA_ = {
  co: "IE",
  kid: "eNNsg2jd4wA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "eNNsg2jd4wBSYFAv2Bx_NsJ13l5-6KoTQZGxOAm7BDU",
    crv: "P-256",
    kid: "eNNsg2jd4wA=",
    x: "ZfUiZPt-jvUVd8fpPkv2xoXxluGZwuvys0oXWRnPOBc",
    y: "A3hpnDLMye4EDSktMTmd98bWP_a4Yr5o1VOuyB3ATPE"
  }
};
var EzYR1uk_E0I_ = {
  co: "EE",
  kid: "EzYR1uk/E0I=",
  jwk: {
    kty: "EC",
    "x5t#S256": "EzYR1uk_E0K-BbHtFA8_bV6Gl4veveR7CiYnwg74dYQ",
    crv: "P-256",
    kid: "EzYR1uk/E0I=",
    x: "vW8QeGk0YQMGQ_wG2vpPalRdoKNfd48O2qW5uP6gmgQ",
    y: "ZtTp60K9oLR91ysTX1Q3rjbqnqJrEkZA1mtw16sC3OA"
  }
};
var Ll3NP03zOxY_ = {
  co: "CH",
  kid: "Ll3NP03zOxY=",
  jwk: {
    kty: "RSA",
    "x5t#S256": "Ll3NP03zOxYSw6HRJR3HbI-TjLwk_Zni8IcXMMpL2ss",
    e: "AQAB",
    kid: "Ll3NP03zOxY=",
    n: "tk_51stJXU48RqD2lh4IdsxFrjlJfmTCrLr3cQNEXkrEoI3OEV8NnotE1RjVmQrqLTT04oxpWlcbMolXtJBtu3rOiLNwQvyVEbj_xSc6KT84Tp7GBo1P_kkunY-Vmab6HUCV_oGZYmsdiUP_OnTPX6Wy6delDhnrgHIDti73_TSsG7Zl1V6km7-KIkjAkVCEDkkUD7uffd4G-GBZ0B9F1KOT0IcFQNvDm0zlROVoGFlmPS8DWlrLHuIdMbB281uiDjcN-kNUt7rUyyj6TFgX9WCgEB_5mQBMRaaXK1zeDTaNkmC2S7IWxhMQsMBXJyAdbD9AnQOZc6XRjBauO7gz0w"
  }
};
var GvVR3e6VJIM_ = {
  co: "MT",
  kid: "GvVR3e6VJIM=",
  jwk: {
    kty: "EC",
    "x5t#S256": "GvVR3e6VJIPphwZ9N0I7Y2mN8V4LjB_FFcsCdFhlr20",
    crv: "P-256",
    kid: "GvVR3e6VJIM=",
    x: "1kpyGGbMShwokxGdJmH_WPJDcDONYigpXr7Z8jiiX9M",
    y: "D9X5I77B3eBpHHxx7a67LK9hS0f5ua4CNyIOcQyyVnU"
  }
};
var QacbC7DdD4U_ = {
  co: "MT",
  kid: "QacbC7DdD4U=",
  jwk: {
    kty: "EC",
    "x5t#S256": "QacbC7DdD4Wz73sW1EfU3R5hwqlFmmvgRuv7mqJyHXY",
    crv: "P-256",
    kid: "QacbC7DdD4U=",
    x: "fapP8-QeyFgXVvY41YkQudlUUh7IZBBpIdOJ34xYmxA",
    y: "hLh121VBarfyUp26VbBrHe2QT1Iy9ruSrPZqATAxDy4"
  }
};
var UZ1cSMaPcaQ_ = {
  co: "MT",
  kid: "UZ1cSMaPcaQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "UZ1cSMaPcaSGpl1kt7j-WgZ6SXJ2lDQeGtQpcOwQc68",
    crv: "P-256",
    kid: "UZ1cSMaPcaQ=",
    x: "1q1nvgXLGIbibQuYQU-f-Xs-mcbPmukAc3KQAyy_5KY",
    y: "R_p-ReGxuFdFyI6YV9Pd2MR4dSWx1js7oSrmp_RW6Mg"
  }
};
var bfoj2trt6bE_ = {
  co: "MT",
  kid: "bfoj2trt6bE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "bfoj2trt6bGT-vf82PeELpWi79O_9NDwlyA_2A8w6Cw",
    crv: "P-256",
    kid: "bfoj2trt6bE=",
    x: "4DsoM1rJFjHyQPcX6WKDWZkouBehfQGxqOgwFAYyRKU",
    y: "260ri_rZM_LCX6PHY37LkESw0rmcbndCDrDAfWLEzKY"
  }
};
var ccgQ13tmkU8_ = {
  co: "MT",
  kid: "ccgQ13tmkU8=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ccgQ13tmkU_IGa3FP9BzbeUCWaivVvc81P6KCF_934Y",
    crv: "P-256",
    kid: "ccgQ13tmkU8=",
    x: "Xj9fU7e4KVYe1VakCDZjYquHzkoxSHT8D33zeMDfyLY",
    y: "2IvxklaSkLT8AT2ZT8eua9im9sGqyCvAYMUoLELzCGo"
  }
};
var f6J92LRKpj0_ = {
  co: "MT",
  kid: "f6J92LRKpj0=",
  jwk: {
    kty: "EC",
    "x5t#S256": "f6J92LRKpj3rKUWUXOq0_mXKxXxvwaebEKm1nh1DFH4",
    crv: "P-256",
    kid: "f6J92LRKpj0=",
    x: "DSjY8ob2FU6g06KQpeZ2BAjhXnNxdEOMdex6l563qlM",
    y: "7zbGOmdsY1aA58fRJZ7OoW3kYzcA_i38KvE5_dkH5OE"
  }
};
var HeWuzGwEM5c_ = {
  co: "IS",
  kid: "HeWuzGwEM5c=",
  jwk: {
    kty: "EC",
    "x5t#S256": "HeWuzGwEM5c4ZAy3dWtSKZ7Rc1OowEcVHr-bPRr_zkc",
    crv: "P-256",
    kid: "HeWuzGwEM5c=",
    x: "vwlwjQL5cId7nINp_A_b-XNY_WzgX9sIOde8ggZmZjU",
    y: "7yGIQ4c-xb7OdqM5namrQ6d8iMD6a-pwDJmjU49CnWY"
  }
};
var Pbydc1LscXo_ = {
  co: "IS",
  kid: "Pbydc1LscXo=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Pbydc1LscXpFpq56-LRLzLtXTAUvQLxIJchUVLo1I7Q",
    crv: "P-256",
    kid: "Pbydc1LscXo=",
    x: "O42X7C2X5bSDTnfSJwnk4qAjSk2m11Cy_mmFqryl7J0",
    y: "TIa2Q38u-5MuLktKNYltfNRL-dZgIltCd4t0nimHhDs"
  }
};
var NJpCsMLQco4_ = {
  co: "IT",
  kid: "NJpCsMLQco4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "NJpCsMLQco5pJbcmDRgT7bJxxUQKoPU8f92i_qiXabs",
    crv: "P-256",
    kid: "NJpCsMLQco4=",
    x: "nL9-WnIp9fvbcocZSGUFlSw9ffW_jbMONzcvm1X4c-o",
    y: "VzjxLOwuP_N_j8UvEsHmtoYJv7SreDyNM_MIJyHoaI8"
  }
};
var vvYa1vaWkGg_ = {
  co: "GR",
  kid: "vvYa1vaWkGg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "vvYa1vaWkGgsAumqgApI-8JmS1mJur496VbRXhZNL4I",
    crv: "P-256",
    kid: "vvYa1vaWkGg=",
    x: "aI7Y-lpY9cv5h5gKDrAzpkhl5bFPen_ohAMuJXU4uFc",
    y: "0LtFJ0gwhbf2x01nKisWHIpPGH5xflGUljihNzLJZRE"
  }
};
var _IcqIBnnZzc_ = {
  co: "ES",
  kid: "/IcqIBnnZzc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "_IcqIBnnZzefMCgbTN9cCnD5PZL964iGmySbY2lLPO4",
    use: "sig",
    crv: "P-256",
    kid: "/IcqIBnnZzc=",
    x: "bxlQ_UTz0AxZWF-xQs-w-xveq5Eche9zf16LnDFYY_I",
    y: "vKWeperG9ipV8PGf5MKKc827-Swl9VcS7BjvUbPTsy4"
  }
};
var _IsdmTYkAAM_ = {
  co: "ES",
  kid: "3IsdmTYkAAM=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3IsdmTYkAAN0vEzzv8wckxEw1-U1D1N-KsDzC-YRZaY",
    use: "sig",
    crv: "P-256",
    kid: "3IsdmTYkAAM=",
    x: "ManlPIcO9J8UBpHCAbku_KkAfiBrGLIre1buTIzhhok",
    y: "3C9GCDvg0Pbj7OlH8zyl80Ku_dVeSOWr4ZqUOo9sxbE"
  }
};
var _Qmniw7B0gc_ = {
  co: "ES",
  kid: "4Qmniw7B0gc=",
  jwk: {
    kty: "EC",
    "x5t#S256": "4Qmniw7B0gc96RZu354uwKsarncrg0dlvXm6XHqebtg",
    use: "sig",
    crv: "P-256",
    kid: "4Qmniw7B0gc=",
    x: "GwQNm-R4gtY5wWQTeJ9_kH1TqtnzC97I1EZQTE54p2Y",
    y: "yYV7y89iBZEOwkEHm0pO3MIIpEwznL0EoOdCcLqTDXw"
  }
};
var _ag2wJkSHtk_ = {
  co: "ES",
  kid: "6ag2wJkSHtk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "6ag2wJkSHtnU_JHYmO9xwHnnQ8YRJORgaz464cMIlic",
    use: "sig",
    crv: "P-256",
    kid: "6ag2wJkSHtk=",
    x: "qF22rG5bDXpWn_tKy358h2KwYyaSKzCZV0HJptUQq7s",
    y: "FsX3gxPOh0qHmwa6Tr6Y4WV9v2ZExf2EZZIdM7Z5HJc"
  }
};
var ARrNkCRtprY_ = {
  co: "ES",
  kid: "ARrNkCRtprY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ARrNkCRtprbn6nuUoq8yW8dCGZKQ7JNgXDA7bOrTl-A",
    use: "sig",
    crv: "P-256",
    kid: "ARrNkCRtprY=",
    x: "blis8RR4Oc4Xqq4RZdhrJ0DnkAvK4vY8AamWbFg9T7M",
    y: "htey2vEyWE6txaiSXeSrbUz-9RqI8URdERCqRfrsALc"
  }
};
var BEnvMVnNFK8_ = {
  co: "ES",
  kid: "BEnvMVnNFK8=",
  jwk: {
    kty: "EC",
    "x5t#S256": "BEnvMVnNFK-d3PwvrxJrKsBwsUarHBGZ3M_4-wsNsOY",
    use: "sig",
    crv: "P-256",
    kid: "BEnvMVnNFK8=",
    x: "e1XUTCn6DkdbSOKlyzczFWQfDvtP31uGdjzVCzAkuxo",
    y: "KzXhF9xfNu4J8nC_5k80ZvJXw8c-uJRFHE8MNCO7p8A"
  }
};
var GMFMBu1RlCg_ = {
  co: "ES",
  kid: "GMFMBu1RlCg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "GMFMBu1RlCjYQ-npp4hLqoyKY3kXPHgMjT2A-8E58FI",
    use: "sig",
    crv: "P-256",
    kid: "GMFMBu1RlCg=",
    x: "t3OX-XF_LZlHff6ZWiHRqQu4WBrgzNZYz4wFJkwkBmk",
    y: "P89ETrCyeBZcDiz7NnFBCCFdD7tXJp54L2uvhM0KWwA"
  }
};
var GuQPQRxbMsU_ = {
  co: "ES",
  kid: "GuQPQRxbMsU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "GuQPQRxbMsVgY7dhAoT1J_TizNHhCwZ5FMJYbJK2dew",
    use: "sig",
    crv: "P-256",
    kid: "GuQPQRxbMsU=",
    x: "KMpkfLlexSZAyOl3FjSomlb4P8POpQb7PYz1bg8uca8",
    y: "kv5f4aT4ltFNgseYElb6HRCTiXXGzDAoEaBhx3cA_tU"
  }
};
var IaGR283U1jA_ = {
  co: "ES",
  kid: "IaGR283U1jA=",
  jwk: {
    kty: "EC",
    "x5t#S256": "IaGR283U1jAgl3B4ZTXhMyLC3l4UtsZendAbZTVGsL4",
    use: "sig",
    crv: "P-256",
    kid: "IaGR283U1jA=",
    x: "j_wPWM6e8JDYxW9673ivEvwlu2JAZpsNBrr2sQW5ppk",
    y: "Luq3KiVCseym739mcdQCXiEu_j0KtojXLoHw_kQv1X0"
  }
};
var JHd4CkNzadI_ = {
  co: "ES",
  kid: "JHd4CkNzadI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "JHd4CkNzadJokWCr43qHdjraCRDd4ATWBIRUJNw2HP0",
    use: "sig",
    crv: "P-256",
    kid: "JHd4CkNzadI=",
    x: "DvCuOC6NlQCaL18-CEn4sbjC3NNnN4jBAmZo6lrGXbg",
    y: "yHwEN2Fpl3N4Ki50havOBBFevtjxcvcsi4KuCZhQHww"
  }
};
var MtI93IMknMk_ = {
  co: "ES",
  kid: "MtI93IMknMk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "MtI93IMknMmRFOYlHBhFWYiDA71bBOhX_eEzzPx19NE",
    use: "sig",
    crv: "P-256",
    kid: "MtI93IMknMk=",
    x: "62orr7HL0POyQCqmgbbEqfcbcdcT4vyfQZEPYfxk69Y",
    y: "Ub_U_CMup1gMhIxdFcb5J3woP8fbooORxVq6XnVthKc"
  }
};
var NCc6YSsVioM_ = {
  co: "ES",
  kid: "NCc6YSsVioM=",
  jwk: {
    kty: "EC",
    "x5t#S256": "NCc6YSsVioMqVU_0VQGgB-WbsvN8-1WdphfeCNanEsk",
    use: "sig",
    crv: "P-256",
    kid: "NCc6YSsVioM=",
    x: "Uvljql1ZGpwzC92AbO4J751kqnIEXaCI8hYUIEArhRc",
    y: "qiXMeagpQBkpAxXG60z1fVrlLZg0PzaaFfhHo6gZpco"
  }
};
var YRYidQ_wetg_ = {
  co: "ES",
  kid: "YRYidQ+wetg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "YRYidQ-wetjtUYj1OKaH-l1KNfRfWWaOpn3sUhRGqEw",
    use: "sig",
    crv: "P-256",
    kid: "YRYidQ+wetg=",
    x: "tdieg6q-5HvrfAd3ufPZthIWeQX4B_ytBp8iYAGpaJk",
    y: "pZCJnpZsj1nQABB-CT17nFzrAHD9bTerzpJNHh3l4B8"
  }
};
var YU9_X9nepqU_ = {
  co: "ES",
  kid: "YU9+X9nepqU=",
  jwk: {
    kty: "EC",
    "x5t#S256": "YU9-X9nepqX4bXSv-RaEcJiP23gjUPjMXsGfo2FQSRw",
    use: "sig",
    crv: "P-256",
    kid: "YU9+X9nepqU=",
    x: "gOuoVfBtfKWYpcffhNWfiCf4g4oZBdaPcdrn0HBtkQ8",
    y: "_cWKehZXxQD9WXtvS2jNXppxcY8kDVldynjZqHP7xWA"
  }
};
var ZcfkloEvfGQ_ = {
  co: "ES",
  kid: "ZcfkloEvfGQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ZcfkloEvfGSuXvyPZV3YD_ujHUwWcu2lu63rTVLxktI",
    use: "sig",
    crv: "P-256",
    kid: "ZcfkloEvfGQ=",
    x: "V61Sl3v6NzBqyCbqSb8_fBodGle-b3RJ7Utk-uExDwY",
    y: "zsc0v_9hlE0RSluN6abJMq9xutP8XiQmnje0vQr7LHY"
  }
};
var e9SH8dtWwdY_ = {
  co: "ES",
  kid: "e9SH8dtWwdY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "e9SH8dtWwdZ0IzPID5f-Jrx3ZXdcsBN_BvtYQj-hK7s",
    use: "sig",
    crv: "P-256",
    kid: "e9SH8dtWwdY=",
    x: "HZjrINN6u-ZGfRqaYqgqL-yZZCDlu-PKPCkVS_ysPos",
    y: "K6J7cJYc52z7KuVvndjcsV3mlAE_pU8kSstTQMThagA"
  }
};
var hgpHHrTb4ws_ = {
  co: "ES",
  kid: "hgpHHrTb4ws=",
  jwk: {
    kty: "EC",
    "x5t#S256": "hgpHHrTb4wswCsq78TQsEpgyinNyC1zpkCQlNM8inCI",
    use: "sig",
    crv: "P-256",
    kid: "hgpHHrTb4ws=",
    x: "li8eKthiom9EydKvhg7LHXj_f88_ZeNUpfEFm6kIAr0",
    y: "ytTQkUr9YKyZzYgXPZb4ILQI6hR0Ehk6L7UXBh3FbkQ"
  }
};
var qFNF2dC_mjQ_ = {
  co: "ES",
  kid: "qFNF2dC+mjQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "qFNF2dC-mjSR0IGpTUjjlt-SBep2WuO7oW4ZsojRXtQ",
    use: "sig",
    crv: "P-256",
    kid: "qFNF2dC+mjQ=",
    x: "3KVI7Sy-id-bprJ8Eh9AHtW-1qeC4qoHH1oK7HN87UI",
    y: "h_SsUIsdI6tEckm9nPuQjfpGwH7GBL1C3x06M9hVs1k"
  }
};
var tCM87WnaaQE_ = {
  co: "ES",
  kid: "tCM87WnaaQE=",
  jwk: {
    kty: "EC",
    "x5t#S256": "tCM87WnaaQGOLK-5bUR843ApnjIT2cWJyuftKuyAv-A",
    use: "sig",
    crv: "P-256",
    kid: "tCM87WnaaQE=",
    x: "DOg7lpxitz9-ytOAKFXxS7F4qc9IfKWrj388ETiCbLE",
    y: "ELqGHlhKfuMFzywhe0UaYOmcbfYhhvd2QMMZfINOTmo"
  }
};
var ub6Qmv9xtAo_ = {
  co: "ES",
  kid: "ub6Qmv9xtAo=",
  jwk: {
    kty: "EC",
    "x5t#S256": "ub6Qmv9xtAqgzif0xaYrDxyYRYVv5RSlPSZNRj7FYS8",
    use: "sig",
    crv: "P-256",
    kid: "ub6Qmv9xtAo=",
    x: "he-kvml2tx_-_wipHR5ttSw1PdmWGLpoEqzNiel2mWs",
    y: "GaL30gUfic64uzaR_LPEQUpxA3NJEE5dnUohAsvQ-OU"
  }
};
var x3ch4ml934I_ = {
  co: "ES",
  kid: "x3ch4ml934I=",
  jwk: {
    kty: "EC",
    "x5t#S256": "x3ch4ml934K1xSR9U9i77PgzgZsdlGx1pg2Q_7wn6uE",
    use: "sig",
    crv: "P-256",
    kid: "x3ch4ml934I=",
    x: "eC6-zmnjgdAUmYG4kIPJsMwSFSJclYoKuHKcIQ5PpX4",
    y: "MSsjN-hqdn5CrwEW8iWI3blPCczvZ60iC1cY7ikWqRc"
  }
};
var Is2JtrOJhik_ = {
  co: "AT",
  kid: "Is2JtrOJhik=",
  jwk: {
    kty: "EC",
    "x5t#S256": "Is2JtrOJhinpnQsaO73CXL3yZEx1jbytAn55PJ52JfU",
    crv: "P-256",
    kid: "Is2JtrOJhik=",
    x: "YE24qIKmdcfRWUh2TqklkfZ6nyNBpX4VHeLMxfFl8rk",
    y: "EPGZLtG3Jx-TmV3JJErfrSrPhRmfbSidVbTQ5nnZS-s"
  }
};
var _rZbUrXNlLk_ = {
  co: "CY",
  kid: "7rZbUrXNlLk=",
  jwk: {
    kty: "EC",
    "x5t#S256": "7rZbUrXNlLnQGiFeDlx4K5jUnCQx999TWiOKJmsE2Jo",
    crv: "P-256",
    kid: "7rZbUrXNlLk=",
    x: "7S_R06707Glu721qJqvxIFzQ2LSbq9P2uu6nRKCBLsE",
    y: "-a8j98F6YIC-oRodPNBeOtmxi07iP4V68RAdpEdlY8M"
  }
};
var e4lH6I4iMIM_ = {
  co: "CZ",
  kid: "e4lH6I4iMIM=",
  jwk: {
    kty: "EC",
    "x5t#S256": "e4lH6I4iMIMy1-9oEcKQdBq4tYiImWxzOjo7VZyuf-U",
    crv: "P-256",
    kid: "e4lH6I4iMIM=",
    x: "UIzSq5MMYg2oez_kdjVH73ZPmI3lAQZTJsLOGqhJNcY",
    y: "obJ_pubxS3jg1hTOv4V0Bki-erCI2yjK2Gte5SjQClM"
  }
};
var fNf883wPIEg_ = {
  co: "CZ",
  kid: "fNf883wPIEg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "fNf883wPIEjxL_f14ybtwtvkhv7WINEpCCMMO8UL-b8",
    crv: "P-256",
    kid: "fNf883wPIEg=",
    x: "8Dj2k2EY_UqgKsSGvIwPRhLiMa2kYm-y02Sam1DJusQ",
    y: "CRTqWx2p5fcDPfFNsZ_WK6T4igl8J2kj4nl8l-xrJDo"
  }
};
var AN1EeLIMAmo_ = {
  co: "PL",
  kid: "AN1EeLIMAmo=",
  jwk: {
    kty: "EC",
    "x5t#S256": "AN1EeLIMAmqDUZSd_iEM4lWlHmE_fIMn5HCcHLhlrbU",
    crv: "P-256",
    kid: "AN1EeLIMAmo=",
    x: "RG4yI_SSv70zEtVjzIrn_CypR1e0BZO5u8bIgltZico",
    y: "4Pvfdp9muxrnMSus8vdcavBfFx-wdEiVO-apK_GdXfQ"
  }
};
var FDNJjaSCWi0_ = {
  co: "PL",
  kid: "FDNJjaSCWi0=",
  jwk: {
    kty: "EC",
    "x5t#S256": "FDNJjaSCWi24bflAWChU5rMog7UKeqC4ESgOFyL2Zp4",
    crv: "P-256",
    kid: "FDNJjaSCWi0=",
    x: "dxvWMfuk6CHCbffZWPS6bRgVYglYdED1NT1FCfXstUY",
    y: "fNQFpmDoerW2YDhfTjNZc6naRQ9bjphGdAPF12JpAdQ"
  }
};
var HhkeqvrtQ0U_ = {
  co: "PL",
  kid: "HhkeqvrtQ0U=",
  jwk: {
    kty: "EC",
    "x5t#S256": "HhkeqvrtQ0WdjNhplLpXTylB8zhZiRTjJBp_mk1K-sU",
    crv: "P-256",
    kid: "HhkeqvrtQ0U=",
    x: "gUesihG8ECIDnqxEoU9RouOR9y3NVLBUlpZ-ri-Ur7Q",
    y: "0CzkUAxN7PzOShhJZcAm7IE-nF1AE_JLp9dpjnCbe_I"
  }
};
var JkFekJel6_o_ = {
  co: "LI",
  kid: "JkFekJel6/o=",
  jwk: {
    kty: "EC",
    "x5t#S256": "JkFekJel6_o5qcYKV6J-r4XE4XRSndzyApPtGtYrAOk",
    crv: "P-256",
    kid: "JkFekJel6/o=",
    x: "BnFUjr8FpfpVaVFtCUW7Yg6JBk_n1TlJKEKpm_rZOvA",
    y: "BMyqcKEwqV6Vzz9Ujxob0F8yfouHQUB4G3cNkg6XGZk"
  }
};
var e_YRqyv__qY_ = {
  co: "LI",
  kid: "e/YRqyv++qY=",
  jwk: {
    kty: "EC",
    "x5t#S256": "e_YRqyv--qYkeb2tMnbk50CeKbJ7wO1KEH9vwG77pC0",
    crv: "P-256",
    kid: "e/YRqyv++qY=",
    x: "mCCGUDO95y6Rj40KX74cFgc99I9BnFoPBkZ3kcAyo2o",
    y: "v7JjeIG2FpKwtljBK7DfM2d-wvUYQBpR2AzfLTyW4gM"
  }
};
var jYpr5GHCDiQ_ = {
  co: "LI",
  kid: "jYpr5GHCDiQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "jYpr5GHCDiRmmYwxtuPM-HGgDmK6ds89vgfnZKiBAMs",
    crv: "P-256",
    kid: "jYpr5GHCDiQ=",
    x: "lHOTKQPe3GZKCAIsaBbPpAfJZ30ftIUsb_r6gHu19cI",
    y: "NtVzH4mQ0LiN8HvNns7Jsoy_4369c5UWKly5m6jq5CQ"
  }
};
var hA1_pwEOxCI_ = {
  co: "RO",
  kid: "hA1+pwEOxCI=",
  jwk: {
    kty: "EC",
    "x5t#S256": "hA1-pwEOxCJQVdJCo1UF20qctj0mp-xVM9O_oWi7NN0",
    crv: "P-256",
    kid: "hA1+pwEOxCI=",
    x: "IQ5LJGhrs3m__HC60__4N8WDL1DiHJRUTirld4U9ebA",
    y: "WGLE7cVpJxhtFLaJ9dsfMgx5u8Ju2kaBYXeTMVuBuXM"
  }
};
var _lTmAZX19GQ_ = {
  co: "NL",
  kid: "3lTmAZX19GQ=",
  jwk: {
    kty: "EC",
    "x5t#S256": "3lTmAZX19GQszm-yiitK_9hTftnElUPZI2StHXj3Rbo",
    crv: "P-256",
    kid: "3lTmAZX19GQ=",
    x: "_DBnhBhTf8TkfsTn4tLEb3mQLCsONkZbY4I5i0zh0Wg",
    y: "bA7qQ7IRp7uExOAIB-mP7gZ7Cfg-kJFQIpM2v67cPPc"
  }
};
var f_4yAPIGTWg_ = {
  co: "NL",
  kid: "f+4yAPIGTWg=",
  jwk: {
    kty: "EC",
    "x5t#S256": "f-4yAPIGTWgdZBliDCTlCY9f-uP7vx-cFb6eAcTbeHg",
    crv: "P-256",
    kid: "f+4yAPIGTWg=",
    x: "RyOtPhis4M-vOSM-4AoqtBot3s7AGrqQOSA2ZY3a25w",
    y: "-XuEJUaRMXdUt_fQgA76OY9Dcqq5v2s64RSLEgHPBSI"
  }
};
var pSEfhlMubh4_ = {
  co: "NL",
  kid: "pSEfhlMubh4=",
  jwk: {
    kty: "EC",
    "x5t#S256": "pSEfhlMubh6v9PGy_Jv3i0bXKcFoDZeYNC-zfrrU5nU",
    crv: "P-256",
    kid: "pSEfhlMubh4=",
    x: "iY-AGRWtd8tCUb5PQdEPaCWAZl0D_SIOtcDH8R8yrp8",
    y: "yU_DJjMVf8DNeVomX9PRMst4iV8BU_vWDgsqwQPwno4"
  }
};
var all_jwk_keys_default = {
  "0L7AaIwu+EY=": _L7AaIwu_EY_,
  "1+da8dKEjlE=": __da8dKEjlE_,
  "2BGoyFIyYPs=": _BGoyFIyYPs_,
  "2JelGO/ymxQ=": _JelGO_ymxQ_,
  "3LCRmucB9kU=": _LCRmucB9kU_,
  "3jqajzfHpKE=": _jqajzfHpKE_,
  "3lrBUHc4iQE=": _lrBUHc4iQE_,
  "3oYtiEZ9wp4=": _oYtiEZ9wp4_,
  "5xtSr6KkAGA=": _xtSr6KkAGA_,
  "6FNkACSMLEc=": _FNkACSMLEc_,
  "6VdOPLF8/Fg=": _VdOPLF8_Fg_,
  "7XLhQx1KXdQ=": _XLhQx1KXdQ_,
  "8AnF/hcilSo=": _AnF_hcilSo_,
  "9IZVOkJRZPQ=": _IZVOkJRZPQ_,
  "9v3FozjKAUo=": _v3FozjKAUo_,
  "AQCGDydsS1Q=": AQCGDydsS1Q_,
  "CvktK3hdjeY=": CvktK3hdjeY_,
  "DusseXrzqO8=": DusseXrzqO8_,
  "IZftFLRmKGY=": IZftFLRmKGY_,
  "L7XIA2gi2ps=": L7XIA2gi2ps_,
  "M8bcnysCMj4=": M8bcnysCMj4_,
  "MxhfdcoHinc=": MxhfdcoHinc_,
  "NCdyt3s+cak=": NCdyt3s_cak_,
  "OKpEjMo/2MY=": OKpEjMo_2MY_,
  "R7q7yd90ZPU=": R7q7yd90ZPU_,
  "TGjTR+Re+yk=": TGjTR_Re_yk_,
  "TpQIkAHAym4=": TpQIkAHAym4_,
  "Uj77p+qIQNs=": Uj77p_qIQNs_,
  "XkVWZqUeeFc=": XkVWZqUeeFc_,
  "XuCERkHu8kY=": XuCERkHu8kY_,
  "Yr8a8Rd+zqI=": Yr8a8Rd_zqI_,
  "ZDoFfkn+yhY=": ZDoFfkn_yhY_,
  "bKmas9wa5tc=": bKmas9wa5tc_,
  "c1XrnEBoj/c=": c1XrnEBoj_c_,
  "dhSzPDr4G2M=": dhSzPDr4G2M_,
  "i5SVuCsR5TA=": i5SVuCsR5TA_,
  "izUDZjGtHWY=": izUDZjGtHWY_,
  "juskqrNQf6k=": juskqrNQf6k_,
  "kjEx2H7huNE=": kjEx2H7huNE_,
  "nHmZ5K96UY4=": nHmZ5K96UY4_,
  "nPKEYm3gXzU=": nPKEYm3gXzU_,
  "nTrG8glLUls=": nTrG8glLUls_,
  "npo0ZWgdQSY=": npo0ZWgdQSY_,
  "r9YkEJZgi9k=": r9YkEJZgi9k_,
  "rKMDA66RiLE=": rKMDA66RiLE_,
  "rXP9L7xddL8=": rXP9L7xddL8_,
  "sYXcYixrOGA=": sYXcYixrOGA_,
  "vjm0I2ATJ+Y=": vjm0I2ATJ_Y_,
  "vq08l/LTxhk=": vq08l_LTxhk_,
  "wb/2450PPrc=": wb_2450PPrc_,
  "wtYpyAmNmdk=": wtYpyAmNmdk_,
  "yWCRdph8XJs=": yWCRdph8XJs_,
  "7z8+6oww2a8=": _z8_6oww2a8_,
  "Er5OTMwLd78=": Er5OTMwLd78_,
  "cdm9Ymfwn2I=": cdm9Ymfwn2I_,
  "BKBFhNFXWAU=": BKBFhNFXWAU_,
  "ODqaG8mnbro=": ODqaG8mnbro_,
  "KG9lzdohSY0=": KG9lzdohSY0_,
  "Jjql9rBrjHI=": Jjql9rBrjHI_,
  "NAyCKly+hCg=": NAyCKly_hCg_,
  "7AfAwcpWOv0=": _AfAwcpWOv0_,
  "lshLbYfCWRg=": lshLbYfCWRg_,
  "02vdAOY/+gI=": _2vdAOY__gI_,
  "0kAwFy+vLpg=": _kAwFy_vLpg_,
  "bBnmkeVMV6A=": bBnmkeVMV6A_,
  "ln8K+9SqfuA=": ln8K_9SqfuA_,
  "25QCxBrBJvA=": _5QCxBrBJvA_,
  "MrT00mhDxLQ=": MrT00mhDxLQ_,
  "hFpY/ySOrwI=": hFpY_ySOrwI_,
  "CvmI4xOoMj4=": CvmI4xOoMj4_,
  "G3jDFQ1oK0Q=": G3jDFQ1oK0Q_,
  "IMgNr10pfPQ=": IMgNr10pfPQ_,
  "YVpBYnLh1Hs=": YVpBYnLh1Hs_,
  "e+bFdywyJQE=": e_bFdywyJQE_,
  "eQOY6BDp+vM=": eQOY6BDp_vM_,
  "fGLuvg6n5wk=": fGLuvg6n5wk_,
  "lrxgMs2Duac=": lrxgMs2Duac_,
  "4GkJs9YsYS4=": _GkJs9YsYS4_,
  "Z7k1XpIWZOE=": Z7k1XpIWZOE_,
  "90CNG8dcdn0=": _0CNG8dcdn0_,
  "6CDB1hL+uKU=": _CDB1hL_uKU_,
  "PBpDVqnJ7Us=": PBpDVqnJ7Us_,
  "eNNsg2jd4wA=": eNNsg2jd4wA_,
  "EzYR1uk/E0I=": EzYR1uk_E0I_,
  "Ll3NP03zOxY=": Ll3NP03zOxY_,
  "GvVR3e6VJIM=": GvVR3e6VJIM_,
  "QacbC7DdD4U=": QacbC7DdD4U_,
  "UZ1cSMaPcaQ=": UZ1cSMaPcaQ_,
  "bfoj2trt6bE=": bfoj2trt6bE_,
  "ccgQ13tmkU8=": ccgQ13tmkU8_,
  "f6J92LRKpj0=": f6J92LRKpj0_,
  "HeWuzGwEM5c=": HeWuzGwEM5c_,
  "Pbydc1LscXo=": Pbydc1LscXo_,
  "NJpCsMLQco4=": NJpCsMLQco4_,
  "vvYa1vaWkGg=": vvYa1vaWkGg_,
  "/IcqIBnnZzc=": _IcqIBnnZzc_,
  "3IsdmTYkAAM=": _IsdmTYkAAM_,
  "4Qmniw7B0gc=": _Qmniw7B0gc_,
  "6ag2wJkSHtk=": _ag2wJkSHtk_,
  "ARrNkCRtprY=": ARrNkCRtprY_,
  "BEnvMVnNFK8=": BEnvMVnNFK8_,
  "GMFMBu1RlCg=": GMFMBu1RlCg_,
  "GuQPQRxbMsU=": GuQPQRxbMsU_,
  "IaGR283U1jA=": IaGR283U1jA_,
  "JHd4CkNzadI=": JHd4CkNzadI_,
  "MtI93IMknMk=": MtI93IMknMk_,
  "NCc6YSsVioM=": NCc6YSsVioM_,
  "YRYidQ+wetg=": YRYidQ_wetg_,
  "YU9+X9nepqU=": YU9_X9nepqU_,
  "ZcfkloEvfGQ=": ZcfkloEvfGQ_,
  "e9SH8dtWwdY=": e9SH8dtWwdY_,
  "hgpHHrTb4ws=": hgpHHrTb4ws_,
  "qFNF2dC+mjQ=": qFNF2dC_mjQ_,
  "tCM87WnaaQE=": tCM87WnaaQE_,
  "ub6Qmv9xtAo=": ub6Qmv9xtAo_,
  "x3ch4ml934I=": x3ch4ml934I_,
  "Is2JtrOJhik=": Is2JtrOJhik_,
  "7rZbUrXNlLk=": _rZbUrXNlLk_,
  "e4lH6I4iMIM=": e4lH6I4iMIM_,
  "fNf883wPIEg=": fNf883wPIEg_,
  "AN1EeLIMAmo=": AN1EeLIMAmo_,
  "FDNJjaSCWi0=": FDNJjaSCWi0_,
  "HhkeqvrtQ0U=": HhkeqvrtQ0U_,
  "JkFekJel6/o=": JkFekJel6_o_,
  "e/YRqyv++qY=": e_YRqyv__qY_,
  "jYpr5GHCDiQ=": jYpr5GHCDiQ_,
  "hA1+pwEOxCI=": hA1_pwEOxCI_,
  "3lTmAZX19GQ=": _lTmAZX19GQ_,
  "f+4yAPIGTWg=": f_4yAPIGTWg_,
  "pSEfhlMubh4=": pSEfhlMubh4_
};

// src/json/pre_jwk_keys.json
var pre_jwk_keys_default = [
  "6l81l8ozsOU=",
  "+/bbaA9m0j0=",
  "+3CK4II5kAg=",
  "+Z3fx3xOKAQ=",
  "/IcqIBnnZzc=",
  "0J/NOaUzCAg=",
  "19qvyYakWNI=",
  "1vxpTLgc6ws=",
  "2Rk3X8HntrI=",
  "2c6RCwOmTGI=",
  "3H2QEFR6mNI=",
  "3IsdmTYkAAM=",
  "428FOlUxNRM=",
  "4Qmniw7B0gc=",
  "5QR1PW8i5fU=",
  "67BzmdT5oYo=",
  "6EjzyhNlGDQ=",
  "6ag2wJkSHtk=",
  "6ek0DM8iSCs=",
  "6jqyJk80bUU=",
  "7/MOPvQI+WY=",
  "727mZUPbpyc=",
  "7JQ83GRvK3A=",
  "9YMMwrfDdoo=",
  "9cWXDDA52FQ=",
  "ARrNkCRtprY=",
  "Ayod4P+EpW8=",
  "B2tu82ZFDgE=",
  "B4BbJQx1lYQ=",
  "BEnvMVnNFK8=",
  "BkMNTz/RKb8=",
  "CFUoOhVtOgo=",
  "CtDYk/6d0xw=",
  "DBCmGJjweMM=",
  "DEsVUSvpFAE=",
  "DhspllZjSVY=",
  "FOKoNhMEwl0=",
  "GMFMBu1RlCg=",
  "GO0rf1TneQQ=",
  "GZ2cfMLwyK8=",
  "H6KcgU3y0DY=",
  "HLY9BHAuz7E=",
  "IaGR283U1jA=",
  "JHd4CkNzadI=",
  "JLxre3vSwyg=",
  "Jj+9Dw7DUVU=",
  "KFP4Rwxlab8=",
  "Ks/eWTAFo+I=",
  "Ld1KH5MrFsY=",
  "MI7hF0OCF8Y=",
  "MiLjTTO/H+I=",
  "N1SUO3VrfMk=",
  "NCc6YSsVioM=",
  "NJpCsMLQco4=",
  "OTAXaM3aBRM=",
  "Ol12Ruv8LLo=",
  "P8Gvy67UYZI=",
  "R2I8VTnOBa4=",
  "Rl7ZUeTLAC4=",
  "SPQ+0opWAuM=",
  "STPDGKKF4N8=",
  "Sti09mkj+lQ=",
  "TfwLMHDXIws=",
  "Tn6X6w0+iBM=",
  "U5vvB3k2Cj4=",
  "Uy2dYAJ4Rdw=",
  "VjUQ+HzmZm0=",
  "WgxNQJs1Iwo=",
  "X3SRAZXFzss=",
  "XmYhV1P+0D4=",
  "YRYidQ+wetg=",
  "YTA6V2K8xQY=",
  "YU9+X9nepqU=",
  "ZcfkloEvfGQ=",
  "b0RhLyvUxgs=",
  "bIwe3F4lAk4=",
  "cKqkRgtW0Xw=",
  "coWnRsJwd/s=",
  "dAacIEGMNcE=",
  "dZl5Qc0tmyE=",
  "dsXHUWEsRfA=",
  "e9SH8dtWwdY=",
  "eZx0UBq8T1E=",
  "f1sfUVIx8CA=",
  "f4ialzEsfzU=",
  "ffE6u4r3Db0=",
  "gklWpqtW+Tg=",
  "gtsQTR82V6w=",
  "hgpHHrTb4ws=",
  "hyJmFP5BVx8=",
  "jrxzCm2qFug=",
  "kP2/7BRoXEs=",
  "kcJv+6yBWTg=",
  "kwL2uX0ViAA=",
  "l3DTTvY1/h0=",
  "lHHRhMo9GWg=",
  "lrXFYdYTLMY=",
  "m3TMC91/ewg=",
  "mRxapyixSJ0=",
  "mamG6Tt5Jl8=",
  "mkooSvJQkZ0=",
  "nSdp31pPUvQ=",
  "oeoGLaBuFPY=",
  "onphe00laog=",
  "pXjP4Y6sns4=",
  "pt8xqyMH4uE=",
  "rjvkUVBSdaE=",
  "snqSuA/dvgk=",
  "tCM87WnaaQE=",
  "u5Tohz8Qb+w=",
  "uE7ViYTSegg=",
  "ub6Qmv9xtAo=",
  "uxvl+dsyrBw=",
  "v58a8hf49kE=",
  "wGR6OwOYF4k=",
  "wRkEAKayPrE=",
  "wTHYuP2pg1k=",
  "xKOXcpzMVb0=",
  "xZ7EcIR8I4Y=",
  "xZUU+IopoVk=",
  "y3g27v8r51I=",
  "yLHLNvSl428=",
  "yM/UEbTW72k=",
  "yWoEMegrayo=",
  "zMq8VEXlueo="
];

// src/json/value-sets.json
var country_2_codes = {valueSetId: "country-2-codes", valueSetDate: "2019-11-01", valueSetValues: {AD: {display: "Andorra", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AE: {display: "United Arab Emirates", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AF: {display: "Afghanistan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AG: {display: "Antigua and Barbuda", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AI: {display: "Anguilla", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AL: {display: "Albania", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AM: {display: "Armenia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AO: {display: "Angola", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AQ: {display: "Antarctica", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AR: {display: "Argentina", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AS: {display: "American Samoa", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AT: {display: "Austria", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AU: {display: "Australia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AW: {display: "Aruba", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AX: {display: "\xC5land Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, AZ: {display: "Azerbaijan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BA: {display: "Bosnia and Herzegovina", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BB: {display: "Barbados", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BD: {display: "Bangladesh", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BE: {display: "Belgium", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BF: {display: "Burkina Faso", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BG: {display: "Bulgaria", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BH: {display: "Bahrain", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BI: {display: "Burundi", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BJ: {display: "Benin", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BL: {display: "Saint Barth\xE9lemy", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BM: {display: "Bermuda", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BN: {display: "Brunei Darussalam", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BO: {display: "Bolivia, Plurinational State of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BQ: {display: "Bonaire, Sint Eustatius and Saba", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BR: {display: "Brazil", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BS: {display: "Bahamas", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BT: {display: "Bhutan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BV: {display: "Bouvet Island", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BW: {display: "Botswana", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BY: {display: "Belarus", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, BZ: {display: "Belize", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CA: {display: "Canada", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CC: {display: "Cocos (Keeling) Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CD: {display: "Congo, the Democratic Republic of the", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CF: {display: "Central African Republic", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CG: {display: "Congo", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CH: {display: "Switzerland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CI: {display: "C\xF4te d''Ivoire", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CK: {display: "Cook Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CL: {display: "Chile", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CM: {display: "Cameroon", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CN: {display: "China", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CO: {display: "Colombia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CR: {display: "Costa Rica", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CU: {display: "Cuba", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CV: {display: "Cabo Verde", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CW: {display: "Cura\xE7ao", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CX: {display: "Christmas Island", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CY: {display: "Cyprus", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, CZ: {display: "Czechia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DE: {display: "Germany", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DJ: {display: "Djibouti", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DK: {display: "Denmark", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DM: {display: "Dominica", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DO: {display: "Dominican Republic", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, DZ: {display: "Algeria", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, EC: {display: "Ecuador", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, EE: {display: "Estonia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, EG: {display: "Egypt", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, EH: {display: "Western Sahara", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ER: {display: "Eritrea", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ES: {display: "Spain", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ET: {display: "Ethiopia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FI: {display: "Finland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FJ: {display: "Fiji", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FK: {display: "Falkland Islands (Malvinas)", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FM: {display: "Micronesia, Federated States of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FO: {display: "Faroe Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, FR: {display: "France", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GA: {display: "Gabon", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GB: {display: "United Kingdom of Great Britain and Northern Ireland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GD: {display: "Grenada", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GE: {display: "Georgia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GF: {display: "French Guiana", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GG: {display: "Guernsey", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GH: {display: "Ghana", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GI: {display: "Gibraltar", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GL: {display: "Greenland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GM: {display: "Gambia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GN: {display: "Guinea", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GP: {display: "Guadeloupe", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GQ: {display: "Equatorial Guinea", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GR: {display: "Greece", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GS: {display: "South Georgia and the South Sandwich Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GT: {display: "Guatemala", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GU: {display: "Guam", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GW: {display: "Guinea-Bissau", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, GY: {display: "Guyana", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HK: {display: "Hong Kong", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HM: {display: "Heard Island and McDonald Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HN: {display: "Honduras", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HR: {display: "Croatia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HT: {display: "Haiti", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, HU: {display: "Hungary", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ID: {display: "Indonesia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IE: {display: "Ireland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IL: {display: "Israel", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IM: {display: "Isle of Man", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IN: {display: "India", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IO: {display: "British Indian Ocean Territory", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IQ: {display: "Iraq", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IR: {display: "Iran, Islamic Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IS: {display: "Iceland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, IT: {display: "Italy", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, JE: {display: "Jersey", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, JM: {display: "Jamaica", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, JO: {display: "Jordan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, JP: {display: "Japan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KE: {display: "Kenya", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KG: {display: "Kyrgyzstan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KH: {display: "Cambodia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KI: {display: "Kiribati", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KM: {display: "Comoros", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KN: {display: "Saint Kitts and Nevis", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KP: {display: "Korea, Democratic People''s Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KR: {display: "Korea, Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KW: {display: "Kuwait", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KY: {display: "Cayman Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, KZ: {display: "Kazakhstan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LA: {display: "Lao People''s Democratic Republic", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LB: {display: "Lebanon", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LC: {display: "Saint Lucia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LI: {display: "Liechtenstein", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LK: {display: "Sri Lanka", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LR: {display: "Liberia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LS: {display: "Lesotho", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LT: {display: "Lithuania", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LU: {display: "Luxembourg", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LV: {display: "Latvia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, LY: {display: "Libya", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MA: {display: "Morocco", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MC: {display: "Monaco", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MD: {display: "Moldova, Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ME: {display: "Montenegro", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MF: {display: "Saint Martin (French part)", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MG: {display: "Madagascar", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MH: {display: "Marshall Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MK: {display: "Macedonia, the former Yugoslav Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ML: {display: "Mali", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MM: {display: "Myanmar", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MN: {display: "Mongolia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MO: {display: "Macao", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MP: {display: "Northern Mariana Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MQ: {display: "Martinique", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MR: {display: "Mauritania", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MS: {display: "Montserrat", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MT: {display: "Malta", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MU: {display: "Mauritius", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MV: {display: "Maldives", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MW: {display: "Malawi", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MX: {display: "Mexico", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MY: {display: "Malaysia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, MZ: {display: "Mozambique", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NA: {display: "Namibia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NC: {display: "New Caledonia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NE: {display: "Niger", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NF: {display: "Norfolk Island", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NG: {display: "Nigeria", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NI: {display: "Nicaragua", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NL: {display: "Netherlands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NO: {display: "Norway", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NP: {display: "Nepal", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NR: {display: "Nauru", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NU: {display: "Niue", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, NZ: {display: "New Zealand", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, OM: {display: "Oman", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PA: {display: "Panama", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PE: {display: "Peru", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PF: {display: "French Polynesia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PG: {display: "Papua New Guinea", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PH: {display: "Philippines", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PK: {display: "Pakistan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PL: {display: "Poland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PM: {display: "Saint Pierre and Miquelon", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PN: {display: "Pitcairn", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PR: {display: "Puerto Rico", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PS: {display: "Palestine, State of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PT: {display: "Portugal", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PW: {display: "Palau", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, PY: {display: "Paraguay", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, QA: {display: "Qatar", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, RE: {display: "R\xE9union", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, RO: {display: "Romania", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, RS: {display: "Serbia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, RU: {display: "Russian Federation", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, RW: {display: "Rwanda", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SA: {display: "Saudi Arabia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SB: {display: "Solomon Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SC: {display: "Seychelles", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SD: {display: "Sudan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SE: {display: "Sweden", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SG: {display: "Singapore", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SH: {display: "Saint Helena, Ascension and Tristan da Cunha", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SI: {display: "Slovenia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SJ: {display: "Svalbard and Jan Mayen", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SK: {display: "Slovakia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SL: {display: "Sierra Leone", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SM: {display: "San Marino", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SN: {display: "Senegal", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SO: {display: "Somalia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SR: {display: "Suriname", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SS: {display: "South Sudan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ST: {display: "Sao Tome and Principe", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SV: {display: "El Salvador", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SX: {display: "Sint Maarten (Dutch part)", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SY: {display: "Syrian Arab Republic", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, SZ: {display: "Swaziland", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TC: {display: "Turks and Caicos Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TD: {display: "Chad", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TF: {display: "French Southern Territories", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TG: {display: "Togo", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TH: {display: "Thailand", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TJ: {display: "Tajikistan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TK: {display: "Tokelau", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TL: {display: "Timor-Leste", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TM: {display: "Turkmenistan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TN: {display: "Tunisia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TO: {display: "Tonga", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TR: {display: "Turkey", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TT: {display: "Trinidad and Tobago", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TV: {display: "Tuvalu", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TW: {display: "Taiwan, Province of China", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, TZ: {display: "Tanzania, United Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, UA: {display: "Ukraine", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, UG: {display: "Uganda", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, UM: {display: "United States Minor Outlying Islands", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, US: {display: "United States of America", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, UY: {display: "Uruguay", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, UZ: {display: "Uzbekistan", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VA: {display: "Holy See", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VC: {display: "Saint Vincent and the Grenadines", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VE: {display: "Venezuela, Bolivarian Republic of", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VG: {display: "Virgin Islands, British", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VI: {display: "Virgin Islands,", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VN: {display: "Viet Nam", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, VU: {display: "Vanuatu", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, WF: {display: "Wallis and Futuna", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, WS: {display: "Samoa", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, YE: {display: "Yemen", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, YT: {display: "Mayotte", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ZA: {display: "South Africa", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ZM: {display: "Zambia", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}, ZW: {display: "Zimbabwe", lang: "en", active: true, system: "urn:iso:std:iso:3166", version: ""}}};
var test_manf = {valueSetId: "covid-19-lab-test-manufacturer-and-name", valueSetDate: "2021-05-27", valueSetValues: {"308": {display: "PCL Inc, PCL COVID19 Ag Rapid FIA", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "344": {display: "SD BIOSENSOR Inc, STANDARD F COVID-19 Ag FIA", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "345": {display: "SD BIOSENSOR Inc, STANDARD Q COVID-19 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "768": {display: "ArcDia International Ltd, mariPOC SARS-CoV-2", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-19 17:12:12 CET"}, "1097": {display: "Quidel Corporation, Sofia SARS Antigen FIA", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1114": {display: "Sugentech, Inc, SGTi-flex COVID-19 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1144": {display: "Green Cross Medical Science Corp., GENEDIA W COVID-19 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-11 09:31:09 CET"}, "1162": {display: "Nal von minden GmbH, NADAL COVID-19 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1173": {display: "CerTest Biotec, CerTest SARS-CoV-2 Card test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:18:20 CET"}, "1180": {display: "MEDsan GmbH, MEDsan SARS-CoV-2 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1190": {display: "m\xF6Lab, COVID-19 Rapid Antigen Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1199": {display: "Oncosem Onkolojik Sistemler San. ve Tic. A.S., CAT", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1215": {display: "Hangzhou Laihe Biotech Co., Ltd, LYHER Novel Coronavirus (COVID-19) Antigen Test Kit(Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1218": {display: "Siemens Healthineers, CLINITEST Rapid Covid-19 Antigen Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1223": {display: "BIOSYNEX S.A., BIOSYNEX COVID-19 Ag BSS", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:18:20 CET"}, "1225": {display: "DDS DIAGNOSTIC, Test Rapid Covid-19 Antigen (tampon nazofaringian)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1232": {display: "Abbott Rapid Diagnostics, Panbio COVID-19 Ag Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-17 11:01:42 CET"}, "1236": {display: "BTNX Inc, Rapid Response COVID-19 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:13 CET"}, "1244": {display: "GenBody, Inc, Genbody COVID-19 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1246": {display: "VivaChek Biotech (Hangzhou) Co., Ltd, Vivadiag SARS CoV 2 Ag Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1253": {display: "GenSure Biotech Inc, GenSure COVID-19 Antigen Rapid Kit (REF: P2004)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1256": {display: "Hangzhou AllTest Biotech Co., Ltd, COVID-19 and Influenza A+B Antigen Combo Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1263": {display: "Humasis, Humasis COVID-19 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1266": {display: "Labnovation Technologies Inc, SARS-CoV-2 Antigen Rapid Test Kit", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1267": {display: "LumiQuick Diagnostics Inc, QuickProfile COVID-19 Antigen Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1268": {display: "LumiraDX, LumiraDx SARS-CoV-2 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:18:20 CET"}, "1271": {display: "Precision Biosensor, Inc, Exdia COVID-19 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1278": {display: "Xiamen Boson Biotech Co. Ltd, Rapid SARS-CoV-2 Antigen Test Card", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1295": {display: "Zhejiang Anji Saianfu Biotech Co., Ltd, reOpenTest COVID-19 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1296": {display: "Zhejiang Anji Saianfu Biotech Co., Ltd, AndLucky COVID-19 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1304": {display: "AMEDA Labordiagnostik GmbH, AMP Rapid Test SARS-CoV-2 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1319": {display: "SGA Medikal, V-Chek SARS-CoV-2 Ag Rapid Test Kit (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1331": {display: "Beijing Lepu Medical Technology Co., Ltd, SARS-CoV-2 Antigen Rapid Test Kit", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1333": {display: "Joinstar Biomedical Technology Co., Ltd, COVID-19 Rapid Antigen Test (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1341": {display: "Qingdao Hightop Biotech Co., Ltd, SARS-CoV-2 Antigen Rapid Test (Immunochromatography)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1343": {display: "Zhezhiang Orient Gene Biotech Co., Ltd, Coronavirus Ag Rapid Test Cassette (Swab)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:18:20 CET"}, "1360": {display: "Guangdong Wesail Biotech Co., Ltd, COVID-19 Ag Test Kit", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1363": {display: "Hangzhou Clongene Biotech Co., Ltd, Covid-19 Antigen Rapid Test Kit", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1365": {display: "Hangzhou Clongene Biotech Co., Ltd, COVID-19/Influenza A+B Antigen Combo Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1375": {display: "DIALAB GmbH, DIAQUICK COVID-19 Ag Cassette", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1392": {display: "Hangzhou Testsea Biotechnology Co., Ltd, COVID-19 Antigen Test Cassette", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1420": {display: "NanoEntek, FREND COVID-19 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1437": {display: "Guangzhou Wondfo Biotech Co., Ltd, Wondfo 2019-nCoV Antigen Test (Lateral Flow Method)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1443": {display: "Vitrosens Biotechnology Co., Ltd, RapidFor SARS-CoV-2 Rapid Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1456": {display: "Xiamen Wiz Biotech Co., Ltd, SARS-CoV-2 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-19 17:10:21 CET"}, "1466": {display: "TODA PHARMA, TODA CORONADIAG Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1468": {display: "ACON Laboratories, Inc, Flowflex SARS-CoV-2 Antigen rapid test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1481": {display: "MP Biomedicals, Rapid SARS-CoV-2 Antigen Test Card", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1484": {display: "Beijing Wantai Biological Pharmacy Enterprise Co., Ltd, Wantai SARS-CoV-2 Ag Rapid Test (FIA)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:04:00 CET"}, "1489": {display: "Safecare Biotech (Hangzhou) Co. Ltd, COVID-19 Antigen Rapid Test Kit (Swab)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-12 12:58:25 CET"}, "1490": {display: "Safecare Biotech (Hangzhou) Co. Ltd, Multi-Respiratory Virus Antigen Test Kit(Swab)  (Influenza A+B/ COVID-19)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1574": {display: "Shenzhen Zhenrui Biotechnology Co., Ltd, Zhenrui \xAECOVID-19 Antigen Test Cassette", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1604": {display: "Roche (SD BIOSENSOR), SARS-CoV-2 Antigen Rapid Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1606": {display: "RapiGEN Inc, BIOCREDIT COVID-19 Ag - SARS-CoV 2 Antigen test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1654": {display: "Asan Pharmaceutical CO., LTD, Asan Easy Test COVID-19 Ag", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1736": {display: "Anhui Deep Blue Medical Technology Co., Ltd, COVID-19 (SARS-CoV-2) Antigen Test Kit(Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1747": {display: "Guangdong Hecin Scientific, Inc., 2019-nCoV Antigen Test Kit (colloidal gold method)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1763": {display: "Xiamen AmonMed Biotechnology Co., Ltd, COVID-19 Antigen Rapid Test Kit (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1764": {display: "JOYSBIO (Tianjin) Biotechnology Co., Ltd, SARS-CoV-2 Antigen Rapid Test Kit (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-11 09:28:10 CET"}, "1767": {display: "Healgen Scientific, Coronavirus Ag Rapid Test Cassette", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 13:18:20 CET"}, "1769": {display: "Shenzhen Watmind Medical Co., Ltd, SARS-CoV-2 Ag Diagnostic Test Kit (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1815": {display: "Anhui Deep Blue Medical Technology Co., Ltd, COVID-19 (SARS-CoV-2) Antigen Test Kit (Colloidal Gold) - Nasal Swab", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-12 12:27:46 CET"}, "1822": {display: "Anbio (Xiamen) Biotechnology Co., Ltd, Rapid COVID-19 Antigen Test(Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1833": {display: "AAZ-LMB, COVID-VIRO", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-17 11:02:12 CET"}, "1844": {display: "Hangzhou Immuno Biotech Co.,Ltd, Immunobio SARS-CoV-2 Antigen ANTERIOR NASAL Rapid Test Kit (minimal invasive)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 19:40:14 CET"}, "1870": {display: "Beijing Hotgen Biotech Co., Ltd, Novel Coronavirus 2019-nCoV Antigen Test (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:07:30 CET"}, "1884": {display: "Xiamen Wiz Biotech Co., Ltd, SARS-CoV-2 Antigen Rapid Test (Colloidal Gold)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-20 15:15:25 CET"}, "1906": {display: "Azure Biotech Inc, COVID-19 Antigen Rapid Test Device", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-19 17:14:21 CET"}, "1919": {display: "Core Technology Co., Ltd, Coretests COVID-19 Ag Test", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-10 20:12:51 CET"}, "1934": {display: "Tody Laboratories Int., Coronavirus (SARS-CoV 2) Antigen - Oral Fluid", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-19 17:16:42 CET"}, "2010": {display: "Atlas Link Technology Co., Ltd., NOVA Test\xAE SARS-CoV-2 Antigen Rapid Test Kit (Colloidal Gold Immunochromatography)", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-11 09:29:55 CET"}, "2017": {display: "Shenzhen Ultra-Diagnostics Biotec.Co.,Ltd, SARS-CoV-2 Antigen Test Kit", lang: "en", active: true, system: "https://covid-19-diagnostics.jrc.ec.europa.eu/devices", version: "2021-05-19 17:15:38 CET"}}};
var test_type = {valueSetId: "covid-19-lab-test-type", valueSetDate: "2021-04-27", valueSetValues: {"LP6464-4": {display: "Nucleic acid amplification with probe detection", lang: "en", active: true, version: "2.69", system: "http://loinc.org"}, "LP217198-3": {display: "Rapid immunoassay", lang: "en", active: true, version: "2.69", system: "http://loinc.org"}}};
var vaccine_medicinal_product = {valueSetId: "vaccines-covid-19-names", valueSetDate: "2021-04-27", valueSetValues: {"EU/1/20/1528": {display: "Comirnaty", lang: "en", active: true, system: "https://ec.europa.eu/health/documents/community-register/html/", version: ""}, "EU/1/20/1507": {display: "COVID-19 Vaccine Moderna", lang: "en", active: true, system: "https://ec.europa.eu/health/documents/community-register/html/", version: ""}, "EU/1/21/1529": {display: "Vaxzevria", lang: "en", active: true, system: "https://ec.europa.eu/health/documents/community-register/html/", version: ""}, "EU/1/20/1525": {display: "COVID-19 Vaccine Janssen", lang: "en", active: true, system: "https://ec.europa.eu/health/documents/community-register/html/", version: ""}, CVnCoV: {display: "CVnCoV", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, "Sputnik-V": {display: "Sputnik-V", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, Convidecia: {display: "Convidecia", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, EpiVacCorona: {display: "EpiVacCorona", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, "BBIBP-CorV": {display: "BBIBP-CorV", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, "Inactivated-SARS-CoV-2-Vero-Cell": {display: "Inactivated SARS-CoV-2 (Vero Cell)", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, CoronaVac: {display: "CoronaVac", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}, Covaxin: {display: "Covaxin (also known as BBV152 A, B, C)", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccineproductname", version: "1.0"}}};
var disease_agent_targeted = {valueSetId: "disease-agent-targeted", valueSetDate: "2021-04-27", valueSetValues: {"840539006": {display: "COVID-19", lang: "en", active: true, version: "http://snomed.info/sct/900000000000207008/version/20210131", system: "http://snomed.info/sct"}}};
var test_result = {valueSetId: "covid-19-lab-result", valueSetDate: "2021-04-27", valueSetValues: {"260373001": {display: "Detected", lang: "en", active: true, version: "http://snomed.info/sct/900000000000207008/version/20210131", system: "http://snomed.info/sct"}, "260415000": {display: "Not detected", lang: "en", active: true, version: "http://snomed.info/sct/900000000000207008/version/20210131", system: "http://snomed.info/sct"}}};
var vaccine_mah_manf = {valueSetId: "vaccines-covid-19-auth-holders", valueSetDate: "2021-04-27", valueSetValues: {"ORG-100001699": {display: "AstraZeneca AB", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100030215": {display: "Biontech Manufacturing GmbH", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100001417": {display: "Janssen-Cilag International", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100031184": {display: "Moderna Biotech Spain S.L.", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100006270": {display: "Curevac AG", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100013793": {display: "CanSino Biologics", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100020693": {display: "China Sinopharm International Corp. - Beijing location", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100010771": {display: "Sinopharm Weiqida Europe Pharmaceutical s.r.o. - Prague location", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100024420": {display: "Sinopharm Zhijun (Shenzhen) Pharmaceutical Co. Ltd. - Shenzhen location", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "ORG-100032020": {display: "Novavax CZ AS", lang: "en", active: true, system: "https://spor.ema.europa.eu/v1/organisations", version: ""}, "Gamaleya-Research-Institute": {display: "Gamaleya Research Institute", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccinemanufacturer", version: "1.0"}, "Vector-Institute": {display: "Vector Institute", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccinemanufacturer", version: "1.0"}, "Sinovac-Biotech": {display: "Sinovac Biotech", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccinemanufacturer", version: "1.0"}, "Bharat-Biotech": {display: "Bharat Biotech", lang: "en", active: true, system: "http://ec.europa.eu/temp/vaccinemanufacturer", version: "1.0"}}};
var vaccine_prophylaxis = {valueSetId: "sct-vaccines-covid-19", valueSetDate: "2021-04-27", valueSetValues: {"1119305005": {display: "SARS-CoV-2 antigen vaccine", lang: "en", active: true, version: "http://snomed.info/sct/900000000000207008/version/20210131", system: "http://snomed.info/sct"}, "1119349007": {display: "SARS-CoV-2 mRNA vaccine", lang: "en", active: true, version: "http://snomed.info/sct/900000000000207008/version/20210131", system: "http://snomed.info/sct"}, J07BX03: {display: "covid-19 vaccines", lang: "en", active: true, version: "2021-01", system: "http://www.whocc.no/atc"}}};
var value_sets_default = {"country-2-codes": country_2_codes, "test-manf": test_manf, "test-type": test_type, "vaccine-medicinal-product": vaccine_medicinal_product, "disease-agent-targeted": disease_agent_targeted, "test-result": test_result, "vaccine-mah-manf": vaccine_mah_manf, "vaccine-prophylaxis": vaccine_prophylaxis};

// src/json/uk_jwk_keys.json
var uk_jwk_keys_default = [{
  kid: "S2V5MVJF",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEtWokvmqrJOv/0PO9Vy8lpb6SgWw+rao0qIXntO/Bf7ExryL3yyKRI73IqAh38Lk4joqHrZK8XLZV9PMclgmTVg=="
}, {
  kid: "S2V5MlJF",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEAauvVllnjXm0toiI2cUQfCTdZiDQ6kvtoo1bSnl8W3Rq7WyOeHWYKhBaQ4rEBceqNl5+v1ZLGj0WfnIhXh246Q=="
}, {
  kid: "S2V5M1JF",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE2ZpDNa1VV6g2PkmyKoL1INO0MtTqE5WT45i3QhY9FFMjbF9ieqnHV4R814wrN3f3vzkx0VN/YJZH4rI1GDlfqw=="
}, {
  kid: "S2V5NFJF",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE8g5iFLRT7NyRmKp7pcP8uEgoHFhfmcXOLLD4RUtX50/Rh4Cz7l/faAiODNMmCkcWLA1Z8WOZoNFQsdmeDjXuLQ=="
}, {
  kid: "S2V5NVJF",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEOFOUp1+SLuaM3NnV+OMZKZOoPg76T7D+vqRCasD0BrRZmlUH2gD+aVlpKvp+u7h8ywTR7T6Z6/iI2Qe6F5begg=="
}, {
  kid: "S2V5MVBSTw==",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEyfUqlGg4hfyPYgZJzl1KepkfTaX+F3592syCJ0ylVOHA4fE6vavLXE4cG+Whz/eqyW/rFuZ0HBHHEskmpCngOA=="
}, {
  kid: "S2V5MlBSTw==",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEP6P6ZlbhcW1xZpp91qagUY+iLIyuu+CynzAlrqiiseqmOYH8uJ71CkbEYhbVh8TemnbaR0unE2j9EPK7Y/x7Vg=="
}, {
  kid: "S2V5M1BSTw==",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAErltiOh3nmU+x4p5r249O/2fBSnHkjJpas23lhMAtEYeQutHiw0G+zeEUNZ/n++/XbFoY5hH68d27cGaGW6uoxw=="
}, {
  kid: "S2V5NFBSTw==",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEEfIefhjjacwZ+xxKudJGqdHr0j95tWtYIUGPeWV2XWmduygfe3oIFJu/A2kYGmeZ4u/ERSTNM2ZXuE9k19xVJQ=="
}, {
  kid: "S2V5NVBSTw==",
  publicKey: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE+4ukUdmm9f4AmyQBwTLQFKPPCQj4fP2BpQkIl2hb4p6FxPGDP9z3JkIo2w2xkoxqs2JrTHn2MCdyh3aeyZWD4A=="
}];

// src/components/cwt.js
async function getTrustedKey(kid) {
  if (!kid) {
    log.myerror("kid is undefined");
    return void 0;
  }
  let entry = all_jwk_keys_default[kid];
  if (entry) {
    console.log(`kid "${kid}" found in EU_PRO trusted list`);
    return {
      kid,
      publicKey: entry.jwk,
      list: "EU_PRO",
      format: "jwk"
    };
  }
  log.mywarn(`kid "${kid}" not found in EU_PRO trusted list`);
  for (let i = 0; i < uk_jwk_keys_default.length; i++) {
    if (uk_jwk_keys_default[i].kid == kid) {
      console.log(`kid "${kid}" found in UK_PRO trusted list`);
      return {
        kid,
        publicKey: uk_jwk_keys_default[i].publicKey,
        list: "UK_PRO",
        format: "spki"
      };
    }
  }
  log.mywarn(`kid "${kid}" not found in UK_PRO trusted list`);
  if (pre_jwk_keys_default.includes(kid)) {
    log.mywarn(`kid "${kid}" found in EU PREPRODUCTION trusted list`);
    return {
      kid,
      publicKey: void 0,
      list: "EU_PREPRODUCTION",
      format: void 0
    };
  }
  log.myerror(`KEY ${kid} not found in any Trusted List`);
  return {
    kid,
    publicKey: void 0,
    list: void 0,
    format: void 0
  };
}
var vs = {
  get: function(key, valueSetName) {
    if (!key) {
      return "N/A";
    }
    let valueSet = value_sets_default[valueSetName];
    if (!valueSet) {
      return key;
    }
    let values = valueSet["valueSetValues"];
    if (!values) {
      return key;
    }
    let value = values[key];
    if (!value) {
      return key;
    }
    return value["display"];
  }
};
function str2ab(str) {
  const buf = new ArrayBuffer(str.length);
  const bufView = new Uint8Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}
var DGCKey = class {
  constructor() {
  }
  static async fromSPKI(SPKI) {
    const binaryDerString = window.atob(SPKI);
    const binaryDer = str2ab(binaryDerString);
    const extractable = true;
    const format = "spki";
    let algorithm = {
      name: "ECDSA",
      namedCurve: "P-256"
    };
    let key = await crypto.subtle.importKey(format, binaryDer, algorithm, extractable, ["verify"]);
    return key;
  }
  static async fromJWK(jwk) {
    const extractable = true;
    const format = "jwk";
    const keyType = jwk["kty"];
    let algorithm;
    if (keyType == "EC") {
      algorithm = {
        name: "ECDSA",
        namedCurve: "P-256"
      };
    } else if (keyType == "RSA") {
      algorithm = {
        name: "RSA-PSS",
        hash: "SHA-256"
      };
    } else {
      throw new Error(`Invalid key type specified: ${jwk["kty"]}`);
    }
    let keyUsages = jwk["d"] ? ["sign"] : ["verify"];
    let key = await crypto.subtle.importKey(format, jwk, algorithm, extractable, keyUsages);
    return key;
  }
  static async generateECDSAKeyPair() {
    const extractable = true;
    const algorithm = {
      name: "ECDSA",
      namedCurve: "P-256"
    };
    const keyUsages = ["sign", "verify"];
    let keyPair = await crypto.subtle.generateKey(algorithm, extractable, keyUsages);
    return keyPair;
  }
  static async generateEncryptionKey() {
    let key = await crypto.subtle.generateKey({
      name: "AES-GCM",
      length: 256
    }, true, ["encrypt", "decrypt"]);
    return key;
  }
  static async exportToJWK(key) {
    let keyJWK = await crypto.subtle.exportKey("jwk", key);
    return keyJWK;
  }
  static async exportToPEM(key) {
    let keyJWK = await crypto.subtle.exportKey("spki", key);
    return keyJWK;
  }
  static async importFromPEMRaw(keyPEMString) {
    const binaryDerString = window.atob(keyPEMString);
    console.log(binaryDerString);
    const binaryDer = str2ab(binaryDerString);
    console.log(binaryDer);
    let key = await crypto.subtle.importKey("spki", binaryDer, {
      name: "ECDSA",
      namedCurve: "P-256"
    }, true, ["verify"]);
    return key;
  }
  static async sign(key, bytes) {
    if (key.type != "private") {
      throw new Error("Not a private key");
    }
    let signature = await window.crypto.subtle.sign({
      name: "ECDSA",
      hash: {name: "SHA-256"}
    }, key, bytes);
    return signature;
  }
  static async verify(key, signature, bytes) {
    if (key.type != "public") {
      throw new Error("Not a public key");
    }
    console.log("Inside VERIFY", key);
    let result;
    try {
      result = await window.crypto.subtle.verify({
        name: "ECDSA",
        hash: {name: "SHA-256"}
      }, key, signature, bytes);
    } catch (error) {
      throw `Verification of payload failed: ${error}`;
    }
    console.log("Result:", result);
    return result;
  }
  static async encryptMessage(key, bytes) {
    if (key.type != "secret") {
      throw new Error("Not a symmetric encryption key");
    }
    let iv = crypto.getRandomValues(new Uint8Array(12));
    let ciphertext = await crypto.subtle.encrypt({
      name: "AES-GCM",
      iv
    }, key, bytes);
    return {iv, ciphertext};
  }
  static async decryptMessage(key, iv, ciphertext) {
    if (key.type != "secret") {
      throw new Error("Not a symmetric encryption key");
    }
    let decrypted = await window.crypto.subtle.decrypt({
      name: "AES-GCM",
      iv
    }, key, ciphertext);
    return decrypted;
  }
};
var aCode = "a".charCodeAt(0);
var fCode = "f".charCodeAt(0);
var ACode = "A".charCodeAt(0);
var FCode = "F".charCodeAt(0);
var zeroCode = "0".charCodeAt(0);
var nineCode = "9".charCodeAt(0);
var lutArray = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f"
];
function bytes2hexStr(bytes) {
  var hexStr = "";
  for (let i = 0; i < bytes.length; i = i + 1) {
    nibHigh = bytes[i] >>> 4;
    nibLow = bytes[i] & 15;
    hexStr = hexStr + lutArray[nibHigh] + lutArray[nibLow];
  }
  return hexStr;
}
var baseSize = 45;
var baseSizeSquared = 2025;
var chunkSize = 2;
var encodedChunkSize = 3;
var byteSize = 256;
var encoding = [
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  " ",
  "$",
  "%",
  "*",
  "+",
  "-",
  ".",
  "/",
  ":"
];
var decoding;
function decodeB45(utf8StringArg) {
  if (utf8StringArg === null || utf8StringArg === void 0)
    throw new Error("utf8StringArg is null or undefined.");
  if (utf8StringArg.length === 0)
    return [];
  var remainderSize = utf8StringArg.length % encodedChunkSize;
  if (remainderSize === 1)
    throw new Error("utf8StringArg has incorrect length.");
  if (decoding === void 0) {
    decoding = {};
    for (let i = 0; i < encoding.length; ++i)
      decoding[encoding[i]] = i;
  }
  const buffer = new Array(utf8StringArg.length);
  for (let i = 0; i < utf8StringArg.length; ++i) {
    const found = decoding[utf8StringArg[i]];
    if (found === void 0)
      throw new Error("Invalid character at position ".concat(i).concat("."));
    buffer[i] = found;
  }
  const wholeChunkCount = Math.trunc(buffer.length / encodedChunkSize);
  var result = new Array(wholeChunkCount * chunkSize + (remainderSize === chunkSize ? 1 : 0));
  var resultIndex = 0;
  const wholeChunkLength = wholeChunkCount * encodedChunkSize;
  for (let i = 0; i < wholeChunkLength; ) {
    const val = buffer[i++] + baseSize * buffer[i++] + baseSizeSquared * buffer[i++];
    result[resultIndex++] = Math.trunc(val / byteSize);
    result[resultIndex++] = val % byteSize;
  }
  if (remainderSize === 0)
    return result;
  result[result.length - 1] = buffer[buffer.length - 2] + baseSize * buffer[buffer.length - 1];
  return result;
}
var COSE_Sign1 = 18;
var MT_INTEGER = 0;
var MT_NEGINTEGER = 1;
var MT_BYTES = 2;
var MT_UTF8 = 3;
var MT_ARRAY = 4;
var MT_MAP = 5;
var MT_TAG = 6;
var MT_FLOAT = 7;
var CWT_ALG = 1;
var CWT_KID = 4;
var utf8Encoder = new TextEncoder();
var utf8Decoder = new TextDecoder();
var CWT_ALG_TO_JWT = new Map();
CWT_ALG_TO_JWT.set(-7, "ES256");
CWT_ALG_TO_JWT.set(-37, "RSA");
var _CWT = class {
  static encode(value) {
    var data = new ArrayBuffer(256);
    var dataView = new DataView(data);
    var lastLength;
    var offset = 0;
    function prepareWrite(length) {
      var newByteLength = data.byteLength;
      var requiredLength = offset + length;
      while (newByteLength < requiredLength)
        newByteLength <<= 1;
      if (newByteLength !== data.byteLength) {
        var oldDataView = dataView;
        data = new ArrayBuffer(newByteLength);
        dataView = new DataView(data);
        var uint32count = offset + 3 >> 2;
        for (var i = 0; i < uint32count; ++i)
          dataView.setUint32(i << 2, oldDataView.getUint32(i << 2));
      }
      lastLength = length;
      return dataView;
    }
    function commitWrite() {
      offset += lastLength;
    }
    function writeFloat64(value2) {
      commitWrite(prepareWrite(8).setFloat64(offset, value2));
    }
    function writeUint8(value2) {
      commitWrite(prepareWrite(1).setUint8(offset, value2));
    }
    function writeUint8Array(value2) {
      var dataView2 = prepareWrite(value2.length);
      for (var i = 0; i < value2.length; ++i)
        dataView2.setUint8(offset + i, value2[i]);
      commitWrite();
    }
    function writeUint16(value2) {
      commitWrite(prepareWrite(2).setUint16(offset, value2));
    }
    function writeUint32(value2) {
      commitWrite(prepareWrite(4).setUint32(offset, value2));
    }
    function writeUint64(value2) {
      var low = value2 % POW_2_32;
      var high = (value2 - low) / POW_2_32;
      var dataView2 = prepareWrite(8);
      dataView2.setUint32(offset, high);
      dataView2.setUint32(offset + 4, low);
      commitWrite();
    }
    function writeTypeAndLength(type, length) {
      if (length < 24) {
        writeUint8(type << 5 | length);
      } else if (length < 256) {
        writeUint8(type << 5 | 24);
        writeUint8(length);
      } else if (length < 65536) {
        writeUint8(type << 5 | 25);
        writeUint16(length);
      } else if (length < 4294967296) {
        writeUint8(type << 5 | 26);
        writeUint32(length);
      } else {
        writeUint8(type << 5 | 27);
        writeUint64(length);
      }
    }
    function encodeItem(value2) {
      var i;
      if (value2 === false)
        return writeUint8(244);
      if (value2 === true)
        return writeUint8(245);
      if (value2 === null)
        return writeUint8(246);
      if (value2 === void 0)
        return writeUint8(247);
      switch (typeof value2) {
        case "number":
          if (Math.floor(value2) === value2) {
            if (0 <= value2 && value2 <= POW_2_53) {
              return writeTypeAndLength(MT_INTEGER, value2);
            }
            if (-POW_2_53 <= value2 && value2 < 0) {
              return writeTypeAndLength(MT_NEGINTEGER, -(value2 + 1));
            }
          }
          writeUint8(251);
          return writeFloat64(value2);
        case "string":
          var utf8data = [];
          for (i = 0; i < value2.length; ++i) {
            var charCode = value2.charCodeAt(i);
            if (charCode < 128) {
              utf8data.push(charCode);
            } else if (charCode < 2048) {
              utf8data.push(192 | charCode >> 6);
              utf8data.push(128 | charCode & 63);
            } else if (charCode < 55296) {
              utf8data.push(224 | charCode >> 12);
              utf8data.push(128 | charCode >> 6 & 63);
              utf8data.push(128 | charCode & 63);
            } else {
              charCode = (charCode & 1023) << 10;
              charCode |= value2.charCodeAt(++i) & 1023;
              charCode += 65536;
              utf8data.push(240 | charCode >> 18);
              utf8data.push(128 | charCode >> 12 & 63);
              utf8data.push(128 | charCode >> 6 & 63);
              utf8data.push(128 | charCode & 63);
            }
          }
          writeTypeAndLength(MT_UTF8, utf8data.length);
          return writeUint8Array(utf8data);
        default:
          var length;
          if (Array.isArray(value2)) {
            length = value2.length;
            writeTypeAndLength(MT_ARRAY, length);
            for (i = 0; i < length; ++i)
              encodeItem(value2[i]);
          } else if (value2 instanceof Uint8Array) {
            writeTypeAndLength(MT_BYTES, value2.length);
            writeUint8Array(value2);
          } else if (value2 instanceof Map) {
            length = value2.size;
            writeTypeAndLength(MT_MAP, length);
            for (let [key2, val] of value2) {
              encodeItem(key2);
              encodeItem(val);
            }
          } else {
            var keys = Object.keys(value2);
            length = keys.length;
            writeTypeAndLength(MT_MAP, length);
            for (i = 0; i < length; ++i) {
              var key = keys[i];
              encodeItem(key);
              encodeItem(value2[key]);
            }
          }
      }
    }
    encodeItem(value);
    return data.slice(0, offset);
  }
  static async verifyCWT(_cwt, verificationKey) {
    let [ph, uph, payload, signature] = _CWT.decode(_cwt);
    let zeroBstr = new Uint8Array(0);
    const Sig_structure = ["Signature1", ph, zeroBstr, payload];
    let Sig_structure_encoded = _CWT.encode(Sig_structure);
    let verified = false;
    try {
      verified = await DGCKey.verify(verificationKey, signature, Sig_structure_encoded);
      console.log("VERIFIED:", verified);
    } catch (error) {
      console.log("ERROR:", error);
    }
    return verified;
  }
  static decode(data, tagger, simpleValue) {
    var dataView = new DataView(data);
    var offset = 0;
    if (typeof tagger !== "function")
      tagger = function(value) {
        return value;
      };
    if (typeof simpleValue !== "function")
      simpleValue = function() {
        return void 0;
      };
    function commitRead(length, value) {
      offset += length;
      return value;
    }
    function readArrayBuffer(length) {
      return commitRead(length, new Uint8Array(data, offset, length));
    }
    function readFloat16() {
      var tempArrayBuffer = new ArrayBuffer(4);
      var tempDataView = new DataView(tempArrayBuffer);
      var value = readUint16();
      var sign = value & 32768;
      var exponent = value & 31744;
      var fraction = value & 1023;
      if (exponent === 31744)
        exponent = 255 << 10;
      else if (exponent !== 0)
        exponent += 127 - 15 << 10;
      else if (fraction !== 0)
        return (sign ? -1 : 1) * fraction * POW_2_24;
      tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
      return tempDataView.getFloat32(0);
    }
    function readFloat32() {
      return commitRead(4, dataView.getFloat32(offset));
    }
    function readFloat64() {
      return commitRead(8, dataView.getFloat64(offset));
    }
    function readUint8() {
      return commitRead(1, dataView.getUint8(offset));
    }
    function readUint16() {
      return commitRead(2, dataView.getUint16(offset));
    }
    function readUint32() {
      return commitRead(4, dataView.getUint32(offset));
    }
    function readUint64() {
      return readUint32() * POW_2_32 + readUint32();
    }
    function readBreak() {
      if (dataView.getUint8(offset) !== 255)
        return false;
      offset += 1;
      return true;
    }
    function readLength(additionalInformation) {
      if (additionalInformation < 24)
        return additionalInformation;
      if (additionalInformation === 24)
        return readUint8();
      if (additionalInformation === 25)
        return readUint16();
      if (additionalInformation === 26)
        return readUint32();
      if (additionalInformation === 27)
        return readUint64();
      if (additionalInformation === 31)
        return -1;
      throw "Invalid length encoding";
    }
    function readIndefiniteStringLength(majorType) {
      var initialByte = readUint8();
      if (initialByte === 255)
        return -1;
      var length = readLength(initialByte & 31);
      if (length < 0 || initialByte >> 5 !== majorType)
        throw "Invalid indefinite length element";
      return length;
    }
    function appendUtf16Data(utf16data, length) {
      for (var i = 0; i < length; ++i) {
        var value = readUint8();
        if (value & 128) {
          if (value < 224) {
            value = (value & 31) << 6 | readUint8() & 63;
            length -= 1;
          } else if (value < 240) {
            value = (value & 15) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
            length -= 2;
          } else {
            value = (value & 15) << 18 | (readUint8() & 63) << 12 | (readUint8() & 63) << 6 | readUint8() & 63;
            length -= 3;
          }
        }
        if (value < 65536) {
          utf16data.push(value);
        } else {
          value -= 65536;
          utf16data.push(55296 | value >> 10);
          utf16data.push(56320 | value & 1023);
        }
      }
    }
    function decodeItem() {
      var initialByte = readUint8();
      var majorType = initialByte >> 5;
      var additionalInformation = initialByte & 31;
      var i;
      var length;
      if (majorType === MT_FLOAT) {
        switch (additionalInformation) {
          case 25:
            return readFloat16();
          case 26:
            return readFloat32();
          case 27:
            return readFloat64();
        }
      }
      length = readLength(additionalInformation);
      if (length < 0 && (majorType < 2 || 6 < majorType))
        throw "Invalid length";
      switch (majorType) {
        case MT_INTEGER:
          return length;
        case MT_NEGINTEGER:
          return -1 - length;
        case MT_BYTES:
          if (length < 0) {
            var elements = [];
            var fullArrayLength = 0;
            while ((length = readIndefiniteStringLength(majorType)) >= 0) {
              fullArrayLength += length;
              elements.push(readArrayBuffer(length));
            }
            var fullArray = new Uint8Array(fullArrayLength);
            var fullArrayOffset = 0;
            for (i = 0; i < elements.length; ++i) {
              fullArray.set(elements[i], fullArrayOffset);
              fullArrayOffset += elements[i].length;
            }
            return fullArray;
          }
          return readArrayBuffer(length);
        case MT_UTF8:
          var utf16data = [];
          if (length < 0) {
            while ((length = readIndefiniteStringLength(majorType)) >= 0)
              appendUtf16Data(utf16data, length);
          } else {
            appendUtf16Data(utf16data, length);
          }
          return String.fromCharCode.apply(null, utf16data);
        case MT_ARRAY:
          var retArray;
          if (length < 0) {
            console.log("INDEFINITE LENGTH ARRAY");
            retArray = [];
            while (!readBreak())
              retArray.push(decodeItem());
          } else {
            retArray = new Array(length);
            for (i = 0; i < length; ++i)
              retArray[i] = decodeItem();
          }
          return retArray;
        case MT_MAP:
          var retMap = new Map();
          for (i = 0; i < length || length < 0 && !readBreak(); ++i) {
            var key = decodeItem();
            retMap.set(key, decodeItem());
          }
          return retMap;
        case MT_TAG:
          return tagger(decodeItem(), length);
        case 7:
          switch (length) {
            case 20:
              return false;
            case 21:
              return true;
            case 22:
              return null;
            case 23:
              return void 0;
            default:
              return simpleValue(length);
          }
      }
    }
    var ret = decodeItem();
    if (offset !== data.byteLength)
      throw "Remaining bytes";
    return ret;
  }
  static async decodeCWT(data, verify) {
    var dataView = new DataView(data);
    function decodeHeadersOld(protectedHeaders2, unprotectedHeaders2) {
      const CWT_ALG2 = 1;
      const CWT_KID2 = 4;
      protectedHeaders2 = protectedHeaders2.slice();
      let headers2 = _CWT.decode(protectedHeaders2.buffer);
      let headersJWT = new Map();
      for (let [key, value] of headers2) {
        switch (key) {
          case CWT_ALG2: {
            let alg = CWT_ALG_TO_JWT.get(value);
            if (alg == void 0) {
              throw `Undefined algorithm: ${value}`;
            }
            headersJWT.set("alg", alg);
            break;
          }
          case CWT_KID2: {
            let kid = bytes2hexStr(value);
            headersJWT.set("kid", kid);
            break;
          }
          default:
            break;
        }
      }
      for (let [key, value] of unprotectedHeaders2) {
        switch (key) {
          case CWT_KID2: {
            let kid = bytes2hexStr(value);
            headersJWT.set("kid", kid);
            break;
          }
          default:
            break;
        }
      }
      return headersJWT;
    }
    function decodeHeaders(protectedHeaders2, unprotectedHeaders2) {
      let newProtectedHeaders = protectedHeaders2.slice();
      let headers2 = _CWT.decode(newProtectedHeaders.buffer);
      let alg_number = headers2.get(CWT_ALG);
      if (alg_number === void 0) {
        throw "Missing algorithm in protected headers";
      }
      let alg_string = CWT_ALG_TO_JWT.get(alg_number);
      if (alg_string === void 0) {
        throw `Invalid algorithm specified: ${alg_number}`;
      }
      let headers_obj = {};
      headers_obj["alg"] = alg_string;
      let kid = headers2.get(CWT_KID);
      if (kid === void 0) {
        kid = unprotectedHeaders2.get(CWT_KID);
      }
      if (kid === void 0) {
        throw "Missing kid in headers";
      }
      let kid_str = "";
      for (let i = 0; i < kid.length; i++) {
        kid_str = kid_str + String.fromCodePoint(kid[i]);
      }
      kid_str = window.btoa(kid_str);
      headers_obj["kid"] = kid_str;
      return headers_obj;
    }
    function decodePayloadAsObject(payload2) {
      const CWT_ISS = 1;
      const CWT_SUB = 2;
      const CWT_AUD = 3;
      const CWT_EXP = 4;
      const CWT_NBF = 5;
      const CWT_IAT = 6;
      const CWT_CTI = 7;
      const HCERT = -260;
      const EU_DCC = 1;
      const T_VACCINATION = "v";
      const T_TEST = "t";
      const T_RECOVERY = "r";
      payload2 = payload2.slice();
      let decodedPayload = _CWT.decode(payload2.buffer);
      payload2 = {};
      for (let [key, value] of decodedPayload) {
        switch (key) {
          case CWT_ISS:
            payload2["iss"] = value;
            break;
          case CWT_SUB:
            payload2["sub"] = value;
            break;
          case CWT_AUD:
            payload2["aud"] = value;
            break;
          case CWT_EXP:
            payload2["exp"] = value;
            break;
          case CWT_NBF:
            payload2["nbf"] = value;
            break;
          case CWT_IAT:
            payload2["iat"] = value;
            break;
          case CWT_CTI:
            payload2["cti"] = value;
            break;
          default:
            break;
        }
      }
      let hcert = decodedPayload.get(HCERT);
      if (hcert == void 0) {
        throw "No hcert found";
      }
      let euCovid = hcert.get(EU_DCC);
      if (euCovid == void 0) {
        throw "No EU COVID certificate found";
      }
      try {
        payload2["version"] = euCovid.get("ver");
        payload2["foreName"] = euCovid.get("nam").get("fn");
        payload2["givenName"] = euCovid.get("nam").get("gn");
        payload2["fullName"] = payload2["foreName"] + ", " + payload2["givenName"];
        payload2["dateOfBirth"] = euCovid.get("dob");
      } catch (error) {
        throw `Error accessing required common fields: ${error}`;
      }
      let c;
      if (euCovid.get("v")) {
        payload2["certType"] = T_VACCINATION;
        c = euCovid.get("v")[0];
      } else if (euCovid.get("r")) {
        payload2["certType"] = T_RECOVERY;
        c = euCovid.get("r")[0];
      } else if (euCovid.get("t")) {
        payload2["certType"] = T_TEST;
        c = euCovid.get("t")[0];
      } else {
        throw `Invalid EU COVID certificate type`;
      }
      if (payload2["certType"] === T_VACCINATION) {
        payload2["diseaseTargeted"] = vs.get(c.get("tg"), "disease-agent-targeted");
        payload2["vaccineProphylaxis"] = vs.get(c.get("vp"), "vaccine-prophylaxis");
        payload2["medicinalProduct"] = vs.get(c.get("mp"), "vaccine-medicinal-product");
        payload2["manufacturer"] = vs.get(c.get("ma"), "vaccine-mah-manf");
        payload2["doseNumber"] = c.get("dn");
        payload2["doseTotal"] = c.get("sd");
        payload2["dateVaccination"] = c.get("dt");
        payload2["country"] = vs.get(c.get("co"), "country-2-codes");
        payload2["certificateIssuer"] = c.get("is");
        payload2["uniqueIdentifier"] = c.get("ci");
      } else if (payload2["certType"] === T_TEST) {
        payload2["diseaseTargeted"] = vs.get(c.get("tg"), "disease-agent-targeted");
        payload2["typeTest"] = vs.get(c.get("tt"), "test-type");
        payload2["testName"] = c.get("nm");
        payload2["manufacturer"] = vs.get(c.get("ma"), "test-manf");
        payload2["timeSample"] = c.get("sc");
        payload2["testResult"] = vs.get(c.get("tr"), "test-result");
        payload2["testingCentre"] = c.get("tc");
        payload2["country"] = vs.get(c.get("co"), "country-2-codes");
        payload2["certificateIssuer"] = c.get("is");
        payload2["uniqueIdentifier"] = c.get("ci");
      } else if (payload2["certType"] === T_RECOVERY) {
        payload2["diseaseTargeted"] = vs.get(c.get("tg"), "disease-agent-targeted");
        payload2["datePositive"] = c.get("fr");
        payload2["dateFrom"] = c.get("df");
        payload2["dateUntil"] = c.get("du");
        payload2["country"] = vs.get(c.get("co"), "country-2-codes");
        payload2["certificateIssuer"] = c.get("is");
        payload2["uniqueIdentifier"] = c.get("ci");
      }
      return payload2;
    }
    function decodePayload(payload2) {
      const CWT_ISS = 1;
      const CWT_SUB = 2;
      const CWT_AUD = 3;
      const CWT_EXP = 4;
      const CWT_NBF = 5;
      const CWT_IAT = 6;
      const CWT_CTI = 7;
      payload2 = payload2.slice();
      let decodedPayload = _CWT.decode(payload2.buffer);
      payload2 = new Map();
      for (let [key, value] of decodedPayload) {
        switch (key) {
          case CWT_ISS:
            payload2.set("iss", value);
            break;
          case CWT_SUB:
            payload2.set("sub", value);
            break;
          case CWT_AUD:
            payload2.set("aud", value);
            break;
          case CWT_EXP:
            payload2.set("exp", value);
            break;
          case CWT_NBF:
            payload2.set("nbf", value);
            break;
          case CWT_IAT:
            payload2.set("iat", value);
            break;
          case CWT_CTI:
            payload2.set("cti", value);
            break;
          default:
            break;
        }
      }
      let hcert = decodedPayload.get(-260);
      if (hcert == void 0) {
        throw "No hcert found";
      }
      let euCovid = hcert.get(1);
      if (euCovid == void 0) {
        throw "No EU COVID certificate found";
      }
      let euCovidMap = new Map();
      euCovidMap.set("euCovid", euCovid);
      payload2.set("hcert", euCovidMap);
      return payload2;
    }
    var initialByte = dataView.getUint8(0);
    var mt = initialByte >> 5;
    var additionalInformation = initialByte & 31;
    if (mt != MT_TAG) {
      throw new Error(`COSE object must start with a tag: ${mt}`);
    }
    if (additionalInformation != COSE_Sign1) {
      throw new Error(`Not a COSE Single signature, tag: ${additionalInformation}`);
    }
    data = data.slice(1);
    let [protectedHeaders, unprotectedHeaders, payload, signature] = _CWT.decode(data);
    let headers = decodeHeaders(protectedHeaders, unprotectedHeaders);
    let verified = false;
    if (verify) {
      let kid = headers["kid"];
      let k = await getTrustedKey(kid);
      if (k.list === "EU_PRO") {
        console.log(k);
        let verificationKey = await DGCKey.fromJWK(k.publicKey);
        verified = await _CWT.verifyCWT(data, verificationKey);
      } else if (k.list === "UK_PRO") {
        let verificationKey = await DGCKey.fromSPKI(k.publicKey);
        verified = await _CWT.verifyCWT(data, verificationKey);
      } else if (k.list === "EU_PREPRODUCTION") {
        verified = "PRE";
      }
    }
    payload = decodePayloadAsObject(payload);
    console.log("Payload:", payload);
    return [headers, payload, signature, verified];
  }
  static async decodeHC1QR(data, verify = false) {
    if (!data.startsWith("HC1:")) {
      throw new Error("Certificate does not start with 'HC1:'");
    }
    data = data.slice(4);
    let cvdCompressed = decodeB45(data);
    cvdCompressed = new Uint8Array(cvdCompressed);
    let coseCVD = inflate_1$2(cvdCompressed);
    let [headers, payload, signature, verified] = await _CWT.decodeCWT(coseCVD.buffer, verify);
    return [headers, payload, signature, verified];
  }
  static displayMB(ib) {
    var majorType = ib >> 5;
    var additionalInformation = ib & 31;
    var i;
    var length = additionalInformation;
    if (majorType === MT_FLOAT) {
      console.log("FLOAT");
    }
    switch (majorType) {
      case MT_INTEGER:
        console.log(`Integer ${length}`);
        return;
      case MT_NEGINTEGER:
        console.log(`Negative Integer ${-1 - length}`);
        return;
      case MT_BYTES:
        console.log(`Bstr ${length}`);
        return `Bstr ${length}`;
      case MT_UTF8:
        console.log(`String ${length}`);
        return;
      case MT_ARRAY:
        console.log(`Array ${length}`);
        return;
      case MT_MAP:
        console.log(`Map ${length}`);
        return;
      case MT_TAG:
        console.log(`Tag ${length}`);
        return;
      case 7:
        switch (length) {
          case 20:
            console.log(`FALSE`);
            return;
          case 21:
            console.log(`TRUE`);
            return;
          case 22:
            console.log(`NULL`);
            return;
          case 23:
            console.log(`UNDEFINED`);
            return;
          default:
            console.log(`Simple Value`);
            return;
        }
    }
  }
};
var CWT = _CWT;
__publicField(CWT, "POW_2_24", 5960464477539063e-23);
__publicField(CWT, "POW_2_32", 4294967296);
__publicField(CWT, "POW_2_53", Number.MAX_SAFE_INTEGER);

// src/pages/abstractpage.js
var AbstractPage = class {
  constructor(id) {
    if (this.tagName === void 0) {
      this.tagName = "div";
    }
    this.domElem = document.createElement(this.tagName);
    if (id) {
      this.domElem.id = id;
    }
    this.domElem.style.display = "none";
  }
  render(theHtml) {
    this.domElem.style.display = "block";
    HeaderBar();
    render(theHtml, this.domElem);
  }
};

// src/pages/hcertpage.js
var DisplayHcert = class extends AbstractPage {
  constructor(domElem2) {
    console.log("HCERT: Constructor");
    super(domElem2);
  }
  async enter(qrContent, historyData) {
    console.log("PRESENT Enter", qrContent);
    let hcert = void 0;
    let verified = false;
    let thehtml = "";
    try {
      hcert = await CWT.decodeHC1QR(qrContent, true);
      verified = hcert[3];
    } catch (error) {
      log.myerror("Error verifying credential", error);
      this.render(this.renderGeneralError(error));
      return;
    }
    try {
      thehtml = this.renderDetail(hcert, verified);
    } catch (error) {
      log.myerror("Error rendering credential", error);
      this.render(this.renderGeneralError(error));
      return;
    }
    let fullPage = html`
        ${thehtml}
        <div class="sect-white">
            <button @click=${() => gotoPage("verifier")} class="w3-button btn-color-primary btn-hover-color-primary
            w3-xlarge w3-round-xlarge">
            ${T("Verify another")}</button>
        </div>
        `;
    this.render(fullPage);
  }
  renderGeneralError(error) {
    return html`
            <div id="hcertFailed" class="w3-panel bkg-fail">
                <h3>Failed!</h3>
                <p>The credential has an invalid format.</p>
            </div>
            `;
  }
  renderDetail(cred, verified) {
    let payload = cred[1];
    let thehtml = "Unrecognized";
    let msg = html`
            <div id="hcertFailed" class="w3-panel bkg-fail">
                <h3>${T("Failed!")}</h3>
                <p>${T("Signature validation failed. The certificate is not valid.")}</p>
            </div>
            `;
    if (verified === "PRE") {
      msg = html`
            <div id="hcertWarning" class="w3-panel bkg-warning">
                <h3>${T("Warning!")}</h3>
                <p>${T("$warningmsg")}</p>
            </div>
            `;
    } else if (verified === true) {
      msg = html`
            <div id="hcertValidated" class="w3-panel bkg-success w3-border">
                <h3>${T("Validated!")}</h3>
                <p>${T("The certificate is valid.")}</p>
            </div>
            `;
    }
    if (payload["certType"] == "v") {
      thehtml = html`

            <section class="section">
                <div class="subsection">
                    <h3 class="w3-center">${T("EU DIGITAL COVID CERTIFICATE")}</h3>
                </div>
                <div class="subsection">
                    <h4 class="w3-center"><b>${T("Vaccination")}</b></h4>
                </div>
            </section>

            ${msg}

            <div class="container">
                <section class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Surname and forename")}</div>
                        <div class="valor">${payload.fullName}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Date of birth")}</div>
                        <div class="valor">${payload.dateOfBirth}</div>
                    </div>
                </section>
                
                <section class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Dose number/Total doses")}</div>
                        <div class="valor">${payload.doseNumber}/${payload.doseTotal}</div>
                    </div>
        
                    <div class="subsection">
                        <div class="etiqueta">${T("Date of vaccination")}</div>
                        <div class="valor">${payload.dateVaccination}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Member State of vaccination")}</div>
                        <div class="valor">${payload.country}</div>
                    </div>
                </section>
                
                <section class="section">
                    <div class="subsection">
                        <div class="etiqueta mt-3">${T("Disease targeted")}</div>
                        <div class="valor mt-3">${payload.diseaseTargeted}</div>
                    </div>
                </section>

                <section class="section">
            
                    <div class="subsection">
                        <div class="etiqueta mt-3">${T("Vaccine/prophylaxis")}</div>
                        <div class="valor mb-3">${payload.vaccineProphylaxis}</div>
                    </div>
            
                    <div class="subsection">
                        <div class="etiqueta">${T("Vaccine medicinal product")}</div>
                        <div class="valor mb-3">${payload.medicinalProduct}</div>
                    </div>
            
                    <div class="subsection">
                        <div class="etiqueta">${T("Manufacturer")}</div>
                        <div class="valor">${payload.manufacturer}</div>            
                    </div>
            
                </section>
                <section class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Certificate identifier")}</div>
                        <div class="valor" style="word-break: break-all;">${payload.uniqueIdentifier}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Certificate issuer")}</div>
                        <div class="valor">${payload.certificateIssuer}</div>                
                    </div>
                </section>
                                
            </div>
            `;
    }
    if (payload["certType"] == "t") {
      thehtml = html`

            <section class="section">
                <div class="subsection">
                    <h3 class="w3-center">${T("EU DIGITAL COVID CERTIFICATE")}</h3>
                </div>
                <div class="subsection">
                    <h4 class="w3-center"><b>${T("Test")}</b></h4>
                </div>
            </section>

            ${msg}

            <div class="container">
                <div class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Surname and forename")}</div>
                        <div class="valor">${payload.fullName}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Date of birth")}</div>
                        <div class="valor">${payload.dateOfBirth}</div>
                    </div>
                </div>
                
                <div class="section">
                
                    <div class="subsection">
                
                        <div class="etiqueta mt-3">${T("Test Name")}</div>
                        <div class="valor mb-3">${payload.typeTest}</div>

                        <div class="etiqueta mt-3">${T("Test Result")}</div>
                        <div class="valor mb-3">${payload.testResult}</div>
            
                        <div class="etiqueta">${T("Date/Time of Sample Collection")}</div>
                        <div class="valor mb-3">${payload.timeSample}</div>
            
                    </div>
                
                </div>
                
                <section class="section">
                        <div class="subsection">
                            <div class="etiqueta mt-3">${T("Disease targeted")}</div>
                            <div class="valor mt-3">${payload.diseaseTargeted}</div>
                        </div>
                    </section>

                <div class="section">
                
                    <div class="subsection">
            
                        <div class="etiqueta">${T("Manufacturer")}</div>
                        <div class="valor">${payload.manufacturer}</div>
            
                        <div class="etiqueta">${T("Testing Centre")}</div>
                        <div class="valor">${payload.testingCentre}</div>
                    </div>
                
                </div>


                <div class="section">
                    <div class="subsection">
                        <div class="etiqueta mt-3">${T("Certificate identifier")}</div>
                        <div class="valor" style="word-break: break-all;">${payload.uniqueIdentifier}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Certificate issuer")}</div>
                        <div class="valor">${payload.certificateIssuer}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Country")}</div>
                        <div class="valor">${payload.country}</div>
                    </div>

                </div>
                
            </div>
            `;
    }
    if (payload["certType"] == "r") {
      thehtml = html`

            <section class="section">
                <div class="subsection">
                    <h3 class="w3-center">${T("EU DIGITAL COVID CERTIFICATE")}</h3>
                </div>
                <div class="subsection">
                    <h4 class="w3-center"><b>${T("Recovery")}</b></h4>
                </div>
            </section>

            ${msg}

            <div class="container">
                <div class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Surname and forename")}</div>
                        <div class="valor">${payload.fullName}</div>
                    </div>
                    <div class="subsection">
                        <div class="etiqueta">${T("Date of birth")}</div>
                        <div class="valor">${payload.dateOfBirth}</div>
                    </div>
                </div>
           
                <div class="section">
            
                    <div class="subsection">
                        <div class="etiqueta">${T("Date of positive")}</div>
                        <div class="valor">${payload.datePositive}</div>
                    </div>
            
                    <div class="subsection">
                        <div class="etiqueta">${T("Valid from")}</div>
                        <div class="valor">${payload.dateFrom}</div>
                    </div>
            
                    <div class="subsection">
                        <div class="etiqueta mt-3">${T("Valid to")}</div>
                        <div class="valor">${payload.dateUntil}</div>
                    </div>
            
                </div>
            
                <div class="section">
                    <div class="subsection">
                        <div class="etiqueta mt-3">${T("Disease targeted")}</div>
                        <div class="valor mt-3">${payload.diseaseTargeted}</div>
                        </div>
                    </div>
                </div>

                <div class="section">
                    <div class="subsection">
                        <div class="etiqueta">${T("Certificate identifier")}</div>
                        <div class="valor" style="word-break: break-all;"><strong>${payload.uniqueIdentifier}</strong></div>
            
                        <div class="etiqueta">${T("Certificate issuer")}</div>
                        <div class="valor">${payload.certificateIssuer}</div>
            
                        <div class="etiqueta">${T("Country")}</div>
                        <div class="valor">${payload.country}</div>
            
                    </div>
            
                </div>
            </div>
            `;
    }
    return thehtml;
  }
};

// src/pages/demo.js
var vaccinationQR = "HC1:NCFOXN%TSMAHN-HPO45JVLFDISVM85:D4*OV-36QHN-TM5*KQM3*GML0FXIKMWDWYPWHH:ZH6I1$4JN:IN1MPK9V L9L69UEG%6M415BEC4633F-96SW6SJE3ZMXDMUF6NZ6E6AH+932Q6G39ZILAPZXI$MI1VCSWC%PDMOL7AD.XIIXB0 J5QB06JOMI/LKW1JVTIM7JZIJI7JIZI.EJJ14B2MZ8DC8CWVD 8D*NI+PB/VSQOL9DLKWCZ3E7KDW0KZ J$XI4OIMEDTJCJKDLEDL9CZTAKBI/8D:8DKTDL+SQ05.$S6ZCJKBPKJDG3LWTXD3/9TL4T.B9GYP8T1+1V$LA*ZEBH1T+UZ%HQK9CZPME1.*UWKU/.1ZY9 UPG706ZRB KYZQBK9-RUUBCFRMLNKNM8JI0JPGO7HWPAG2B5VL3K9OTJ0UL4ZVBWSA81TXH4YVZ38+APZGJKDJB1PGB49WE*7CY2P3LM DOLQ9KKAX15BP3:GNSFKPOQU-0DCOTCPHXOP40SF355";
var recoveryQR = "HC1:NCFOXN%TSMAHN-HKTGX94G-ICWEXWPDDH9M9ESIARGHXK7V4A:C5B9VUFJMP5VC9:BPCNUKMOFE1JAA/CFZJDIKLEM1FC$50B464*632NPK98.031A E9PF6846A$Q 76UW6B699B5RFUOV1TU1BPISNHHJECNN+-CZJJ+.K4IJZJJBY4.Z8YLV0C58G13HHEGJDFH5B9-NT0 2Q58DV5 R1JMI:TURBG5Q14UVMRVUVI/E2$4JY/K+.S+2T%:KW/S8JVR+3$BJ.+I92K70ULOJ1ALJYJAZI-3C ZJ83B7N2*EU:H3N6E N3$9T5-IZ0K%PIUY25HTS SR633WSNYJF0JEYI1DLZZL162IHQAQU*0FGANYCVXMMVY6G%LSVEZ%NVBC1.M+.9Q6V.C6ZH4:KVUE87G77AS BPE/7+WL-TS+ESEWSUZD2XCDJV7KLQ39X%O7DQT-AHB0JNEZRE";
var testQR = "HC1:NCFOXN%TSMAHN-HKTGX94G-ICWEXWP769FLT3XH74M6R5ZEH%/1.TMBX43Q1B0E/GPWBILC9FF9WNHR-S7D1PI0BARKN4412IP149D%QKS1J WJP*Q.XIQXB8UJ06JSVBDKBDJJKCILML%ZJJ7J/NIKMINYJ3A41VCSWC%PDB2M67D$JCYJC66CVV8VZ0958AHLAA3S3NZ*U0I1-I0*OC6H0/VM8OI6S99K6QJ2BMAOCIPLIO4KRK4WPE-L95*BG+SB.V4Q56EK+:LJDQIYO*%NH$RSC9LHFEF89LN3%85G1U-K037Y0B /KE$CM%IG4TK47B+2Q$SQ0531T7$S5RVCNNIQV$IVYWVX:88AL**IVRFNK7XKRZK72RVV+0V7J$%25I3KC3X83$87089PRLOC8EJB6QJW V-W1OK2H:I8JVAS2V.R4ONB49ZWKTYU1:T-$CW4VPQ4P2CS1O$H891VJ:E41E0WMJ*0STQGID+BMF*V4.OF+1:TFT5G";
var DemoPage = class extends AbstractPage {
  constructor(domElem2) {
    console.log("DEMO: inside constructor");
    super(domElem2);
  }
  enter() {
    console.log("DEMO: enter page");
    let theHtml = html`
        <!-- =========================================== -->
        <!-- HOME PAGE for demos. It has several roles   -->
        <!-- and the user can choose                     -->
        <!-- =========================================== -->
        
        <div class="container">
            <a @click=${() => gotoPage("passenger")}>
                <div class="panel">
                    <h3>I am a Passenger</h3>
                    <p>Manage your certificates</p>
                </div>
            </a>
            
            <a @click=${() => gotoPage("verifier")}>
                <div class="panel">
                    <h3>I am a Verifier</h3>
                    <p>Check validity of a certificate</p>
                </div>
            </a>

            <a @click=${() => gotoPage("displayhcert", vaccinationQR)}>
                <div class="panel">
                    <h3>Vaccination QR</h3>
                    <p>Only for testing</p>
                </div>
            </a>

            <a @click=${() => gotoPage("displayhcert", testQR)}>
                <div class="panel">
                    <h3>Test QR</h3>
                    <p>Only for testing</p>
                </div>
            </a>
            
            <a @click=${() => gotoPage("displayhcert", recoveryQR)}>
                <div class="panel">
                    <h3>Recovery QR</h3>
                    <p>Only for testing</p>
                </div>
            </a>
            
            <a @click=${() => gotoPage("issuerHome")}>
                <div class="panel">
                    <h3>I am an Issuer</h3>
                    <p>Display available certificates</p>
                </div>
            </a>
            
            <a @click=${() => gotoPage("pubcreds")}>
                <div class="panel">
                    <h3>Public Credentials</h3>
                    <p>Query the public credentials</p>
                </div>
            </a>
            
            <a @click=${() => gotoPage("admin")}>
                <div class="panel">
                    <h3 class="card-title">Admin</h3>
                    <p>Only if you know what you are doing</p>
                </div>
            </a>
        </div>
        `;
    this.render(theHtml);
  }
};

// src/pages/page404.js
var Page404 = class extends AbstractPage {
  constructor(domElem2) {
    console.log("PAGE404: inside constructor");
    super(domElem2);
  }
  enter() {
    console.log("PAGE404: enter page");
    let theHtml = html`
        <div class="w3-container">
            <h1>The page does not exist!</h1>
        </div>
        `;
    this.render(theHtml);
  }
};

// node_modules/ts-custom-error/dist/custom-error.mjs
function fixProto(target, prototype) {
  var setPrototypeOf = Object.setPrototypeOf;
  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
  if (fn === void 0) {
    fn = target.constructor;
  }
  var captureStackTrace = Error.captureStackTrace;
  captureStackTrace && captureStackTrace(target, fn);
}
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) {
        if (b2.hasOwnProperty(p)) {
          d2[p] = b2[p];
        }
      }
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CustomError = function(_super) {
  __extends(CustomError2, _super);
  function CustomError2(message) {
    var _newTarget = this.constructor;
    var _this = _super.call(this, message) || this;
    Object.defineProperty(_this, "name", {
      value: _newTarget.name,
      enumerable: false,
      configurable: true
    });
    fixProto(_this, _newTarget.prototype);
    fixStack(_this);
    return _this;
  }
  return CustomError2;
}(Error);

// node_modules/@zxing/library/esm/core/Exception.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Exception = function(_super) {
  __extends2(Exception2, _super);
  function Exception2(message) {
    if (message === void 0) {
      message = void 0;
    }
    var _this = _super.call(this, message) || this;
    _this.message = message;
    return _this;
  }
  Exception2.prototype.getKind = function() {
    var ex = this.constructor;
    return ex.kind;
  };
  Exception2.kind = "Exception";
  return Exception2;
}(CustomError);
var Exception_default = Exception;

// node_modules/@zxing/library/esm/core/ArgumentException.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ArgumentException = function(_super) {
  __extends3(ArgumentException2, _super);
  function ArgumentException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ArgumentException2.kind = "ArgumentException";
  return ArgumentException2;
}(Exception_default);
var ArgumentException_default = ArgumentException;

// node_modules/@zxing/library/esm/core/IllegalArgumentException.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IllegalArgumentException = function(_super) {
  __extends4(IllegalArgumentException2, _super);
  function IllegalArgumentException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IllegalArgumentException2.kind = "IllegalArgumentException";
  return IllegalArgumentException2;
}(Exception_default);
var IllegalArgumentException_default = IllegalArgumentException;

// node_modules/@zxing/library/esm/core/BinaryBitmap.js
var BinaryBitmap = function() {
  function BinaryBitmap2(binarizer) {
    this.binarizer = binarizer;
    if (binarizer === null) {
      throw new IllegalArgumentException_default("Binarizer must be non-null.");
    }
  }
  BinaryBitmap2.prototype.getWidth = function() {
    return this.binarizer.getWidth();
  };
  BinaryBitmap2.prototype.getHeight = function() {
    return this.binarizer.getHeight();
  };
  BinaryBitmap2.prototype.getBlackRow = function(y, row) {
    return this.binarizer.getBlackRow(y, row);
  };
  BinaryBitmap2.prototype.getBlackMatrix = function() {
    if (this.matrix === null || this.matrix === void 0) {
      this.matrix = this.binarizer.getBlackMatrix();
    }
    return this.matrix;
  };
  BinaryBitmap2.prototype.isCropSupported = function() {
    return this.binarizer.getLuminanceSource().isCropSupported();
  };
  BinaryBitmap2.prototype.crop = function(left, top, width, height) {
    var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
    return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
  };
  BinaryBitmap2.prototype.isRotateSupported = function() {
    return this.binarizer.getLuminanceSource().isRotateSupported();
  };
  BinaryBitmap2.prototype.rotateCounterClockwise = function() {
    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
    return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
  };
  BinaryBitmap2.prototype.rotateCounterClockwise45 = function() {
    var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
    return new BinaryBitmap2(this.binarizer.createBinarizer(newSource));
  };
  BinaryBitmap2.prototype.toString = function() {
    try {
      return this.getBlackMatrix().toString();
    } catch (e) {
      return "";
    }
  };
  return BinaryBitmap2;
}();
var BinaryBitmap_default = BinaryBitmap;

// node_modules/@zxing/library/esm/core/ChecksumException.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ChecksumException = function(_super) {
  __extends5(ChecksumException2, _super);
  function ChecksumException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ChecksumException2.getChecksumInstance = function() {
    return new ChecksumException2();
  };
  ChecksumException2.kind = "ChecksumException";
  return ChecksumException2;
}(Exception_default);
var ChecksumException_default = ChecksumException;

// node_modules/@zxing/library/esm/core/Binarizer.js
var Binarizer = function() {
  function Binarizer2(source) {
    this.source = source;
  }
  Binarizer2.prototype.getLuminanceSource = function() {
    return this.source;
  };
  Binarizer2.prototype.getWidth = function() {
    return this.source.getWidth();
  };
  Binarizer2.prototype.getHeight = function() {
    return this.source.getHeight();
  };
  return Binarizer2;
}();
var Binarizer_default = Binarizer;

// node_modules/@zxing/library/esm/core/util/System.js
var System = function() {
  function System2() {
  }
  System2.arraycopy = function(src, srcPos, dest, destPos, length) {
    while (length--) {
      dest[destPos++] = src[srcPos++];
    }
  };
  System2.currentTimeMillis = function() {
    return Date.now();
  };
  return System2;
}();
var System_default = System;

// node_modules/@zxing/library/esm/core/IndexOutOfBoundsException.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IndexOutOfBoundsException = function(_super) {
  __extends6(IndexOutOfBoundsException2, _super);
  function IndexOutOfBoundsException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IndexOutOfBoundsException2.kind = "IndexOutOfBoundsException";
  return IndexOutOfBoundsException2;
}(Exception_default);
var IndexOutOfBoundsException_default = IndexOutOfBoundsException;

// node_modules/@zxing/library/esm/core/ArrayIndexOutOfBoundsException.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ArrayIndexOutOfBoundsException = function(_super) {
  __extends7(ArrayIndexOutOfBoundsException2, _super);
  function ArrayIndexOutOfBoundsException2(index, message) {
    if (index === void 0) {
      index = void 0;
    }
    if (message === void 0) {
      message = void 0;
    }
    var _this = _super.call(this, message) || this;
    _this.index = index;
    _this.message = message;
    return _this;
  }
  ArrayIndexOutOfBoundsException2.kind = "ArrayIndexOutOfBoundsException";
  return ArrayIndexOutOfBoundsException2;
}(IndexOutOfBoundsException_default);
var ArrayIndexOutOfBoundsException_default = ArrayIndexOutOfBoundsException;

// node_modules/@zxing/library/esm/core/util/Arrays.js
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Arrays = function() {
  function Arrays2() {
  }
  Arrays2.fill = function(a, val) {
    for (var i = 0, len = a.length; i < len; i++)
      a[i] = val;
  };
  Arrays2.fillWithin = function(a, fromIndex, toIndex, val) {
    Arrays2.rangeCheck(a.length, fromIndex, toIndex);
    for (var i = fromIndex; i < toIndex; i++)
      a[i] = val;
  };
  Arrays2.rangeCheck = function(arrayLength, fromIndex, toIndex) {
    if (fromIndex > toIndex) {
      throw new IllegalArgumentException_default("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
    }
    if (fromIndex < 0) {
      throw new ArrayIndexOutOfBoundsException_default(fromIndex);
    }
    if (toIndex > arrayLength) {
      throw new ArrayIndexOutOfBoundsException_default(toIndex);
    }
  };
  Arrays2.asList = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return args;
  };
  Arrays2.create = function(rows, cols, value) {
    var arr = Array.from({length: rows});
    return arr.map(function(x2) {
      return Array.from({length: cols}).fill(value);
    });
  };
  Arrays2.createInt32Array = function(rows, cols, value) {
    var arr = Array.from({length: rows});
    return arr.map(function(x2) {
      return Int32Array.from({length: cols}).fill(value);
    });
  };
  Arrays2.equals = function(first, second) {
    if (!first) {
      return false;
    }
    if (!second) {
      return false;
    }
    if (!first.length) {
      return false;
    }
    if (!second.length) {
      return false;
    }
    if (first.length !== second.length) {
      return false;
    }
    for (var i = 0, length_1 = first.length; i < length_1; i++) {
      if (first[i] !== second[i]) {
        return false;
      }
    }
    return true;
  };
  Arrays2.hashCode = function(a) {
    var e_1, _a;
    if (a === null) {
      return 0;
    }
    var result = 1;
    try {
      for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
        var element = a_1_1.value;
        result = 31 * result + element;
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (a_1_1 && !a_1_1.done && (_a = a_1.return))
          _a.call(a_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return result;
  };
  Arrays2.fillUint8Array = function(a, value) {
    for (var i = 0; i !== a.length; i++) {
      a[i] = value;
    }
  };
  Arrays2.copyOf = function(original, newLength) {
    return original.slice(0, newLength);
  };
  Arrays2.copyOfUint8Array = function(original, newLength) {
    if (original.length <= newLength) {
      var newArray = new Uint8Array(newLength);
      newArray.set(original);
      return newArray;
    }
    return original.slice(0, newLength);
  };
  Arrays2.copyOfRange = function(original, from, to) {
    var newLength = to - from;
    var copy = new Int32Array(newLength);
    System_default.arraycopy(original, from, copy, 0, newLength);
    return copy;
  };
  Arrays2.binarySearch = function(ar, el, comparator) {
    if (comparator === void 0) {
      comparator = Arrays2.numberComparator;
    }
    var m = 0;
    var n = ar.length - 1;
    while (m <= n) {
      var k = n + m >> 1;
      var cmp = comparator(el, ar[k]);
      if (cmp > 0) {
        m = k + 1;
      } else if (cmp < 0) {
        n = k - 1;
      } else {
        return k;
      }
    }
    return -m - 1;
  };
  Arrays2.numberComparator = function(a, b) {
    return a - b;
  };
  return Arrays2;
}();
var Arrays_default = Arrays;

// node_modules/@zxing/library/esm/core/util/Integer.js
var Integer = function() {
  function Integer2() {
  }
  Integer2.numberOfTrailingZeros = function(i) {
    var y;
    if (i === 0)
      return 32;
    var n = 31;
    y = i << 16;
    if (y !== 0) {
      n -= 16;
      i = y;
    }
    y = i << 8;
    if (y !== 0) {
      n -= 8;
      i = y;
    }
    y = i << 4;
    if (y !== 0) {
      n -= 4;
      i = y;
    }
    y = i << 2;
    if (y !== 0) {
      n -= 2;
      i = y;
    }
    return n - (i << 1 >>> 31);
  };
  Integer2.numberOfLeadingZeros = function(i) {
    if (i === 0) {
      return 32;
    }
    var n = 1;
    if (i >>> 16 === 0) {
      n += 16;
      i <<= 16;
    }
    if (i >>> 24 === 0) {
      n += 8;
      i <<= 8;
    }
    if (i >>> 28 === 0) {
      n += 4;
      i <<= 4;
    }
    if (i >>> 30 === 0) {
      n += 2;
      i <<= 2;
    }
    n -= i >>> 31;
    return n;
  };
  Integer2.toHexString = function(i) {
    return i.toString(16);
  };
  Integer2.toBinaryString = function(intNumber) {
    return String(parseInt(String(intNumber), 2));
  };
  Integer2.bitCount = function(i) {
    i = i - (i >>> 1 & 1431655765);
    i = (i & 858993459) + (i >>> 2 & 858993459);
    i = i + (i >>> 4) & 252645135;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 63;
  };
  Integer2.truncDivision = function(dividend, divisor) {
    return Math.trunc(dividend / divisor);
  };
  Integer2.parseInt = function(num, radix) {
    if (radix === void 0) {
      radix = void 0;
    }
    return parseInt(num, radix);
  };
  Integer2.MIN_VALUE_32_BITS = -2147483648;
  Integer2.MAX_VALUE = Number.MAX_SAFE_INTEGER;
  return Integer2;
}();
var Integer_default = Integer;

// node_modules/@zxing/library/esm/core/common/BitArray.js
var BitArray = function() {
  function BitArray2(size, bits) {
    if (size === void 0) {
      this.size = 0;
      this.bits = new Int32Array(1);
    } else {
      this.size = size;
      if (bits === void 0 || bits === null) {
        this.bits = BitArray2.makeArray(size);
      } else {
        this.bits = bits;
      }
    }
  }
  BitArray2.prototype.getSize = function() {
    return this.size;
  };
  BitArray2.prototype.getSizeInBytes = function() {
    return Math.floor((this.size + 7) / 8);
  };
  BitArray2.prototype.ensureCapacity = function(size) {
    if (size > this.bits.length * 32) {
      var newBits = BitArray2.makeArray(size);
      System_default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
      this.bits = newBits;
    }
  };
  BitArray2.prototype.get = function(i) {
    return (this.bits[Math.floor(i / 32)] & 1 << (i & 31)) !== 0;
  };
  BitArray2.prototype.set = function(i) {
    this.bits[Math.floor(i / 32)] |= 1 << (i & 31);
  };
  BitArray2.prototype.flip = function(i) {
    this.bits[Math.floor(i / 32)] ^= 1 << (i & 31);
  };
  BitArray2.prototype.getNextSet = function(from) {
    var size = this.size;
    if (from >= size) {
      return size;
    }
    var bits = this.bits;
    var bitsOffset = Math.floor(from / 32);
    var currentBits = bits[bitsOffset];
    currentBits &= ~((1 << (from & 31)) - 1);
    var length = bits.length;
    while (currentBits === 0) {
      if (++bitsOffset === length) {
        return size;
      }
      currentBits = bits[bitsOffset];
    }
    var result = bitsOffset * 32 + Integer_default.numberOfTrailingZeros(currentBits);
    return result > size ? size : result;
  };
  BitArray2.prototype.getNextUnset = function(from) {
    var size = this.size;
    if (from >= size) {
      return size;
    }
    var bits = this.bits;
    var bitsOffset = Math.floor(from / 32);
    var currentBits = ~bits[bitsOffset];
    currentBits &= ~((1 << (from & 31)) - 1);
    var length = bits.length;
    while (currentBits === 0) {
      if (++bitsOffset === length) {
        return size;
      }
      currentBits = ~bits[bitsOffset];
    }
    var result = bitsOffset * 32 + Integer_default.numberOfTrailingZeros(currentBits);
    return result > size ? size : result;
  };
  BitArray2.prototype.setBulk = function(i, newBits) {
    this.bits[Math.floor(i / 32)] = newBits;
  };
  BitArray2.prototype.setRange = function(start, end) {
    if (end < start || start < 0 || end > this.size) {
      throw new IllegalArgumentException_default();
    }
    if (end === start) {
      return;
    }
    end--;
    var firstInt = Math.floor(start / 32);
    var lastInt = Math.floor(end / 32);
    var bits = this.bits;
    for (var i = firstInt; i <= lastInt; i++) {
      var firstBit = i > firstInt ? 0 : start & 31;
      var lastBit = i < lastInt ? 31 : end & 31;
      var mask = (2 << lastBit) - (1 << firstBit);
      bits[i] |= mask;
    }
  };
  BitArray2.prototype.clear = function() {
    var max = this.bits.length;
    var bits = this.bits;
    for (var i = 0; i < max; i++) {
      bits[i] = 0;
    }
  };
  BitArray2.prototype.isRange = function(start, end, value) {
    if (end < start || start < 0 || end > this.size) {
      throw new IllegalArgumentException_default();
    }
    if (end === start) {
      return true;
    }
    end--;
    var firstInt = Math.floor(start / 32);
    var lastInt = Math.floor(end / 32);
    var bits = this.bits;
    for (var i = firstInt; i <= lastInt; i++) {
      var firstBit = i > firstInt ? 0 : start & 31;
      var lastBit = i < lastInt ? 31 : end & 31;
      var mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
      if ((bits[i] & mask) !== (value ? mask : 0)) {
        return false;
      }
    }
    return true;
  };
  BitArray2.prototype.appendBit = function(bit) {
    this.ensureCapacity(this.size + 1);
    if (bit) {
      this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
    }
    this.size++;
  };
  BitArray2.prototype.appendBits = function(value, numBits) {
    if (numBits < 0 || numBits > 32) {
      throw new IllegalArgumentException_default("Num bits must be between 0 and 32");
    }
    this.ensureCapacity(this.size + numBits);
    for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
      this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
    }
  };
  BitArray2.prototype.appendBitArray = function(other) {
    var otherSize = other.size;
    this.ensureCapacity(this.size + otherSize);
    for (var i = 0; i < otherSize; i++) {
      this.appendBit(other.get(i));
    }
  };
  BitArray2.prototype.xor = function(other) {
    if (this.size !== other.size) {
      throw new IllegalArgumentException_default("Sizes don't match");
    }
    var bits = this.bits;
    for (var i = 0, length_1 = bits.length; i < length_1; i++) {
      bits[i] ^= other.bits[i];
    }
  };
  BitArray2.prototype.toBytes = function(bitOffset, array, offset, numBytes) {
    for (var i = 0; i < numBytes; i++) {
      var theByte = 0;
      for (var j = 0; j < 8; j++) {
        if (this.get(bitOffset)) {
          theByte |= 1 << 7 - j;
        }
        bitOffset++;
      }
      array[offset + i] = theByte;
    }
  };
  BitArray2.prototype.getBitArray = function() {
    return this.bits;
  };
  BitArray2.prototype.reverse = function() {
    var newBits = new Int32Array(this.bits.length);
    var len = Math.floor((this.size - 1) / 32);
    var oldBitsLen = len + 1;
    var bits = this.bits;
    for (var i = 0; i < oldBitsLen; i++) {
      var x2 = bits[i];
      x2 = x2 >> 1 & 1431655765 | (x2 & 1431655765) << 1;
      x2 = x2 >> 2 & 858993459 | (x2 & 858993459) << 2;
      x2 = x2 >> 4 & 252645135 | (x2 & 252645135) << 4;
      x2 = x2 >> 8 & 16711935 | (x2 & 16711935) << 8;
      x2 = x2 >> 16 & 65535 | (x2 & 65535) << 16;
      newBits[len - i] = x2;
    }
    if (this.size !== oldBitsLen * 32) {
      var leftOffset = oldBitsLen * 32 - this.size;
      var currentInt = newBits[0] >>> leftOffset;
      for (var i = 1; i < oldBitsLen; i++) {
        var nextInt = newBits[i];
        currentInt |= nextInt << 32 - leftOffset;
        newBits[i - 1] = currentInt;
        currentInt = nextInt >>> leftOffset;
      }
      newBits[oldBitsLen - 1] = currentInt;
    }
    this.bits = newBits;
  };
  BitArray2.makeArray = function(size) {
    return new Int32Array(Math.floor((size + 31) / 32));
  };
  BitArray2.prototype.equals = function(o) {
    if (!(o instanceof BitArray2)) {
      return false;
    }
    var other = o;
    return this.size === other.size && Arrays_default.equals(this.bits, other.bits);
  };
  BitArray2.prototype.hashCode = function() {
    return 31 * this.size + Arrays_default.hashCode(this.bits);
  };
  BitArray2.prototype.toString = function() {
    var result = "";
    for (var i = 0, size = this.size; i < size; i++) {
      if ((i & 7) === 0) {
        result += " ";
      }
      result += this.get(i) ? "X" : ".";
    }
    return result;
  };
  BitArray2.prototype.clone = function() {
    return new BitArray2(this.size, this.bits.slice());
  };
  return BitArray2;
}();
var BitArray_default = BitArray;

// node_modules/@zxing/library/esm/core/DecodeHintType.js
var DecodeHintType;
(function(DecodeHintType2) {
  DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
  DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
  DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
  DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
  DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
  DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
  DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
  DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 7] = "ASSUME_GS1";
  DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
  DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
  DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
})(DecodeHintType || (DecodeHintType = {}));
var DecodeHintType_default = DecodeHintType;

// node_modules/@zxing/library/esm/core/FormatException.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var FormatException = function(_super) {
  __extends8(FormatException2, _super);
  function FormatException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  FormatException2.getFormatInstance = function() {
    return new FormatException2();
  };
  FormatException2.kind = "FormatException";
  return FormatException2;
}(Exception_default);
var FormatException_default = FormatException;

// node_modules/@zxing/library/esm/core/common/CharacterSetECI.js
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var CharacterSetValueIdentifiers;
(function(CharacterSetValueIdentifiers2) {
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
  CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
})(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
var CharacterSetECI = function() {
  function CharacterSetECI2(valueIdentifier, valuesParam, name) {
    var e_1, _a;
    var otherEncodingNames = [];
    for (var _i = 3; _i < arguments.length; _i++) {
      otherEncodingNames[_i - 3] = arguments[_i];
    }
    this.valueIdentifier = valueIdentifier;
    this.name = name;
    if (typeof valuesParam === "number") {
      this.values = Int32Array.from([valuesParam]);
    } else {
      this.values = valuesParam;
    }
    this.otherEncodingNames = otherEncodingNames;
    CharacterSetECI2.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
    CharacterSetECI2.NAME_TO_ECI.set(name, this);
    var values = this.values;
    for (var i = 0, length_1 = values.length; i !== length_1; i++) {
      var v = values[i];
      CharacterSetECI2.VALUES_TO_ECI.set(v, this);
    }
    try {
      for (var otherEncodingNames_1 = __values2(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {
        var otherName = otherEncodingNames_1_1.value;
        CharacterSetECI2.NAME_TO_ECI.set(otherName, this);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return))
          _a.call(otherEncodingNames_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  CharacterSetECI2.prototype.getValueIdentifier = function() {
    return this.valueIdentifier;
  };
  CharacterSetECI2.prototype.getName = function() {
    return this.name;
  };
  CharacterSetECI2.prototype.getValue = function() {
    return this.values[0];
  };
  CharacterSetECI2.getCharacterSetECIByValue = function(value) {
    if (value < 0 || value >= 900) {
      throw new FormatException_default("incorect value");
    }
    var characterSet = CharacterSetECI2.VALUES_TO_ECI.get(value);
    if (characterSet === void 0) {
      throw new FormatException_default("incorect value");
    }
    return characterSet;
  };
  CharacterSetECI2.getCharacterSetECIByName = function(name) {
    var characterSet = CharacterSetECI2.NAME_TO_ECI.get(name);
    if (characterSet === void 0) {
      throw new FormatException_default("incorect value");
    }
    return characterSet;
  };
  CharacterSetECI2.prototype.equals = function(o) {
    if (!(o instanceof CharacterSetECI2)) {
      return false;
    }
    var other = o;
    return this.getName() === other.getName();
  };
  CharacterSetECI2.VALUE_IDENTIFIER_TO_ECI = new Map();
  CharacterSetECI2.VALUES_TO_ECI = new Map();
  CharacterSetECI2.NAME_TO_ECI = new Map();
  CharacterSetECI2.Cp437 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
  CharacterSetECI2.ISO8859_1 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
  CharacterSetECI2.ISO8859_2 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
  CharacterSetECI2.ISO8859_3 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
  CharacterSetECI2.ISO8859_4 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
  CharacterSetECI2.ISO8859_5 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
  CharacterSetECI2.ISO8859_6 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
  CharacterSetECI2.ISO8859_7 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
  CharacterSetECI2.ISO8859_8 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
  CharacterSetECI2.ISO8859_9 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
  CharacterSetECI2.ISO8859_10 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
  CharacterSetECI2.ISO8859_11 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
  CharacterSetECI2.ISO8859_13 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
  CharacterSetECI2.ISO8859_14 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
  CharacterSetECI2.ISO8859_15 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
  CharacterSetECI2.ISO8859_16 = new CharacterSetECI2(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
  CharacterSetECI2.SJIS = new CharacterSetECI2(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
  CharacterSetECI2.Cp1250 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
  CharacterSetECI2.Cp1251 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
  CharacterSetECI2.Cp1252 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
  CharacterSetECI2.Cp1256 = new CharacterSetECI2(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
  CharacterSetECI2.UnicodeBigUnmarked = new CharacterSetECI2(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
  CharacterSetECI2.UTF8 = new CharacterSetECI2(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
  CharacterSetECI2.ASCII = new CharacterSetECI2(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
  CharacterSetECI2.Big5 = new CharacterSetECI2(CharacterSetValueIdentifiers.Big5, 28, "Big5");
  CharacterSetECI2.GB18030 = new CharacterSetECI2(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
  CharacterSetECI2.EUC_KR = new CharacterSetECI2(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
  return CharacterSetECI2;
}();
var CharacterSetECI_default = CharacterSetECI;

// node_modules/@zxing/library/esm/core/UnsupportedOperationException.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var UnsupportedOperationException = function(_super) {
  __extends9(UnsupportedOperationException2, _super);
  function UnsupportedOperationException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  UnsupportedOperationException2.kind = "UnsupportedOperationException";
  return UnsupportedOperationException2;
}(Exception_default);
var UnsupportedOperationException_default = UnsupportedOperationException;

// node_modules/@zxing/library/esm/core/util/StringEncoding.js
var StringEncoding = function() {
  function StringEncoding2() {
  }
  StringEncoding2.decode = function(bytes, encoding2) {
    var encodingName = this.encodingName(encoding2);
    if (this.customDecoder) {
      return this.customDecoder(bytes, encodingName);
    }
    if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
      return this.decodeFallback(bytes, encodingName);
    }
    return new TextDecoder(encodingName).decode(bytes);
  };
  StringEncoding2.shouldDecodeOnFallback = function(encodingName) {
    return !StringEncoding2.isBrowser() && encodingName === "ISO-8859-1";
  };
  StringEncoding2.encode = function(s, encoding2) {
    var encodingName = this.encodingName(encoding2);
    if (this.customEncoder) {
      return this.customEncoder(s, encodingName);
    }
    if (typeof TextEncoder === "undefined") {
      return this.encodeFallback(s);
    }
    return new TextEncoder().encode(s);
  };
  StringEncoding2.isBrowser = function() {
    return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
  };
  StringEncoding2.encodingName = function(encoding2) {
    return typeof encoding2 === "string" ? encoding2 : encoding2.getName();
  };
  StringEncoding2.encodingCharacterSet = function(encoding2) {
    if (encoding2 instanceof CharacterSetECI_default) {
      return encoding2;
    }
    return CharacterSetECI_default.getCharacterSetECIByName(encoding2);
  };
  StringEncoding2.decodeFallback = function(bytes, encoding2) {
    var characterSet = this.encodingCharacterSet(encoding2);
    if (StringEncoding2.isDecodeFallbackSupported(characterSet)) {
      var s = "";
      for (var i = 0, length_1 = bytes.length; i < length_1; i++) {
        var h = bytes[i].toString(16);
        if (h.length < 2) {
          h = "0" + h;
        }
        s += "%" + h;
      }
      return decodeURIComponent(s);
    }
    if (characterSet.equals(CharacterSetECI_default.UnicodeBigUnmarked)) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    }
    throw new UnsupportedOperationException_default("Encoding " + this.encodingName(encoding2) + " not supported by fallback.");
  };
  StringEncoding2.isDecodeFallbackSupported = function(characterSet) {
    return characterSet.equals(CharacterSetECI_default.UTF8) || characterSet.equals(CharacterSetECI_default.ISO8859_1) || characterSet.equals(CharacterSetECI_default.ASCII);
  };
  StringEncoding2.encodeFallback = function(s) {
    var encodedURIstring = btoa(unescape(encodeURIComponent(s)));
    var charList = encodedURIstring.split("");
    var uintArray = [];
    for (var i = 0; i < charList.length; i++) {
      uintArray.push(charList[i].charCodeAt(0));
    }
    return new Uint8Array(uintArray);
  };
  return StringEncoding2;
}();
var StringEncoding_default = StringEncoding;

// node_modules/@zxing/library/esm/core/common/StringUtils.js
var StringUtils = function() {
  function StringUtils2() {
  }
  StringUtils2.castAsNonUtf8Char = function(code, encoding2) {
    if (encoding2 === void 0) {
      encoding2 = null;
    }
    var e = encoding2 ? encoding2.getName() : this.ISO88591;
    return StringEncoding_default.decode(new Uint8Array([code]), e);
  };
  StringUtils2.guessEncoding = function(bytes, hints) {
    if (hints !== null && hints !== void 0 && hints.get(DecodeHintType_default.CHARACTER_SET) !== void 0) {
      return hints.get(DecodeHintType_default.CHARACTER_SET).toString();
    }
    var length = bytes.length;
    var canBeISO88591 = true;
    var canBeShiftJIS = true;
    var canBeUTF8 = true;
    var utf8BytesLeft = 0;
    var utf2BytesChars = 0;
    var utf3BytesChars = 0;
    var utf4BytesChars = 0;
    var sjisBytesLeft = 0;
    var sjisKatakanaChars = 0;
    var sjisCurKatakanaWordLength = 0;
    var sjisCurDoubleBytesWordLength = 0;
    var sjisMaxKatakanaWordLength = 0;
    var sjisMaxDoubleBytesWordLength = 0;
    var isoHighOther = 0;
    var utf8bom = bytes.length > 3 && bytes[0] === 239 && bytes[1] === 187 && bytes[2] === 191;
    for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
      var value = bytes[i] & 255;
      if (canBeUTF8) {
        if (utf8BytesLeft > 0) {
          if ((value & 128) === 0) {
            canBeUTF8 = false;
          } else {
            utf8BytesLeft--;
          }
        } else if ((value & 128) !== 0) {
          if ((value & 64) === 0) {
            canBeUTF8 = false;
          } else {
            utf8BytesLeft++;
            if ((value & 32) === 0) {
              utf2BytesChars++;
            } else {
              utf8BytesLeft++;
              if ((value & 16) === 0) {
                utf3BytesChars++;
              } else {
                utf8BytesLeft++;
                if ((value & 8) === 0) {
                  utf4BytesChars++;
                } else {
                  canBeUTF8 = false;
                }
              }
            }
          }
        }
      }
      if (canBeISO88591) {
        if (value > 127 && value < 160) {
          canBeISO88591 = false;
        } else if (value > 159) {
          if (value < 192 || value === 215 || value === 247) {
            isoHighOther++;
          }
        }
      }
      if (canBeShiftJIS) {
        if (sjisBytesLeft > 0) {
          if (value < 64 || value === 127 || value > 252) {
            canBeShiftJIS = false;
          } else {
            sjisBytesLeft--;
          }
        } else if (value === 128 || value === 160 || value > 239) {
          canBeShiftJIS = false;
        } else if (value > 160 && value < 224) {
          sjisKatakanaChars++;
          sjisCurDoubleBytesWordLength = 0;
          sjisCurKatakanaWordLength++;
          if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
            sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
          }
        } else if (value > 127) {
          sjisBytesLeft++;
          sjisCurKatakanaWordLength = 0;
          sjisCurDoubleBytesWordLength++;
          if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
            sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
          }
        } else {
          sjisCurKatakanaWordLength = 0;
          sjisCurDoubleBytesWordLength = 0;
        }
      }
    }
    if (canBeUTF8 && utf8BytesLeft > 0) {
      canBeUTF8 = false;
    }
    if (canBeShiftJIS && sjisBytesLeft > 0) {
      canBeShiftJIS = false;
    }
    if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
      return StringUtils2.UTF8;
    }
    if (canBeShiftJIS && (StringUtils2.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
      return StringUtils2.SHIFT_JIS;
    }
    if (canBeISO88591 && canBeShiftJIS) {
      return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils2.SHIFT_JIS : StringUtils2.ISO88591;
    }
    if (canBeISO88591) {
      return StringUtils2.ISO88591;
    }
    if (canBeShiftJIS) {
      return StringUtils2.SHIFT_JIS;
    }
    if (canBeUTF8) {
      return StringUtils2.UTF8;
    }
    return StringUtils2.PLATFORM_DEFAULT_ENCODING;
  };
  StringUtils2.format = function(append) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var i = -1;
    function callback(exp, p0, p1, p2, p3, p4) {
      if (exp === "%%")
        return "%";
      if (args[++i] === void 0)
        return void 0;
      exp = p2 ? parseInt(p2.substr(1)) : void 0;
      var base = p3 ? parseInt(p3.substr(1)) : void 0;
      var val;
      switch (p4) {
        case "s":
          val = args[i];
          break;
        case "c":
          val = args[i][0];
          break;
        case "f":
          val = parseFloat(args[i]).toFixed(exp);
          break;
        case "p":
          val = parseFloat(args[i]).toPrecision(exp);
          break;
        case "e":
          val = parseFloat(args[i]).toExponential(exp);
          break;
        case "x":
          val = parseInt(args[i]).toString(base ? base : 16);
          break;
        case "d":
          val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);
          break;
      }
      val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
      var size = parseInt(p1);
      var ch = p1 && p1[0] + "" === "0" ? "0" : " ";
      while (val.length < size)
        val = p0 !== void 0 ? val + ch : ch + val;
      return val;
    }
    var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
    return append.replace(regex, callback);
  };
  StringUtils2.getBytes = function(str, encoding2) {
    return StringEncoding_default.encode(str, encoding2);
  };
  StringUtils2.getCharCode = function(str, index) {
    if (index === void 0) {
      index = 0;
    }
    return str.charCodeAt(index);
  };
  StringUtils2.getCharAt = function(charCode) {
    return String.fromCharCode(charCode);
  };
  StringUtils2.SHIFT_JIS = CharacterSetECI_default.SJIS.getName();
  StringUtils2.GB2312 = "GB2312";
  StringUtils2.ISO88591 = CharacterSetECI_default.ISO8859_1.getName();
  StringUtils2.EUC_JP = "EUC_JP";
  StringUtils2.UTF8 = CharacterSetECI_default.UTF8.getName();
  StringUtils2.PLATFORM_DEFAULT_ENCODING = StringUtils2.UTF8;
  StringUtils2.ASSUME_SHIFT_JIS = false;
  return StringUtils2;
}();
var StringUtils_default = StringUtils;

// node_modules/@zxing/library/esm/core/util/StringBuilder.js
var StringBuilder = function() {
  function StringBuilder2(value) {
    if (value === void 0) {
      value = "";
    }
    this.value = value;
  }
  StringBuilder2.prototype.enableDecoding = function(encoding2) {
    this.encoding = encoding2;
    return this;
  };
  StringBuilder2.prototype.append = function(s) {
    if (typeof s === "string") {
      this.value += s.toString();
    } else if (this.encoding) {
      this.value += StringUtils_default.castAsNonUtf8Char(s, this.encoding);
    } else {
      this.value += String.fromCharCode(s);
    }
    return this;
  };
  StringBuilder2.prototype.appendChars = function(str, offset, len) {
    for (var i = offset; offset < offset + len; i++) {
      this.append(str[i]);
    }
    return this;
  };
  StringBuilder2.prototype.length = function() {
    return this.value.length;
  };
  StringBuilder2.prototype.charAt = function(n) {
    return this.value.charAt(n);
  };
  StringBuilder2.prototype.deleteCharAt = function(n) {
    this.value = this.value.substr(0, n) + this.value.substring(n + 1);
  };
  StringBuilder2.prototype.setCharAt = function(n, c) {
    this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
  };
  StringBuilder2.prototype.substring = function(start, end) {
    return this.value.substring(start, end);
  };
  StringBuilder2.prototype.setLengthToZero = function() {
    this.value = "";
  };
  StringBuilder2.prototype.toString = function() {
    return this.value;
  };
  StringBuilder2.prototype.insert = function(n, c) {
    this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
  };
  return StringBuilder2;
}();
var StringBuilder_default = StringBuilder;

// node_modules/@zxing/library/esm/core/common/BitMatrix.js
var BitMatrix = function() {
  function BitMatrix2(width, height, rowSize, bits) {
    this.width = width;
    this.height = height;
    this.rowSize = rowSize;
    this.bits = bits;
    if (height === void 0 || height === null) {
      height = width;
    }
    this.height = height;
    if (width < 1 || height < 1) {
      throw new IllegalArgumentException_default("Both dimensions must be greater than 0");
    }
    if (rowSize === void 0 || rowSize === null) {
      rowSize = Math.floor((width + 31) / 32);
    }
    this.rowSize = rowSize;
    if (bits === void 0 || bits === null) {
      this.bits = new Int32Array(this.rowSize * this.height);
    }
  }
  BitMatrix2.parseFromBooleanArray = function(image) {
    var height = image.length;
    var width = image[0].length;
    var bits = new BitMatrix2(width, height);
    for (var i = 0; i < height; i++) {
      var imageI = image[i];
      for (var j = 0; j < width; j++) {
        if (imageI[j]) {
          bits.set(j, i);
        }
      }
    }
    return bits;
  };
  BitMatrix2.parseFromString = function(stringRepresentation, setString, unsetString) {
    if (stringRepresentation === null) {
      throw new IllegalArgumentException_default("stringRepresentation cannot be null");
    }
    var bits = new Array(stringRepresentation.length);
    var bitsPos = 0;
    var rowStartPos = 0;
    var rowLength = -1;
    var nRows = 0;
    var pos = 0;
    while (pos < stringRepresentation.length) {
      if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
        if (bitsPos > rowStartPos) {
          if (rowLength === -1) {
            rowLength = bitsPos - rowStartPos;
          } else if (bitsPos - rowStartPos !== rowLength) {
            throw new IllegalArgumentException_default("row lengths do not match");
          }
          rowStartPos = bitsPos;
          nRows++;
        }
        pos++;
      } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
        pos += setString.length;
        bits[bitsPos] = true;
        bitsPos++;
      } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
        pos += unsetString.length;
        bits[bitsPos] = false;
        bitsPos++;
      } else {
        throw new IllegalArgumentException_default("illegal character encountered: " + stringRepresentation.substring(pos));
      }
    }
    if (bitsPos > rowStartPos) {
      if (rowLength === -1) {
        rowLength = bitsPos - rowStartPos;
      } else if (bitsPos - rowStartPos !== rowLength) {
        throw new IllegalArgumentException_default("row lengths do not match");
      }
      nRows++;
    }
    var matrix = new BitMatrix2(rowLength, nRows);
    for (var i = 0; i < bitsPos; i++) {
      if (bits[i]) {
        matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
      }
    }
    return matrix;
  };
  BitMatrix2.prototype.get = function(x2, y) {
    var offset = y * this.rowSize + Math.floor(x2 / 32);
    return (this.bits[offset] >>> (x2 & 31) & 1) !== 0;
  };
  BitMatrix2.prototype.set = function(x2, y) {
    var offset = y * this.rowSize + Math.floor(x2 / 32);
    this.bits[offset] |= 1 << (x2 & 31) & 4294967295;
  };
  BitMatrix2.prototype.unset = function(x2, y) {
    var offset = y * this.rowSize + Math.floor(x2 / 32);
    this.bits[offset] &= ~(1 << (x2 & 31) & 4294967295);
  };
  BitMatrix2.prototype.flip = function(x2, y) {
    var offset = y * this.rowSize + Math.floor(x2 / 32);
    this.bits[offset] ^= 1 << (x2 & 31) & 4294967295;
  };
  BitMatrix2.prototype.xor = function(mask) {
    if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
      throw new IllegalArgumentException_default("input matrix dimensions do not match");
    }
    var rowArray = new BitArray_default(Math.floor(this.width / 32) + 1);
    var rowSize = this.rowSize;
    var bits = this.bits;
    for (var y = 0, height = this.height; y < height; y++) {
      var offset = y * rowSize;
      var row = mask.getRow(y, rowArray).getBitArray();
      for (var x2 = 0; x2 < rowSize; x2++) {
        bits[offset + x2] ^= row[x2];
      }
    }
  };
  BitMatrix2.prototype.clear = function() {
    var bits = this.bits;
    var max = bits.length;
    for (var i = 0; i < max; i++) {
      bits[i] = 0;
    }
  };
  BitMatrix2.prototype.setRegion = function(left, top, width, height) {
    if (top < 0 || left < 0) {
      throw new IllegalArgumentException_default("Left and top must be nonnegative");
    }
    if (height < 1 || width < 1) {
      throw new IllegalArgumentException_default("Height and width must be at least 1");
    }
    var right = left + width;
    var bottom = top + height;
    if (bottom > this.height || right > this.width) {
      throw new IllegalArgumentException_default("The region must fit inside the matrix");
    }
    var rowSize = this.rowSize;
    var bits = this.bits;
    for (var y = top; y < bottom; y++) {
      var offset = y * rowSize;
      for (var x2 = left; x2 < right; x2++) {
        bits[offset + Math.floor(x2 / 32)] |= 1 << (x2 & 31) & 4294967295;
      }
    }
  };
  BitMatrix2.prototype.getRow = function(y, row) {
    if (row === null || row === void 0 || row.getSize() < this.width) {
      row = new BitArray_default(this.width);
    } else {
      row.clear();
    }
    var rowSize = this.rowSize;
    var bits = this.bits;
    var offset = y * rowSize;
    for (var x2 = 0; x2 < rowSize; x2++) {
      row.setBulk(x2 * 32, bits[offset + x2]);
    }
    return row;
  };
  BitMatrix2.prototype.setRow = function(y, row) {
    System_default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
  };
  BitMatrix2.prototype.rotate180 = function() {
    var width = this.getWidth();
    var height = this.getHeight();
    var topRow = new BitArray_default(width);
    var bottomRow = new BitArray_default(width);
    for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {
      topRow = this.getRow(i, topRow);
      bottomRow = this.getRow(height - 1 - i, bottomRow);
      topRow.reverse();
      bottomRow.reverse();
      this.setRow(i, bottomRow);
      this.setRow(height - 1 - i, topRow);
    }
  };
  BitMatrix2.prototype.getEnclosingRectangle = function() {
    var width = this.width;
    var height = this.height;
    var rowSize = this.rowSize;
    var bits = this.bits;
    var left = width;
    var top = height;
    var right = -1;
    var bottom = -1;
    for (var y = 0; y < height; y++) {
      for (var x32 = 0; x32 < rowSize; x32++) {
        var theBits = bits[y * rowSize + x32];
        if (theBits !== 0) {
          if (y < top) {
            top = y;
          }
          if (y > bottom) {
            bottom = y;
          }
          if (x32 * 32 < left) {
            var bit = 0;
            while ((theBits << 31 - bit & 4294967295) === 0) {
              bit++;
            }
            if (x32 * 32 + bit < left) {
              left = x32 * 32 + bit;
            }
          }
          if (x32 * 32 + 31 > right) {
            var bit = 31;
            while (theBits >>> bit === 0) {
              bit--;
            }
            if (x32 * 32 + bit > right) {
              right = x32 * 32 + bit;
            }
          }
        }
      }
    }
    if (right < left || bottom < top) {
      return null;
    }
    return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
  };
  BitMatrix2.prototype.getTopLeftOnBit = function() {
    var rowSize = this.rowSize;
    var bits = this.bits;
    var bitsOffset = 0;
    while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
      bitsOffset++;
    }
    if (bitsOffset === bits.length) {
      return null;
    }
    var y = bitsOffset / rowSize;
    var x2 = bitsOffset % rowSize * 32;
    var theBits = bits[bitsOffset];
    var bit = 0;
    while ((theBits << 31 - bit & 4294967295) === 0) {
      bit++;
    }
    x2 += bit;
    return Int32Array.from([x2, y]);
  };
  BitMatrix2.prototype.getBottomRightOnBit = function() {
    var rowSize = this.rowSize;
    var bits = this.bits;
    var bitsOffset = bits.length - 1;
    while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
      bitsOffset--;
    }
    if (bitsOffset < 0) {
      return null;
    }
    var y = Math.floor(bitsOffset / rowSize);
    var x2 = Math.floor(bitsOffset % rowSize) * 32;
    var theBits = bits[bitsOffset];
    var bit = 31;
    while (theBits >>> bit === 0) {
      bit--;
    }
    x2 += bit;
    return Int32Array.from([x2, y]);
  };
  BitMatrix2.prototype.getWidth = function() {
    return this.width;
  };
  BitMatrix2.prototype.getHeight = function() {
    return this.height;
  };
  BitMatrix2.prototype.getRowSize = function() {
    return this.rowSize;
  };
  BitMatrix2.prototype.equals = function(o) {
    if (!(o instanceof BitMatrix2)) {
      return false;
    }
    var other = o;
    return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays_default.equals(this.bits, other.bits);
  };
  BitMatrix2.prototype.hashCode = function() {
    var hash = this.width;
    hash = 31 * hash + this.width;
    hash = 31 * hash + this.height;
    hash = 31 * hash + this.rowSize;
    hash = 31 * hash + Arrays_default.hashCode(this.bits);
    return hash;
  };
  BitMatrix2.prototype.toString = function(setString, unsetString, lineSeparator) {
    if (setString === void 0) {
      setString = "X ";
    }
    if (unsetString === void 0) {
      unsetString = "  ";
    }
    if (lineSeparator === void 0) {
      lineSeparator = "\n";
    }
    return this.buildToString(setString, unsetString, lineSeparator);
  };
  BitMatrix2.prototype.buildToString = function(setString, unsetString, lineSeparator) {
    var result = new StringBuilder_default();
    for (var y = 0, height = this.height; y < height; y++) {
      for (var x2 = 0, width = this.width; x2 < width; x2++) {
        result.append(this.get(x2, y) ? setString : unsetString);
      }
      result.append(lineSeparator);
    }
    return result.toString();
  };
  BitMatrix2.prototype.clone = function() {
    return new BitMatrix2(this.width, this.height, this.rowSize, this.bits.slice());
  };
  return BitMatrix2;
}();
var BitMatrix_default = BitMatrix;

// node_modules/@zxing/library/esm/core/NotFoundException.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NotFoundException = function(_super) {
  __extends10(NotFoundException2, _super);
  function NotFoundException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  NotFoundException2.getNotFoundInstance = function() {
    return new NotFoundException2();
  };
  NotFoundException2.kind = "NotFoundException";
  return NotFoundException2;
}(Exception_default);
var NotFoundException_default = NotFoundException;

// node_modules/@zxing/library/esm/core/common/GlobalHistogramBinarizer.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GlobalHistogramBinarizer = function(_super) {
  __extends11(GlobalHistogramBinarizer2, _super);
  function GlobalHistogramBinarizer2(source) {
    var _this = _super.call(this, source) || this;
    _this.luminances = GlobalHistogramBinarizer2.EMPTY;
    _this.buckets = new Int32Array(GlobalHistogramBinarizer2.LUMINANCE_BUCKETS);
    return _this;
  }
  GlobalHistogramBinarizer2.prototype.getBlackRow = function(y, row) {
    var source = this.getLuminanceSource();
    var width = source.getWidth();
    if (row === void 0 || row === null || row.getSize() < width) {
      row = new BitArray_default(width);
    } else {
      row.clear();
    }
    this.initArrays(width);
    var localLuminances = source.getRow(y, this.luminances);
    var localBuckets = this.buckets;
    for (var x2 = 0; x2 < width; x2++) {
      localBuckets[(localLuminances[x2] & 255) >> GlobalHistogramBinarizer2.LUMINANCE_SHIFT]++;
    }
    var blackPoint = GlobalHistogramBinarizer2.estimateBlackPoint(localBuckets);
    if (width < 3) {
      for (var x2 = 0; x2 < width; x2++) {
        if ((localLuminances[x2] & 255) < blackPoint) {
          row.set(x2);
        }
      }
    } else {
      var left = localLuminances[0] & 255;
      var center = localLuminances[1] & 255;
      for (var x2 = 1; x2 < width - 1; x2++) {
        var right = localLuminances[x2 + 1] & 255;
        if ((center * 4 - left - right) / 2 < blackPoint) {
          row.set(x2);
        }
        left = center;
        center = right;
      }
    }
    return row;
  };
  GlobalHistogramBinarizer2.prototype.getBlackMatrix = function() {
    var source = this.getLuminanceSource();
    var width = source.getWidth();
    var height = source.getHeight();
    var matrix = new BitMatrix_default(width, height);
    this.initArrays(width);
    var localBuckets = this.buckets;
    for (var y = 1; y < 5; y++) {
      var row = Math.floor(height * y / 5);
      var localLuminances_1 = source.getRow(row, this.luminances);
      var right = Math.floor(width * 4 / 5);
      for (var x2 = Math.floor(width / 5); x2 < right; x2++) {
        var pixel = localLuminances_1[x2] & 255;
        localBuckets[pixel >> GlobalHistogramBinarizer2.LUMINANCE_SHIFT]++;
      }
    }
    var blackPoint = GlobalHistogramBinarizer2.estimateBlackPoint(localBuckets);
    var localLuminances = source.getMatrix();
    for (var y = 0; y < height; y++) {
      var offset = y * width;
      for (var x2 = 0; x2 < width; x2++) {
        var pixel = localLuminances[offset + x2] & 255;
        if (pixel < blackPoint) {
          matrix.set(x2, y);
        }
      }
    }
    return matrix;
  };
  GlobalHistogramBinarizer2.prototype.createBinarizer = function(source) {
    return new GlobalHistogramBinarizer2(source);
  };
  GlobalHistogramBinarizer2.prototype.initArrays = function(luminanceSize) {
    if (this.luminances.length < luminanceSize) {
      this.luminances = new Uint8ClampedArray(luminanceSize);
    }
    var buckets = this.buckets;
    for (var x2 = 0; x2 < GlobalHistogramBinarizer2.LUMINANCE_BUCKETS; x2++) {
      buckets[x2] = 0;
    }
  };
  GlobalHistogramBinarizer2.estimateBlackPoint = function(buckets) {
    var numBuckets = buckets.length;
    var maxBucketCount = 0;
    var firstPeak = 0;
    var firstPeakSize = 0;
    for (var x2 = 0; x2 < numBuckets; x2++) {
      if (buckets[x2] > firstPeakSize) {
        firstPeak = x2;
        firstPeakSize = buckets[x2];
      }
      if (buckets[x2] > maxBucketCount) {
        maxBucketCount = buckets[x2];
      }
    }
    var secondPeak = 0;
    var secondPeakScore = 0;
    for (var x2 = 0; x2 < numBuckets; x2++) {
      var distanceToBiggest = x2 - firstPeak;
      var score = buckets[x2] * distanceToBiggest * distanceToBiggest;
      if (score > secondPeakScore) {
        secondPeak = x2;
        secondPeakScore = score;
      }
    }
    if (firstPeak > secondPeak) {
      var temp = firstPeak;
      firstPeak = secondPeak;
      secondPeak = temp;
    }
    if (secondPeak - firstPeak <= numBuckets / 16) {
      throw new NotFoundException_default();
    }
    var bestValley = secondPeak - 1;
    var bestValleyScore = -1;
    for (var x2 = secondPeak - 1; x2 > firstPeak; x2--) {
      var fromFirst = x2 - firstPeak;
      var score = fromFirst * fromFirst * (secondPeak - x2) * (maxBucketCount - buckets[x2]);
      if (score > bestValleyScore) {
        bestValley = x2;
        bestValleyScore = score;
      }
    }
    return bestValley << GlobalHistogramBinarizer2.LUMINANCE_SHIFT;
  };
  GlobalHistogramBinarizer2.LUMINANCE_BITS = 5;
  GlobalHistogramBinarizer2.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer2.LUMINANCE_BITS;
  GlobalHistogramBinarizer2.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer2.LUMINANCE_BITS;
  GlobalHistogramBinarizer2.EMPTY = Uint8ClampedArray.from([0]);
  return GlobalHistogramBinarizer2;
}(Binarizer_default);
var GlobalHistogramBinarizer_default = GlobalHistogramBinarizer;

// node_modules/@zxing/library/esm/core/common/HybridBinarizer.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HybridBinarizer = function(_super) {
  __extends12(HybridBinarizer2, _super);
  function HybridBinarizer2(source) {
    var _this = _super.call(this, source) || this;
    _this.matrix = null;
    return _this;
  }
  HybridBinarizer2.prototype.getBlackMatrix = function() {
    if (this.matrix !== null) {
      return this.matrix;
    }
    var source = this.getLuminanceSource();
    var width = source.getWidth();
    var height = source.getHeight();
    if (width >= HybridBinarizer2.MINIMUM_DIMENSION && height >= HybridBinarizer2.MINIMUM_DIMENSION) {
      var luminances = source.getMatrix();
      var subWidth = width >> HybridBinarizer2.BLOCK_SIZE_POWER;
      if ((width & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
        subWidth++;
      }
      var subHeight = height >> HybridBinarizer2.BLOCK_SIZE_POWER;
      if ((height & HybridBinarizer2.BLOCK_SIZE_MASK) !== 0) {
        subHeight++;
      }
      var blackPoints = HybridBinarizer2.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
      var newMatrix = new BitMatrix_default(width, height);
      HybridBinarizer2.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
      this.matrix = newMatrix;
    } else {
      this.matrix = _super.prototype.getBlackMatrix.call(this);
    }
    return this.matrix;
  };
  HybridBinarizer2.prototype.createBinarizer = function(source) {
    return new HybridBinarizer2(source);
  };
  HybridBinarizer2.calculateThresholdForBlock = function(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
    var maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
    var maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
    for (var y = 0; y < subHeight; y++) {
      var yoffset = y << HybridBinarizer2.BLOCK_SIZE_POWER;
      if (yoffset > maxYOffset) {
        yoffset = maxYOffset;
      }
      var top_1 = HybridBinarizer2.cap(y, 2, subHeight - 3);
      for (var x2 = 0; x2 < subWidth; x2++) {
        var xoffset = x2 << HybridBinarizer2.BLOCK_SIZE_POWER;
        if (xoffset > maxXOffset) {
          xoffset = maxXOffset;
        }
        var left = HybridBinarizer2.cap(x2, 2, subWidth - 3);
        var sum = 0;
        for (var z = -2; z <= 2; z++) {
          var blackRow = blackPoints[top_1 + z];
          sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
        }
        var average = sum / 25;
        HybridBinarizer2.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
      }
    }
  };
  HybridBinarizer2.cap = function(value, min, max) {
    return value < min ? min : value > max ? max : value;
  };
  HybridBinarizer2.thresholdBlock = function(luminances, xoffset, yoffset, threshold, stride, matrix) {
    for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer2.BLOCK_SIZE; y++, offset += stride) {
      for (var x2 = 0; x2 < HybridBinarizer2.BLOCK_SIZE; x2++) {
        if ((luminances[offset + x2] & 255) <= threshold) {
          matrix.set(xoffset + x2, yoffset + y);
        }
      }
    }
  };
  HybridBinarizer2.calculateBlackPoints = function(luminances, subWidth, subHeight, width, height) {
    var maxYOffset = height - HybridBinarizer2.BLOCK_SIZE;
    var maxXOffset = width - HybridBinarizer2.BLOCK_SIZE;
    var blackPoints = new Array(subHeight);
    for (var y = 0; y < subHeight; y++) {
      blackPoints[y] = new Int32Array(subWidth);
      var yoffset = y << HybridBinarizer2.BLOCK_SIZE_POWER;
      if (yoffset > maxYOffset) {
        yoffset = maxYOffset;
      }
      for (var x2 = 0; x2 < subWidth; x2++) {
        var xoffset = x2 << HybridBinarizer2.BLOCK_SIZE_POWER;
        if (xoffset > maxXOffset) {
          xoffset = maxXOffset;
        }
        var sum = 0;
        var min = 255;
        var max = 0;
        for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset += width) {
          for (var xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
            var pixel = luminances[offset + xx] & 255;
            sum += pixel;
            if (pixel < min) {
              min = pixel;
            }
            if (pixel > max) {
              max = pixel;
            }
          }
          if (max - min > HybridBinarizer2.MIN_DYNAMIC_RANGE) {
            for (yy++, offset += width; yy < HybridBinarizer2.BLOCK_SIZE; yy++, offset += width) {
              for (var xx = 0; xx < HybridBinarizer2.BLOCK_SIZE; xx++) {
                sum += luminances[offset + xx] & 255;
              }
            }
          }
        }
        var average = sum >> HybridBinarizer2.BLOCK_SIZE_POWER * 2;
        if (max - min <= HybridBinarizer2.MIN_DYNAMIC_RANGE) {
          average = min / 2;
          if (y > 0 && x2 > 0) {
            var averageNeighborBlackPoint = (blackPoints[y - 1][x2] + 2 * blackPoints[y][x2 - 1] + blackPoints[y - 1][x2 - 1]) / 4;
            if (min < averageNeighborBlackPoint) {
              average = averageNeighborBlackPoint;
            }
          }
        }
        blackPoints[y][x2] = average;
      }
    }
    return blackPoints;
  };
  HybridBinarizer2.BLOCK_SIZE_POWER = 3;
  HybridBinarizer2.BLOCK_SIZE = 1 << HybridBinarizer2.BLOCK_SIZE_POWER;
  HybridBinarizer2.BLOCK_SIZE_MASK = HybridBinarizer2.BLOCK_SIZE - 1;
  HybridBinarizer2.MINIMUM_DIMENSION = HybridBinarizer2.BLOCK_SIZE * 5;
  HybridBinarizer2.MIN_DYNAMIC_RANGE = 24;
  return HybridBinarizer2;
}(GlobalHistogramBinarizer_default);
var HybridBinarizer_default = HybridBinarizer;

// node_modules/@zxing/library/esm/core/LuminanceSource.js
var LuminanceSource = function() {
  function LuminanceSource2(width, height) {
    this.width = width;
    this.height = height;
  }
  LuminanceSource2.prototype.getWidth = function() {
    return this.width;
  };
  LuminanceSource2.prototype.getHeight = function() {
    return this.height;
  };
  LuminanceSource2.prototype.isCropSupported = function() {
    return false;
  };
  LuminanceSource2.prototype.crop = function(left, top, width, height) {
    throw new UnsupportedOperationException_default("This luminance source does not support cropping.");
  };
  LuminanceSource2.prototype.isRotateSupported = function() {
    return false;
  };
  LuminanceSource2.prototype.rotateCounterClockwise = function() {
    throw new UnsupportedOperationException_default("This luminance source does not support rotation by 90 degrees.");
  };
  LuminanceSource2.prototype.rotateCounterClockwise45 = function() {
    throw new UnsupportedOperationException_default("This luminance source does not support rotation by 45 degrees.");
  };
  LuminanceSource2.prototype.toString = function() {
    var row = new Uint8ClampedArray(this.width);
    var result = new StringBuilder_default();
    for (var y = 0; y < this.height; y++) {
      var sourceRow = this.getRow(y, row);
      for (var x2 = 0; x2 < this.width; x2++) {
        var luminance = sourceRow[x2] & 255;
        var c = void 0;
        if (luminance < 64) {
          c = "#";
        } else if (luminance < 128) {
          c = "+";
        } else if (luminance < 192) {
          c = ".";
        } else {
          c = " ";
        }
        result.append(c);
      }
      result.append("\n");
    }
    return result.toString();
  };
  return LuminanceSource2;
}();
var LuminanceSource_default = LuminanceSource;

// node_modules/@zxing/library/esm/core/InvertedLuminanceSource.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var InvertedLuminanceSource = function(_super) {
  __extends13(InvertedLuminanceSource2, _super);
  function InvertedLuminanceSource2(delegate) {
    var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;
    _this.delegate = delegate;
    return _this;
  }
  InvertedLuminanceSource2.prototype.getRow = function(y, row) {
    var sourceRow = this.delegate.getRow(y, row);
    var width = this.getWidth();
    for (var i = 0; i < width; i++) {
      sourceRow[i] = 255 - (sourceRow[i] & 255);
    }
    return sourceRow;
  };
  InvertedLuminanceSource2.prototype.getMatrix = function() {
    var matrix = this.delegate.getMatrix();
    var length = this.getWidth() * this.getHeight();
    var invertedMatrix = new Uint8ClampedArray(length);
    for (var i = 0; i < length; i++) {
      invertedMatrix[i] = 255 - (matrix[i] & 255);
    }
    return invertedMatrix;
  };
  InvertedLuminanceSource2.prototype.isCropSupported = function() {
    return this.delegate.isCropSupported();
  };
  InvertedLuminanceSource2.prototype.crop = function(left, top, width, height) {
    return new InvertedLuminanceSource2(this.delegate.crop(left, top, width, height));
  };
  InvertedLuminanceSource2.prototype.isRotateSupported = function() {
    return this.delegate.isRotateSupported();
  };
  InvertedLuminanceSource2.prototype.invert = function() {
    return this.delegate;
  };
  InvertedLuminanceSource2.prototype.rotateCounterClockwise = function() {
    return new InvertedLuminanceSource2(this.delegate.rotateCounterClockwise());
  };
  InvertedLuminanceSource2.prototype.rotateCounterClockwise45 = function() {
    return new InvertedLuminanceSource2(this.delegate.rotateCounterClockwise45());
  };
  return InvertedLuminanceSource2;
}(LuminanceSource_default);
var InvertedLuminanceSource_default = InvertedLuminanceSource;

// node_modules/@zxing/library/esm/browser/HTMLCanvasElementLuminanceSource.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HTMLCanvasElementLuminanceSource = function(_super) {
  __extends14(HTMLCanvasElementLuminanceSource2, _super);
  function HTMLCanvasElementLuminanceSource2(canvas) {
    var _this = _super.call(this, canvas.width, canvas.height) || this;
    _this.canvas = canvas;
    _this.tempCanvasElement = null;
    _this.buffer = HTMLCanvasElementLuminanceSource2.makeBufferFromCanvasImageData(canvas);
    return _this;
  }
  HTMLCanvasElementLuminanceSource2.makeBufferFromCanvasImageData = function(canvas) {
    var imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
    return HTMLCanvasElementLuminanceSource2.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
  };
  HTMLCanvasElementLuminanceSource2.toGrayscaleBuffer = function(imageBuffer, width, height) {
    var grayscaleBuffer = new Uint8ClampedArray(width * height);
    for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
      var gray = void 0;
      var alpha = imageBuffer[i + 3];
      if (alpha === 0) {
        gray = 255;
      } else {
        var pixelR = imageBuffer[i];
        var pixelG = imageBuffer[i + 1];
        var pixelB = imageBuffer[i + 2];
        gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
      }
      grayscaleBuffer[j] = gray;
    }
    return grayscaleBuffer;
  };
  HTMLCanvasElementLuminanceSource2.prototype.getRow = function(y, row) {
    if (y < 0 || y >= this.getHeight()) {
      throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
    }
    var width = this.getWidth();
    var start = y * width;
    if (row === null) {
      row = this.buffer.slice(start, start + width);
    } else {
      if (row.length < width) {
        row = new Uint8ClampedArray(width);
      }
      row.set(this.buffer.slice(start, start + width));
    }
    return row;
  };
  HTMLCanvasElementLuminanceSource2.prototype.getMatrix = function() {
    return this.buffer;
  };
  HTMLCanvasElementLuminanceSource2.prototype.isCropSupported = function() {
    return true;
  };
  HTMLCanvasElementLuminanceSource2.prototype.crop = function(left, top, width, height) {
    _super.prototype.crop.call(this, left, top, width, height);
    return this;
  };
  HTMLCanvasElementLuminanceSource2.prototype.isRotateSupported = function() {
    return true;
  };
  HTMLCanvasElementLuminanceSource2.prototype.rotateCounterClockwise = function() {
    this.rotate(-90);
    return this;
  };
  HTMLCanvasElementLuminanceSource2.prototype.rotateCounterClockwise45 = function() {
    this.rotate(-45);
    return this;
  };
  HTMLCanvasElementLuminanceSource2.prototype.getTempCanvasElement = function() {
    if (this.tempCanvasElement === null) {
      var tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
      tempCanvasElement.width = this.canvas.width;
      tempCanvasElement.height = this.canvas.height;
      this.tempCanvasElement = tempCanvasElement;
    }
    return this.tempCanvasElement;
  };
  HTMLCanvasElementLuminanceSource2.prototype.rotate = function(angle) {
    var tempCanvasElement = this.getTempCanvasElement();
    var tempContext = tempCanvasElement.getContext("2d");
    var angleRadians = angle * HTMLCanvasElementLuminanceSource2.DEGREE_TO_RADIANS;
    var width = this.canvas.width;
    var height = this.canvas.height;
    var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
    var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
    tempCanvasElement.width = newWidth;
    tempCanvasElement.height = newHeight;
    tempContext.translate(newWidth / 2, newHeight / 2);
    tempContext.rotate(angleRadians);
    tempContext.drawImage(this.canvas, width / -2, height / -2);
    this.buffer = HTMLCanvasElementLuminanceSource2.makeBufferFromCanvasImageData(tempCanvasElement);
    return this;
  };
  HTMLCanvasElementLuminanceSource2.prototype.invert = function() {
    return new InvertedLuminanceSource_default(this);
  };
  HTMLCanvasElementLuminanceSource2.DEGREE_TO_RADIANS = Math.PI / 180;
  return HTMLCanvasElementLuminanceSource2;
}(LuminanceSource_default);

// node_modules/@zxing/library/esm/browser/VideoInputDevice.js
var VideoInputDevice = function() {
  function VideoInputDevice2(deviceId, label, groupId) {
    this.deviceId = deviceId;
    this.label = label;
    this.kind = "videoinput";
    this.groupId = groupId || void 0;
  }
  VideoInputDevice2.prototype.toJSON = function() {
    return {
      kind: this.kind,
      groupId: this.groupId,
      deviceId: this.deviceId,
      label: this.label
    };
  };
  return VideoInputDevice2;
}();

// node_modules/@zxing/library/esm/browser/BrowserCodeReader.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = {label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: []}, f, y, t, g;
  return g = {next: verb(0), throw: verb(1), return: verb(2)}, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return {value: op[1], done: false};
          case 5:
            _2.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return {value: op[0] ? op[1] : void 0, done: true};
  }
};
var __values3 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BrowserCodeReader = function() {
  function BrowserCodeReader2(reader, timeBetweenScansMillis, _hints) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    this.reader = reader;
    this.timeBetweenScansMillis = timeBetweenScansMillis;
    this._hints = _hints;
    this._stopContinuousDecode = false;
    this._stopAsyncDecode = false;
    this._timeBetweenDecodingAttempts = 0;
  }
  Object.defineProperty(BrowserCodeReader2.prototype, "hasNavigator", {
    get: function() {
      return typeof navigator !== "undefined";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BrowserCodeReader2.prototype, "isMediaDevicesSuported", {
    get: function() {
      return this.hasNavigator && !!navigator.mediaDevices;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BrowserCodeReader2.prototype, "canEnumerateDevices", {
    get: function() {
      return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BrowserCodeReader2.prototype, "timeBetweenDecodingAttempts", {
    get: function() {
      return this._timeBetweenDecodingAttempts;
    },
    set: function(millis) {
      this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BrowserCodeReader2.prototype, "hints", {
    get: function() {
      return this._hints;
    },
    set: function(hints) {
      this._hints = hints || null;
    },
    enumerable: false,
    configurable: true
  });
  BrowserCodeReader2.prototype.listVideoInputDevices = function() {
    return __awaiter(this, void 0, void 0, function() {
      var devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;
      var e_1, _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!this.hasNavigator) {
              throw new Error("Can't enumerate devices, navigator is not present.");
            }
            if (!this.canEnumerateDevices) {
              throw new Error("Can't enumerate devices, method not supported.");
            }
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 1:
            devices = _b.sent();
            videoDevices = [];
            try {
              for (devices_1 = __values3(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {
                device = devices_1_1.value;
                kind = device.kind === "video" ? "videoinput" : device.kind;
                if (kind !== "videoinput") {
                  continue;
                }
                deviceId = device.deviceId || device.id;
                label = device.label || "Video device " + (videoDevices.length + 1);
                groupId = device.groupId;
                videoDevice = {deviceId, label, kind, groupId};
                videoDevices.push(videoDevice);
              }
            } catch (e_1_1) {
              e_1 = {error: e_1_1};
            } finally {
              try {
                if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return))
                  _a.call(devices_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            return [2, videoDevices];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.getVideoInputDevices = function() {
    return __awaiter(this, void 0, void 0, function() {
      var devices;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.listVideoInputDevices()];
          case 1:
            devices = _a.sent();
            return [2, devices.map(function(d) {
              return new VideoInputDevice(d.deviceId, d.label);
            })];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.findDeviceById = function(deviceId) {
    return __awaiter(this, void 0, void 0, function() {
      var devices;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.listVideoInputDevices()];
          case 1:
            devices = _a.sent();
            if (!devices) {
              return [2, null];
            }
            return [2, devices.find(function(x2) {
              return x2.deviceId === deviceId;
            })];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeFromInputVideoDevice = function(deviceId, videoSource) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.decodeOnceFromVideoDevice(deviceId, videoSource)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeOnceFromVideoDevice = function(deviceId, videoSource) {
    return __awaiter(this, void 0, void 0, function() {
      var videoConstraints, constraints;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reset();
            if (!deviceId) {
              videoConstraints = {facingMode: "environment"};
            } else {
              videoConstraints = {deviceId: {exact: deviceId}};
            }
            constraints = {video: videoConstraints};
            return [4, this.decodeOnceFromConstraints(constraints, videoSource)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeOnceFromConstraints = function(constraints, videoSource) {
    return __awaiter(this, void 0, void 0, function() {
      var stream;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, navigator.mediaDevices.getUserMedia(constraints)];
          case 1:
            stream = _a.sent();
            return [4, this.decodeOnceFromStream(stream, videoSource)];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeOnceFromStream = function(stream, videoSource) {
    return __awaiter(this, void 0, void 0, function() {
      var video, result;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reset();
            return [4, this.attachStreamToVideo(stream, videoSource)];
          case 1:
            video = _a.sent();
            return [4, this.decodeOnce(video)];
          case 2:
            result = _a.sent();
            return [2, result];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeFromInputVideoDeviceContinuously = function(deviceId, videoSource, callbackFn) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.decodeFromVideoDevice(deviceId, videoSource, callbackFn)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeFromVideoDevice = function(deviceId, videoSource, callbackFn) {
    return __awaiter(this, void 0, void 0, function() {
      var videoConstraints, constraints;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!deviceId) {
              videoConstraints = {facingMode: "environment"};
            } else {
              videoConstraints = {deviceId: {exact: deviceId}};
            }
            constraints = {video: videoConstraints};
            return [4, this.decodeFromConstraints(constraints, videoSource, callbackFn)];
          case 1:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeFromConstraints = function(constraints, videoSource, callbackFn) {
    return __awaiter(this, void 0, void 0, function() {
      var stream;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, navigator.mediaDevices.getUserMedia(constraints)];
          case 1:
            stream = _a.sent();
            return [4, this.decodeFromStream(stream, videoSource, callbackFn)];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.decodeFromStream = function(stream, videoSource, callbackFn) {
    return __awaiter(this, void 0, void 0, function() {
      var video;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reset();
            return [4, this.attachStreamToVideo(stream, videoSource)];
          case 1:
            video = _a.sent();
            return [4, this.decodeContinuously(video, callbackFn)];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.stopAsyncDecode = function() {
    this._stopAsyncDecode = true;
  };
  BrowserCodeReader2.prototype.stopContinuousDecode = function() {
    this._stopContinuousDecode = true;
  };
  BrowserCodeReader2.prototype.attachStreamToVideo = function(stream, videoSource) {
    return __awaiter(this, void 0, void 0, function() {
      var videoElement;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            videoElement = this.prepareVideoElement(videoSource);
            this.addVideoSource(videoElement, stream);
            this.videoElement = videoElement;
            this.stream = stream;
            return [4, this.playVideoOnLoadAsync(videoElement)];
          case 1:
            _a.sent();
            return [2, videoElement];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.playVideoOnLoadAsync = function(videoElement) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      return _this.playVideoOnLoad(videoElement, function() {
        return resolve();
      });
    });
  };
  BrowserCodeReader2.prototype.playVideoOnLoad = function(element, callbackFn) {
    var _this = this;
    this.videoEndedListener = function() {
      return _this.stopStreams();
    };
    this.videoCanPlayListener = function() {
      return _this.tryPlayVideo(element);
    };
    element.addEventListener("ended", this.videoEndedListener);
    element.addEventListener("canplay", this.videoCanPlayListener);
    element.addEventListener("playing", callbackFn);
    this.tryPlayVideo(element);
  };
  BrowserCodeReader2.prototype.isVideoPlaying = function(video) {
    return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
  };
  BrowserCodeReader2.prototype.tryPlayVideo = function(videoElement) {
    return __awaiter(this, void 0, void 0, function() {
      var _a;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (this.isVideoPlaying(videoElement)) {
              console.warn("Trying to play video that is already playing.");
              return [2];
            }
            _b.label = 1;
          case 1:
            _b.trys.push([1, 3, , 4]);
            return [4, videoElement.play()];
          case 2:
            _b.sent();
            return [3, 4];
          case 3:
            _a = _b.sent();
            console.warn("It was not possible to play the video.");
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.getMediaElement = function(mediaElementId, type) {
    var mediaElement = document.getElementById(mediaElementId);
    if (!mediaElement) {
      throw new ArgumentException_default("element with id '" + mediaElementId + "' not found");
    }
    if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
      throw new ArgumentException_default("element with id '" + mediaElementId + "' must be an " + type + " element");
    }
    return mediaElement;
  };
  BrowserCodeReader2.prototype.decodeFromImage = function(source, url) {
    if (!source && !url) {
      throw new ArgumentException_default("either imageElement with a src set or an url must be provided");
    }
    if (url && !source) {
      return this.decodeFromImageUrl(url);
    }
    return this.decodeFromImageElement(source);
  };
  BrowserCodeReader2.prototype.decodeFromVideo = function(source, url) {
    if (!source && !url) {
      throw new ArgumentException_default("Either an element with a src set or an URL must be provided");
    }
    if (url && !source) {
      return this.decodeFromVideoUrl(url);
    }
    return this.decodeFromVideoElement(source);
  };
  BrowserCodeReader2.prototype.decodeFromVideoContinuously = function(source, url, callbackFn) {
    if (source === void 0 && url === void 0) {
      throw new ArgumentException_default("Either an element with a src set or an URL must be provided");
    }
    if (url && !source) {
      return this.decodeFromVideoUrlContinuously(url, callbackFn);
    }
    return this.decodeFromVideoElementContinuously(source, callbackFn);
  };
  BrowserCodeReader2.prototype.decodeFromImageElement = function(source) {
    if (!source) {
      throw new ArgumentException_default("An image element must be provided.");
    }
    this.reset();
    var element = this.prepareImageElement(source);
    this.imageElement = element;
    var task;
    if (this.isImageLoaded(element)) {
      task = this.decodeOnce(element, false, true);
    } else {
      task = this._decodeOnLoadImage(element);
    }
    return task;
  };
  BrowserCodeReader2.prototype.decodeFromVideoElement = function(source) {
    var element = this._decodeFromVideoElementSetup(source);
    return this._decodeOnLoadVideo(element);
  };
  BrowserCodeReader2.prototype.decodeFromVideoElementContinuously = function(source, callbackFn) {
    var element = this._decodeFromVideoElementSetup(source);
    return this._decodeOnLoadVideoContinuously(element, callbackFn);
  };
  BrowserCodeReader2.prototype._decodeFromVideoElementSetup = function(source) {
    if (!source) {
      throw new ArgumentException_default("A video element must be provided.");
    }
    this.reset();
    var element = this.prepareVideoElement(source);
    this.videoElement = element;
    return element;
  };
  BrowserCodeReader2.prototype.decodeFromImageUrl = function(url) {
    if (!url) {
      throw new ArgumentException_default("An URL must be provided.");
    }
    this.reset();
    var element = this.prepareImageElement();
    this.imageElement = element;
    var decodeTask = this._decodeOnLoadImage(element);
    element.src = url;
    return decodeTask;
  };
  BrowserCodeReader2.prototype.decodeFromVideoUrl = function(url) {
    if (!url) {
      throw new ArgumentException_default("An URL must be provided.");
    }
    this.reset();
    var element = this.prepareVideoElement();
    var decodeTask = this.decodeFromVideoElement(element);
    element.src = url;
    return decodeTask;
  };
  BrowserCodeReader2.prototype.decodeFromVideoUrlContinuously = function(url, callbackFn) {
    if (!url) {
      throw new ArgumentException_default("An URL must be provided.");
    }
    this.reset();
    var element = this.prepareVideoElement();
    var decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
    element.src = url;
    return decodeTask;
  };
  BrowserCodeReader2.prototype._decodeOnLoadImage = function(element) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.imageLoadedListener = function() {
        return _this.decodeOnce(element, false, true).then(resolve, reject);
      };
      element.addEventListener("load", _this.imageLoadedListener);
    });
  };
  BrowserCodeReader2.prototype._decodeOnLoadVideo = function(videoElement) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.playVideoOnLoadAsync(videoElement)];
          case 1:
            _a.sent();
            return [4, this.decodeOnce(videoElement)];
          case 2:
            return [2, _a.sent()];
        }
      });
    });
  };
  BrowserCodeReader2.prototype._decodeOnLoadVideoContinuously = function(videoElement, callbackFn) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.playVideoOnLoadAsync(videoElement)];
          case 1:
            _a.sent();
            this.decodeContinuously(videoElement, callbackFn);
            return [2];
        }
      });
    });
  };
  BrowserCodeReader2.prototype.isImageLoaded = function(img) {
    if (!img.complete) {
      return false;
    }
    if (img.naturalWidth === 0) {
      return false;
    }
    return true;
  };
  BrowserCodeReader2.prototype.prepareImageElement = function(imageSource) {
    var imageElement;
    if (typeof imageSource === "undefined") {
      imageElement = document.createElement("img");
      imageElement.width = 200;
      imageElement.height = 200;
    }
    if (typeof imageSource === "string") {
      imageElement = this.getMediaElement(imageSource, "img");
    }
    if (imageSource instanceof HTMLImageElement) {
      imageElement = imageSource;
    }
    return imageElement;
  };
  BrowserCodeReader2.prototype.prepareVideoElement = function(videoSource) {
    var videoElement;
    if (!videoSource && typeof document !== "undefined") {
      videoElement = document.createElement("video");
      videoElement.width = 200;
      videoElement.height = 200;
    }
    if (typeof videoSource === "string") {
      videoElement = this.getMediaElement(videoSource, "video");
    }
    if (videoSource instanceof HTMLVideoElement) {
      videoElement = videoSource;
    }
    videoElement.setAttribute("autoplay", "true");
    videoElement.setAttribute("muted", "true");
    videoElement.setAttribute("playsinline", "true");
    return videoElement;
  };
  BrowserCodeReader2.prototype.decodeOnce = function(element, retryIfNotFound, retryIfChecksumOrFormatError) {
    var _this = this;
    if (retryIfNotFound === void 0) {
      retryIfNotFound = true;
    }
    if (retryIfChecksumOrFormatError === void 0) {
      retryIfChecksumOrFormatError = true;
    }
    this._stopAsyncDecode = false;
    var loop = function(resolve, reject) {
      if (_this._stopAsyncDecode) {
        reject(new NotFoundException_default("Video stream has ended before any code could be detected."));
        _this._stopAsyncDecode = void 0;
        return;
      }
      try {
        var result = _this.decode(element);
        resolve(result);
      } catch (e) {
        var ifNotFound = retryIfNotFound && e instanceof NotFoundException_default;
        var isChecksumOrFormatError = e instanceof ChecksumException_default || e instanceof FormatException_default;
        var ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
        if (ifNotFound || ifChecksumOrFormat) {
          return setTimeout(loop, _this._timeBetweenDecodingAttempts, resolve, reject);
        }
        reject(e);
      }
    };
    return new Promise(function(resolve, reject) {
      return loop(resolve, reject);
    });
  };
  BrowserCodeReader2.prototype.decodeContinuously = function(element, callbackFn) {
    var _this = this;
    this._stopContinuousDecode = false;
    var loop = function() {
      if (_this._stopContinuousDecode) {
        _this._stopContinuousDecode = void 0;
        return;
      }
      try {
        var result = _this.decode(element);
        callbackFn(result, null);
        setTimeout(loop, _this.timeBetweenScansMillis);
      } catch (e) {
        callbackFn(null, e);
        var isChecksumOrFormatError = e instanceof ChecksumException_default || e instanceof FormatException_default;
        var isNotFound = e instanceof NotFoundException_default;
        if (isChecksumOrFormatError || isNotFound) {
          setTimeout(loop, _this._timeBetweenDecodingAttempts);
        }
      }
    };
    loop();
  };
  BrowserCodeReader2.prototype.decode = function(element) {
    var binaryBitmap = this.createBinaryBitmap(element);
    return this.decodeBitmap(binaryBitmap);
  };
  BrowserCodeReader2.prototype.createBinaryBitmap = function(mediaElement) {
    var ctx = this.getCaptureCanvasContext(mediaElement);
    this.drawImageOnCanvas(ctx, mediaElement);
    var canvas = this.getCaptureCanvas(mediaElement);
    var luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
    var hybridBinarizer = new HybridBinarizer_default(luminanceSource);
    return new BinaryBitmap_default(hybridBinarizer);
  };
  BrowserCodeReader2.prototype.getCaptureCanvasContext = function(mediaElement) {
    if (!this.captureCanvasContext) {
      var elem = this.getCaptureCanvas(mediaElement);
      var ctx = elem.getContext("2d");
      this.captureCanvasContext = ctx;
    }
    return this.captureCanvasContext;
  };
  BrowserCodeReader2.prototype.getCaptureCanvas = function(mediaElement) {
    if (!this.captureCanvas) {
      var elem = this.createCaptureCanvas(mediaElement);
      this.captureCanvas = elem;
    }
    return this.captureCanvas;
  };
  BrowserCodeReader2.prototype.drawImageOnCanvas = function(canvasElementContext, srcElement) {
    canvasElementContext.drawImage(srcElement, 0, 0);
  };
  BrowserCodeReader2.prototype.decodeBitmap = function(binaryBitmap) {
    return this.reader.decode(binaryBitmap, this._hints);
  };
  BrowserCodeReader2.prototype.createCaptureCanvas = function(mediaElement) {
    if (typeof document === "undefined") {
      this._destroyCaptureCanvas();
      return null;
    }
    var canvasElement = document.createElement("canvas");
    var width;
    var height;
    if (typeof mediaElement !== "undefined") {
      if (mediaElement instanceof HTMLVideoElement) {
        width = mediaElement.videoWidth;
        height = mediaElement.videoHeight;
      } else if (mediaElement instanceof HTMLImageElement) {
        width = mediaElement.naturalWidth || mediaElement.width;
        height = mediaElement.naturalHeight || mediaElement.height;
      }
    }
    canvasElement.style.width = width + "px";
    canvasElement.style.height = height + "px";
    canvasElement.width = width;
    canvasElement.height = height;
    return canvasElement;
  };
  BrowserCodeReader2.prototype.stopStreams = function() {
    if (this.stream) {
      this.stream.getVideoTracks().forEach(function(t) {
        return t.stop();
      });
      this.stream = void 0;
    }
    if (this._stopAsyncDecode === false) {
      this.stopAsyncDecode();
    }
    if (this._stopContinuousDecode === false) {
      this.stopContinuousDecode();
    }
  };
  BrowserCodeReader2.prototype.reset = function() {
    this.stopStreams();
    this._destroyVideoElement();
    this._destroyImageElement();
    this._destroyCaptureCanvas();
  };
  BrowserCodeReader2.prototype._destroyVideoElement = function() {
    if (!this.videoElement) {
      return;
    }
    if (typeof this.videoEndedListener !== "undefined") {
      this.videoElement.removeEventListener("ended", this.videoEndedListener);
    }
    if (typeof this.videoPlayingEventListener !== "undefined") {
      this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
    }
    if (typeof this.videoCanPlayListener !== "undefined") {
      this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
    }
    this.cleanVideoSource(this.videoElement);
    this.videoElement = void 0;
  };
  BrowserCodeReader2.prototype._destroyImageElement = function() {
    if (!this.imageElement) {
      return;
    }
    if (this.imageLoadedListener !== void 0) {
      this.imageElement.removeEventListener("load", this.imageLoadedListener);
    }
    this.imageElement.src = void 0;
    this.imageElement.removeAttribute("src");
    this.imageElement = void 0;
  };
  BrowserCodeReader2.prototype._destroyCaptureCanvas = function() {
    this.captureCanvasContext = void 0;
    this.captureCanvas = void 0;
  };
  BrowserCodeReader2.prototype.addVideoSource = function(videoElement, stream) {
    try {
      videoElement.srcObject = stream;
    } catch (err2) {
      videoElement.src = URL.createObjectURL(stream);
    }
  };
  BrowserCodeReader2.prototype.cleanVideoSource = function(videoElement) {
    try {
      videoElement.srcObject = null;
    } catch (err2) {
      videoElement.src = "";
    }
    this.videoElement.removeAttribute("src");
  };
  return BrowserCodeReader2;
}();

// node_modules/@zxing/library/esm/core/Result.js
var Result = function() {
  function Result2(text, rawBytes, numBits, resultPoints, format, timestamp) {
    if (numBits === void 0) {
      numBits = rawBytes == null ? 0 : 8 * rawBytes.length;
    }
    if (timestamp === void 0) {
      timestamp = System_default.currentTimeMillis();
    }
    this.text = text;
    this.rawBytes = rawBytes;
    this.numBits = numBits;
    this.resultPoints = resultPoints;
    this.format = format;
    this.timestamp = timestamp;
    this.text = text;
    this.rawBytes = rawBytes;
    if (numBits === void 0 || numBits === null) {
      this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
    } else {
      this.numBits = numBits;
    }
    this.resultPoints = resultPoints;
    this.format = format;
    this.resultMetadata = null;
    if (timestamp === void 0 || timestamp === null) {
      this.timestamp = System_default.currentTimeMillis();
    } else {
      this.timestamp = timestamp;
    }
  }
  Result2.prototype.getText = function() {
    return this.text;
  };
  Result2.prototype.getRawBytes = function() {
    return this.rawBytes;
  };
  Result2.prototype.getNumBits = function() {
    return this.numBits;
  };
  Result2.prototype.getResultPoints = function() {
    return this.resultPoints;
  };
  Result2.prototype.getBarcodeFormat = function() {
    return this.format;
  };
  Result2.prototype.getResultMetadata = function() {
    return this.resultMetadata;
  };
  Result2.prototype.putMetadata = function(type, value) {
    if (this.resultMetadata === null) {
      this.resultMetadata = new Map();
    }
    this.resultMetadata.set(type, value);
  };
  Result2.prototype.putAllMetadata = function(metadata) {
    if (metadata !== null) {
      if (this.resultMetadata === null) {
        this.resultMetadata = metadata;
      } else {
        this.resultMetadata = new Map(metadata);
      }
    }
  };
  Result2.prototype.addResultPoints = function(newPoints) {
    var oldPoints = this.resultPoints;
    if (oldPoints === null) {
      this.resultPoints = newPoints;
    } else if (newPoints !== null && newPoints.length > 0) {
      var allPoints = new Array(oldPoints.length + newPoints.length);
      System_default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
      System_default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
      this.resultPoints = allPoints;
    }
  };
  Result2.prototype.getTimestamp = function() {
    return this.timestamp;
  };
  Result2.prototype.toString = function() {
    return this.text;
  };
  return Result2;
}();
var Result_default = Result;

// node_modules/@zxing/library/esm/core/BarcodeFormat.js
var BarcodeFormat;
(function(BarcodeFormat2) {
  BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
  BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
  BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
  BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
  BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
  BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
  BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
  BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
  BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
  BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
  BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
  BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
  BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
  BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
  BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
  BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
  BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(BarcodeFormat || (BarcodeFormat = {}));
var BarcodeFormat_default = BarcodeFormat;

// node_modules/@zxing/library/esm/core/ResultMetadataType.js
var ResultMetadataType;
(function(ResultMetadataType2) {
  ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
  ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
  ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
  ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
  ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
  ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
  ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
  ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
  ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
  ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
  ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
})(ResultMetadataType || (ResultMetadataType = {}));
var ResultMetadataType_default = ResultMetadataType;

// node_modules/@zxing/library/esm/core/common/DecoderResult.js
var DecoderResult = function() {
  function DecoderResult2(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {
    if (structuredAppendSequenceNumber === void 0) {
      structuredAppendSequenceNumber = -1;
    }
    if (structuredAppendParity === void 0) {
      structuredAppendParity = -1;
    }
    this.rawBytes = rawBytes;
    this.text = text;
    this.byteSegments = byteSegments;
    this.ecLevel = ecLevel;
    this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
    this.structuredAppendParity = structuredAppendParity;
    this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
  }
  DecoderResult2.prototype.getRawBytes = function() {
    return this.rawBytes;
  };
  DecoderResult2.prototype.getNumBits = function() {
    return this.numBits;
  };
  DecoderResult2.prototype.setNumBits = function(numBits) {
    this.numBits = numBits;
  };
  DecoderResult2.prototype.getText = function() {
    return this.text;
  };
  DecoderResult2.prototype.getByteSegments = function() {
    return this.byteSegments;
  };
  DecoderResult2.prototype.getECLevel = function() {
    return this.ecLevel;
  };
  DecoderResult2.prototype.getErrorsCorrected = function() {
    return this.errorsCorrected;
  };
  DecoderResult2.prototype.setErrorsCorrected = function(errorsCorrected) {
    this.errorsCorrected = errorsCorrected;
  };
  DecoderResult2.prototype.getErasures = function() {
    return this.erasures;
  };
  DecoderResult2.prototype.setErasures = function(erasures) {
    this.erasures = erasures;
  };
  DecoderResult2.prototype.getOther = function() {
    return this.other;
  };
  DecoderResult2.prototype.setOther = function(other) {
    this.other = other;
  };
  DecoderResult2.prototype.hasStructuredAppend = function() {
    return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
  };
  DecoderResult2.prototype.getStructuredAppendParity = function() {
    return this.structuredAppendParity;
  };
  DecoderResult2.prototype.getStructuredAppendSequenceNumber = function() {
    return this.structuredAppendSequenceNumber;
  };
  return DecoderResult2;
}();
var DecoderResult_default = DecoderResult;

// node_modules/@zxing/library/esm/core/common/reedsolomon/AbstractGenericGF.js
var AbstractGenericGF = function() {
  function AbstractGenericGF2() {
  }
  AbstractGenericGF2.prototype.exp = function(a) {
    return this.expTable[a];
  };
  AbstractGenericGF2.prototype.log = function(a) {
    if (a === 0) {
      throw new IllegalArgumentException_default();
    }
    return this.logTable[a];
  };
  AbstractGenericGF2.addOrSubtract = function(a, b) {
    return a ^ b;
  };
  return AbstractGenericGF2;
}();
var AbstractGenericGF_default = AbstractGenericGF;

// node_modules/@zxing/library/esm/core/common/reedsolomon/GenericGFPoly.js
var GenericGFPoly = function() {
  function GenericGFPoly2(field, coefficients) {
    if (coefficients.length === 0) {
      throw new IllegalArgumentException_default();
    }
    this.field = field;
    var coefficientsLength = coefficients.length;
    if (coefficientsLength > 1 && coefficients[0] === 0) {
      var firstNonZero = 1;
      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
        firstNonZero++;
      }
      if (firstNonZero === coefficientsLength) {
        this.coefficients = Int32Array.from([0]);
      } else {
        this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
        System_default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
      }
    } else {
      this.coefficients = coefficients;
    }
  }
  GenericGFPoly2.prototype.getCoefficients = function() {
    return this.coefficients;
  };
  GenericGFPoly2.prototype.getDegree = function() {
    return this.coefficients.length - 1;
  };
  GenericGFPoly2.prototype.isZero = function() {
    return this.coefficients[0] === 0;
  };
  GenericGFPoly2.prototype.getCoefficient = function(degree) {
    return this.coefficients[this.coefficients.length - 1 - degree];
  };
  GenericGFPoly2.prototype.evaluateAt = function(a) {
    if (a === 0) {
      return this.getCoefficient(0);
    }
    var coefficients = this.coefficients;
    var result;
    if (a === 1) {
      result = 0;
      for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {
        var coefficient = coefficients[i];
        result = AbstractGenericGF_default.addOrSubtract(result, coefficient);
      }
      return result;
    }
    result = coefficients[0];
    var size = coefficients.length;
    var field = this.field;
    for (var i = 1; i < size; i++) {
      result = AbstractGenericGF_default.addOrSubtract(field.multiply(a, result), coefficients[i]);
    }
    return result;
  };
  GenericGFPoly2.prototype.addOrSubtract = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
    }
    if (this.isZero()) {
      return other;
    }
    if (other.isZero()) {
      return this;
    }
    var smallerCoefficients = this.coefficients;
    var largerCoefficients = other.coefficients;
    if (smallerCoefficients.length > largerCoefficients.length) {
      var temp = smallerCoefficients;
      smallerCoefficients = largerCoefficients;
      largerCoefficients = temp;
    }
    var sumDiff = new Int32Array(largerCoefficients.length);
    var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
    System_default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
    for (var i = lengthDiff; i < largerCoefficients.length; i++) {
      sumDiff[i] = AbstractGenericGF_default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
    }
    return new GenericGFPoly2(this.field, sumDiff);
  };
  GenericGFPoly2.prototype.multiply = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
    }
    if (this.isZero() || other.isZero()) {
      return this.field.getZero();
    }
    var aCoefficients = this.coefficients;
    var aLength = aCoefficients.length;
    var bCoefficients = other.coefficients;
    var bLength = bCoefficients.length;
    var product = new Int32Array(aLength + bLength - 1);
    var field = this.field;
    for (var i = 0; i < aLength; i++) {
      var aCoeff = aCoefficients[i];
      for (var j = 0; j < bLength; j++) {
        product[i + j] = AbstractGenericGF_default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
      }
    }
    return new GenericGFPoly2(field, product);
  };
  GenericGFPoly2.prototype.multiplyScalar = function(scalar) {
    if (scalar === 0) {
      return this.field.getZero();
    }
    if (scalar === 1) {
      return this;
    }
    var size = this.coefficients.length;
    var field = this.field;
    var product = new Int32Array(size);
    var coefficients = this.coefficients;
    for (var i = 0; i < size; i++) {
      product[i] = field.multiply(coefficients[i], scalar);
    }
    return new GenericGFPoly2(field, product);
  };
  GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
    if (degree < 0) {
      throw new IllegalArgumentException_default();
    }
    if (coefficient === 0) {
      return this.field.getZero();
    }
    var coefficients = this.coefficients;
    var size = coefficients.length;
    var product = new Int32Array(size + degree);
    var field = this.field;
    for (var i = 0; i < size; i++) {
      product[i] = field.multiply(coefficients[i], coefficient);
    }
    return new GenericGFPoly2(field, product);
  };
  GenericGFPoly2.prototype.divide = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("GenericGFPolys do not have same GenericGF field");
    }
    if (other.isZero()) {
      throw new IllegalArgumentException_default("Divide by 0");
    }
    var field = this.field;
    var quotient = field.getZero();
    var remainder = this;
    var denominatorLeadingTerm = other.getCoefficient(other.getDegree());
    var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
    while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
      var degreeDifference = remainder.getDegree() - other.getDegree();
      var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
      var term = other.multiplyByMonomial(degreeDifference, scale);
      var iterationQuotient = field.buildMonomial(degreeDifference, scale);
      quotient = quotient.addOrSubtract(iterationQuotient);
      remainder = remainder.addOrSubtract(term);
    }
    return [quotient, remainder];
  };
  GenericGFPoly2.prototype.toString = function() {
    var result = "";
    for (var degree = this.getDegree(); degree >= 0; degree--) {
      var coefficient = this.getCoefficient(degree);
      if (coefficient !== 0) {
        if (coefficient < 0) {
          result += " - ";
          coefficient = -coefficient;
        } else {
          if (result.length > 0) {
            result += " + ";
          }
        }
        if (degree === 0 || coefficient !== 1) {
          var alphaPower = this.field.log(coefficient);
          if (alphaPower === 0) {
            result += "1";
          } else if (alphaPower === 1) {
            result += "a";
          } else {
            result += "a^";
            result += alphaPower;
          }
        }
        if (degree !== 0) {
          if (degree === 1) {
            result += "x";
          } else {
            result += "x^";
            result += degree;
          }
        }
      }
    }
    return result;
  };
  return GenericGFPoly2;
}();
var GenericGFPoly_default = GenericGFPoly;

// node_modules/@zxing/library/esm/core/ArithmeticException.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ArithmeticException = function(_super) {
  __extends15(ArithmeticException2, _super);
  function ArithmeticException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ArithmeticException2.kind = "ArithmeticException";
  return ArithmeticException2;
}(Exception_default);
var ArithmeticException_default = ArithmeticException;

// node_modules/@zxing/library/esm/core/common/reedsolomon/GenericGF.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GenericGF = function(_super) {
  __extends16(GenericGF2, _super);
  function GenericGF2(primitive, size, generatorBase) {
    var _this = _super.call(this) || this;
    _this.primitive = primitive;
    _this.size = size;
    _this.generatorBase = generatorBase;
    var expTable = new Int32Array(size);
    var x2 = 1;
    for (var i = 0; i < size; i++) {
      expTable[i] = x2;
      x2 *= 2;
      if (x2 >= size) {
        x2 ^= primitive;
        x2 &= size - 1;
      }
    }
    _this.expTable = expTable;
    var logTable = new Int32Array(size);
    for (var i = 0; i < size - 1; i++) {
      logTable[expTable[i]] = i;
    }
    _this.logTable = logTable;
    _this.zero = new GenericGFPoly_default(_this, Int32Array.from([0]));
    _this.one = new GenericGFPoly_default(_this, Int32Array.from([1]));
    return _this;
  }
  GenericGF2.prototype.getZero = function() {
    return this.zero;
  };
  GenericGF2.prototype.getOne = function() {
    return this.one;
  };
  GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
    if (degree < 0) {
      throw new IllegalArgumentException_default();
    }
    if (coefficient === 0) {
      return this.zero;
    }
    var coefficients = new Int32Array(degree + 1);
    coefficients[0] = coefficient;
    return new GenericGFPoly_default(this, coefficients);
  };
  GenericGF2.prototype.inverse = function(a) {
    if (a === 0) {
      throw new ArithmeticException_default();
    }
    return this.expTable[this.size - this.logTable[a] - 1];
  };
  GenericGF2.prototype.multiply = function(a, b) {
    if (a === 0 || b === 0) {
      return 0;
    }
    return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
  };
  GenericGF2.prototype.getSize = function() {
    return this.size;
  };
  GenericGF2.prototype.getGeneratorBase = function() {
    return this.generatorBase;
  };
  GenericGF2.prototype.toString = function() {
    return "GF(0x" + Integer_default.toHexString(this.primitive) + "," + this.size + ")";
  };
  GenericGF2.prototype.equals = function(o) {
    return o === this;
  };
  GenericGF2.AZTEC_DATA_12 = new GenericGF2(4201, 4096, 1);
  GenericGF2.AZTEC_DATA_10 = new GenericGF2(1033, 1024, 1);
  GenericGF2.AZTEC_DATA_6 = new GenericGF2(67, 64, 1);
  GenericGF2.AZTEC_PARAM = new GenericGF2(19, 16, 1);
  GenericGF2.QR_CODE_FIELD_256 = new GenericGF2(285, 256, 0);
  GenericGF2.DATA_MATRIX_FIELD_256 = new GenericGF2(301, 256, 1);
  GenericGF2.AZTEC_DATA_8 = GenericGF2.DATA_MATRIX_FIELD_256;
  GenericGF2.MAXICODE_FIELD_64 = GenericGF2.AZTEC_DATA_6;
  return GenericGF2;
}(AbstractGenericGF_default);
var GenericGF_default = GenericGF;

// node_modules/@zxing/library/esm/core/ReedSolomonException.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ReedSolomonException = function(_super) {
  __extends17(ReedSolomonException2, _super);
  function ReedSolomonException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ReedSolomonException2.kind = "ReedSolomonException";
  return ReedSolomonException2;
}(Exception_default);
var ReedSolomonException_default = ReedSolomonException;

// node_modules/@zxing/library/esm/core/IllegalStateException.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var IllegalStateException = function(_super) {
  __extends18(IllegalStateException2, _super);
  function IllegalStateException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IllegalStateException2.kind = "IllegalStateException";
  return IllegalStateException2;
}(Exception_default);
var IllegalStateException_default = IllegalStateException;

// node_modules/@zxing/library/esm/core/common/reedsolomon/ReedSolomonDecoder.js
var ReedSolomonDecoder = function() {
  function ReedSolomonDecoder2(field) {
    this.field = field;
  }
  ReedSolomonDecoder2.prototype.decode = function(received, twoS) {
    var field = this.field;
    var poly = new GenericGFPoly_default(field, received);
    var syndromeCoefficients = new Int32Array(twoS);
    var noError = true;
    for (var i = 0; i < twoS; i++) {
      var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
      syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
      if (evalResult !== 0) {
        noError = false;
      }
    }
    if (noError) {
      return;
    }
    var syndrome = new GenericGFPoly_default(field, syndromeCoefficients);
    var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
    var sigma = sigmaOmega[0];
    var omega = sigmaOmega[1];
    var errorLocations = this.findErrorLocations(sigma);
    var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
    for (var i = 0; i < errorLocations.length; i++) {
      var position = received.length - 1 - field.log(errorLocations[i]);
      if (position < 0) {
        throw new ReedSolomonException_default("Bad error location");
      }
      received[position] = GenericGF_default.addOrSubtract(received[position], errorMagnitudes[i]);
    }
  };
  ReedSolomonDecoder2.prototype.runEuclideanAlgorithm = function(a, b, R) {
    if (a.getDegree() < b.getDegree()) {
      var temp = a;
      a = b;
      b = temp;
    }
    var field = this.field;
    var rLast = a;
    var r = b;
    var tLast = field.getZero();
    var t = field.getOne();
    while (r.getDegree() >= (R / 2 | 0)) {
      var rLastLast = rLast;
      var tLastLast = tLast;
      rLast = r;
      tLast = t;
      if (rLast.isZero()) {
        throw new ReedSolomonException_default("r_{i-1} was zero");
      }
      r = rLastLast;
      var q = field.getZero();
      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
      var dltInverse = field.inverse(denominatorLeadingTerm);
      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
        var degreeDiff = r.getDegree() - rLast.getDegree();
        var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
        q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
        r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
      }
      t = q.multiply(tLast).addOrSubtract(tLastLast);
      if (r.getDegree() >= rLast.getDegree()) {
        throw new IllegalStateException_default("Division algorithm failed to reduce polynomial?");
      }
    }
    var sigmaTildeAtZero = t.getCoefficient(0);
    if (sigmaTildeAtZero === 0) {
      throw new ReedSolomonException_default("sigmaTilde(0) was zero");
    }
    var inverse = field.inverse(sigmaTildeAtZero);
    var sigma = t.multiplyScalar(inverse);
    var omega = r.multiplyScalar(inverse);
    return [sigma, omega];
  };
  ReedSolomonDecoder2.prototype.findErrorLocations = function(errorLocator) {
    var numErrors = errorLocator.getDegree();
    if (numErrors === 1) {
      return Int32Array.from([errorLocator.getCoefficient(1)]);
    }
    var result = new Int32Array(numErrors);
    var e = 0;
    var field = this.field;
    for (var i = 1; i < field.getSize() && e < numErrors; i++) {
      if (errorLocator.evaluateAt(i) === 0) {
        result[e] = field.inverse(i);
        e++;
      }
    }
    if (e !== numErrors) {
      throw new ReedSolomonException_default("Error locator degree does not match number of roots");
    }
    return result;
  };
  ReedSolomonDecoder2.prototype.findErrorMagnitudes = function(errorEvaluator, errorLocations) {
    var s = errorLocations.length;
    var result = new Int32Array(s);
    var field = this.field;
    for (var i = 0; i < s; i++) {
      var xiInverse = field.inverse(errorLocations[i]);
      var denominator = 1;
      for (var j = 0; j < s; j++) {
        if (i !== j) {
          var term = field.multiply(errorLocations[j], xiInverse);
          var termPlus1 = (term & 1) === 0 ? term | 1 : term & ~1;
          denominator = field.multiply(denominator, termPlus1);
        }
      }
      result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
      if (field.getGeneratorBase() !== 0) {
        result[i] = field.multiply(result[i], xiInverse);
      }
    }
    return result;
  };
  return ReedSolomonDecoder2;
}();
var ReedSolomonDecoder_default = ReedSolomonDecoder;

// node_modules/@zxing/library/esm/core/aztec/decoder/Decoder.js
var Table;
(function(Table2) {
  Table2[Table2["UPPER"] = 0] = "UPPER";
  Table2[Table2["LOWER"] = 1] = "LOWER";
  Table2[Table2["MIXED"] = 2] = "MIXED";
  Table2[Table2["DIGIT"] = 3] = "DIGIT";
  Table2[Table2["PUNCT"] = 4] = "PUNCT";
  Table2[Table2["BINARY"] = 5] = "BINARY";
})(Table || (Table = {}));
var Decoder = function() {
  function Decoder4() {
  }
  Decoder4.prototype.decode = function(detectorResult) {
    this.ddata = detectorResult;
    var matrix = detectorResult.getBits();
    var rawbits = this.extractBits(matrix);
    var correctedBits = this.correctBits(rawbits);
    var rawBytes = Decoder4.convertBoolArrayToByteArray(correctedBits);
    var result = Decoder4.getEncodedData(correctedBits);
    var decoderResult = new DecoderResult_default(rawBytes, result, null, null);
    decoderResult.setNumBits(correctedBits.length);
    return decoderResult;
  };
  Decoder4.highLevelDecode = function(correctedBits) {
    return this.getEncodedData(correctedBits);
  };
  Decoder4.getEncodedData = function(correctedBits) {
    var endIndex = correctedBits.length;
    var latchTable = Table.UPPER;
    var shiftTable = Table.UPPER;
    var result = "";
    var index = 0;
    while (index < endIndex) {
      if (shiftTable === Table.BINARY) {
        if (endIndex - index < 5) {
          break;
        }
        var length_1 = Decoder4.readCode(correctedBits, index, 5);
        index += 5;
        if (length_1 === 0) {
          if (endIndex - index < 11) {
            break;
          }
          length_1 = Decoder4.readCode(correctedBits, index, 11) + 31;
          index += 11;
        }
        for (var charCount = 0; charCount < length_1; charCount++) {
          if (endIndex - index < 8) {
            index = endIndex;
            break;
          }
          var code = Decoder4.readCode(correctedBits, index, 8);
          result += StringUtils_default.castAsNonUtf8Char(code);
          index += 8;
        }
        shiftTable = latchTable;
      } else {
        var size = shiftTable === Table.DIGIT ? 4 : 5;
        if (endIndex - index < size) {
          break;
        }
        var code = Decoder4.readCode(correctedBits, index, size);
        index += size;
        var str = Decoder4.getCharacter(shiftTable, code);
        if (str.startsWith("CTRL_")) {
          latchTable = shiftTable;
          shiftTable = Decoder4.getTable(str.charAt(5));
          if (str.charAt(6) === "L") {
            latchTable = shiftTable;
          }
        } else {
          result += str;
          shiftTable = latchTable;
        }
      }
    }
    return result;
  };
  Decoder4.getTable = function(t) {
    switch (t) {
      case "L":
        return Table.LOWER;
      case "P":
        return Table.PUNCT;
      case "M":
        return Table.MIXED;
      case "D":
        return Table.DIGIT;
      case "B":
        return Table.BINARY;
      case "U":
      default:
        return Table.UPPER;
    }
  };
  Decoder4.getCharacter = function(table, code) {
    switch (table) {
      case Table.UPPER:
        return Decoder4.UPPER_TABLE[code];
      case Table.LOWER:
        return Decoder4.LOWER_TABLE[code];
      case Table.MIXED:
        return Decoder4.MIXED_TABLE[code];
      case Table.PUNCT:
        return Decoder4.PUNCT_TABLE[code];
      case Table.DIGIT:
        return Decoder4.DIGIT_TABLE[code];
      default:
        throw new IllegalStateException_default("Bad table");
    }
  };
  Decoder4.prototype.correctBits = function(rawbits) {
    var gf;
    var codewordSize;
    if (this.ddata.getNbLayers() <= 2) {
      codewordSize = 6;
      gf = GenericGF_default.AZTEC_DATA_6;
    } else if (this.ddata.getNbLayers() <= 8) {
      codewordSize = 8;
      gf = GenericGF_default.AZTEC_DATA_8;
    } else if (this.ddata.getNbLayers() <= 22) {
      codewordSize = 10;
      gf = GenericGF_default.AZTEC_DATA_10;
    } else {
      codewordSize = 12;
      gf = GenericGF_default.AZTEC_DATA_12;
    }
    var numDataCodewords = this.ddata.getNbDatablocks();
    var numCodewords = rawbits.length / codewordSize;
    if (numCodewords < numDataCodewords) {
      throw new FormatException_default();
    }
    var offset = rawbits.length % codewordSize;
    var dataWords = new Int32Array(numCodewords);
    for (var i = 0; i < numCodewords; i++, offset += codewordSize) {
      dataWords[i] = Decoder4.readCode(rawbits, offset, codewordSize);
    }
    try {
      var rsDecoder = new ReedSolomonDecoder_default(gf);
      rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
    } catch (ex) {
      throw new FormatException_default(ex);
    }
    var mask = (1 << codewordSize) - 1;
    var stuffedBits = 0;
    for (var i = 0; i < numDataCodewords; i++) {
      var dataWord = dataWords[i];
      if (dataWord === 0 || dataWord === mask) {
        throw new FormatException_default();
      } else if (dataWord === 1 || dataWord === mask - 1) {
        stuffedBits++;
      }
    }
    var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
    var index = 0;
    for (var i = 0; i < numDataCodewords; i++) {
      var dataWord = dataWords[i];
      if (dataWord === 1 || dataWord === mask - 1) {
        correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
        index += codewordSize - 1;
      } else {
        for (var bit = codewordSize - 1; bit >= 0; --bit) {
          correctedBits[index++] = (dataWord & 1 << bit) !== 0;
        }
      }
    }
    return correctedBits;
  };
  Decoder4.prototype.extractBits = function(matrix) {
    var compact = this.ddata.isCompact();
    var layers = this.ddata.getNbLayers();
    var baseMatrixSize = (compact ? 11 : 14) + layers * 4;
    var alignmentMap = new Int32Array(baseMatrixSize);
    var rawbits = new Array(this.totalBitsInLayer(layers, compact));
    if (compact) {
      for (var i = 0; i < alignmentMap.length; i++) {
        alignmentMap[i] = i;
      }
    } else {
      var matrixSize = baseMatrixSize + 1 + 2 * Integer_default.truncDivision(Integer_default.truncDivision(baseMatrixSize, 2) - 1, 15);
      var origCenter = baseMatrixSize / 2;
      var center = Integer_default.truncDivision(matrixSize, 2);
      for (var i = 0; i < origCenter; i++) {
        var newOffset = i + Integer_default.truncDivision(i, 15);
        alignmentMap[origCenter - i - 1] = center - newOffset - 1;
        alignmentMap[origCenter + i] = center + newOffset + 1;
      }
    }
    for (var i = 0, rowOffset = 0; i < layers; i++) {
      var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
      var low = i * 2;
      var high = baseMatrixSize - 1 - low;
      for (var j = 0; j < rowSize; j++) {
        var columnOffset = j * 2;
        for (var k = 0; k < 2; k++) {
          rawbits[rowOffset + columnOffset + k] = matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
          rawbits[rowOffset + 2 * rowSize + columnOffset + k] = matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
          rawbits[rowOffset + 4 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
          rawbits[rowOffset + 6 * rowSize + columnOffset + k] = matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
        }
      }
      rowOffset += rowSize * 8;
    }
    return rawbits;
  };
  Decoder4.readCode = function(rawbits, startIndex, length) {
    var res = 0;
    for (var i = startIndex; i < startIndex + length; i++) {
      res <<= 1;
      if (rawbits[i]) {
        res |= 1;
      }
    }
    return res;
  };
  Decoder4.readByte = function(rawbits, startIndex) {
    var n = rawbits.length - startIndex;
    if (n >= 8) {
      return Decoder4.readCode(rawbits, startIndex, 8);
    }
    return Decoder4.readCode(rawbits, startIndex, n) << 8 - n;
  };
  Decoder4.convertBoolArrayToByteArray = function(boolArr) {
    var byteArr = new Uint8Array((boolArr.length + 7) / 8);
    for (var i = 0; i < byteArr.length; i++) {
      byteArr[i] = Decoder4.readByte(boolArr, 8 * i);
    }
    return byteArr;
  };
  Decoder4.prototype.totalBitsInLayer = function(layers, compact) {
    return ((compact ? 88 : 112) + 16 * layers) * layers;
  };
  Decoder4.UPPER_TABLE = [
    "CTRL_PS",
    " ",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "CTRL_LL",
    "CTRL_ML",
    "CTRL_DL",
    "CTRL_BS"
  ];
  Decoder4.LOWER_TABLE = [
    "CTRL_PS",
    " ",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "CTRL_US",
    "CTRL_ML",
    "CTRL_DL",
    "CTRL_BS"
  ];
  Decoder4.MIXED_TABLE = [
    "CTRL_PS",
    " ",
    "\\1",
    "\\2",
    "\\3",
    "\\4",
    "\\5",
    "\\6",
    "\\7",
    "\b",
    "	",
    "\n",
    "\\13",
    "\f",
    "\r",
    "\\33",
    "\\34",
    "\\35",
    "\\36",
    "\\37",
    "@",
    "\\",
    "^",
    "_",
    "`",
    "|",
    "~",
    "\\177",
    "CTRL_LL",
    "CTRL_UL",
    "CTRL_PL",
    "CTRL_BS"
  ];
  Decoder4.PUNCT_TABLE = [
    "",
    "\r",
    "\r\n",
    ". ",
    ", ",
    ": ",
    "!",
    '"',
    "#",
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "?",
    "[",
    "]",
    "{",
    "}",
    "CTRL_UL"
  ];
  Decoder4.DIGIT_TABLE = [
    "CTRL_PS",
    " ",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    ",",
    ".",
    "CTRL_UL",
    "CTRL_US"
  ];
  return Decoder4;
}();
var Decoder_default = Decoder;

// node_modules/@zxing/library/esm/core/common/detector/MathUtils.js
var MathUtils = function() {
  function MathUtils2() {
  }
  MathUtils2.round = function(d) {
    if (d === NaN)
      return 0;
    if (d <= Number.MIN_SAFE_INTEGER)
      return Number.MIN_SAFE_INTEGER;
    if (d >= Number.MAX_SAFE_INTEGER)
      return Number.MAX_SAFE_INTEGER;
    return d + (d < 0 ? -0.5 : 0.5) | 0;
  };
  MathUtils2.distance = function(aX, aY, bX, bY) {
    var xDiff = aX - bX;
    var yDiff = aY - bY;
    return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  };
  MathUtils2.sum = function(array) {
    var count = 0;
    for (var i = 0, length_1 = array.length; i !== length_1; i++) {
      var a = array[i];
      count += a;
    }
    return count;
  };
  return MathUtils2;
}();
var MathUtils_default = MathUtils;

// node_modules/@zxing/library/esm/core/util/Float.js
var Float = function() {
  function Float2() {
  }
  Float2.floatToIntBits = function(f) {
    return f;
  };
  Float2.MAX_VALUE = Number.MAX_SAFE_INTEGER;
  return Float2;
}();
var Float_default = Float;

// node_modules/@zxing/library/esm/core/ResultPoint.js
var ResultPoint = function() {
  function ResultPoint2(x2, y) {
    this.x = x2;
    this.y = y;
  }
  ResultPoint2.prototype.getX = function() {
    return this.x;
  };
  ResultPoint2.prototype.getY = function() {
    return this.y;
  };
  ResultPoint2.prototype.equals = function(other) {
    if (other instanceof ResultPoint2) {
      var otherPoint = other;
      return this.x === otherPoint.x && this.y === otherPoint.y;
    }
    return false;
  };
  ResultPoint2.prototype.hashCode = function() {
    return 31 * Float_default.floatToIntBits(this.x) + Float_default.floatToIntBits(this.y);
  };
  ResultPoint2.prototype.toString = function() {
    return "(" + this.x + "," + this.y + ")";
  };
  ResultPoint2.orderBestPatterns = function(patterns) {
    var zeroOneDistance = this.distance(patterns[0], patterns[1]);
    var oneTwoDistance = this.distance(patterns[1], patterns[2]);
    var zeroTwoDistance = this.distance(patterns[0], patterns[2]);
    var pointA;
    var pointB;
    var pointC;
    if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
      pointB = patterns[0];
      pointA = patterns[1];
      pointC = patterns[2];
    } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
      pointB = patterns[1];
      pointA = patterns[0];
      pointC = patterns[2];
    } else {
      pointB = patterns[2];
      pointA = patterns[0];
      pointC = patterns[1];
    }
    if (this.crossProductZ(pointA, pointB, pointC) < 0) {
      var temp = pointA;
      pointA = pointC;
      pointC = temp;
    }
    patterns[0] = pointA;
    patterns[1] = pointB;
    patterns[2] = pointC;
  };
  ResultPoint2.distance = function(pattern1, pattern2) {
    return MathUtils_default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
  };
  ResultPoint2.crossProductZ = function(pointA, pointB, pointC) {
    var bX = pointB.x;
    var bY = pointB.y;
    return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
  };
  return ResultPoint2;
}();
var ResultPoint_default = ResultPoint;

// node_modules/@zxing/library/esm/core/common/DetectorResult.js
var DetectorResult = function() {
  function DetectorResult2(bits, points) {
    this.bits = bits;
    this.points = points;
  }
  DetectorResult2.prototype.getBits = function() {
    return this.bits;
  };
  DetectorResult2.prototype.getPoints = function() {
    return this.points;
  };
  return DetectorResult2;
}();
var DetectorResult_default = DetectorResult;

// node_modules/@zxing/library/esm/core/aztec/AztecDetectorResult.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AztecDetectorResult = function(_super) {
  __extends19(AztecDetectorResult2, _super);
  function AztecDetectorResult2(bits, points, compact, nbDatablocks, nbLayers) {
    var _this = _super.call(this, bits, points) || this;
    _this.compact = compact;
    _this.nbDatablocks = nbDatablocks;
    _this.nbLayers = nbLayers;
    return _this;
  }
  AztecDetectorResult2.prototype.getNbLayers = function() {
    return this.nbLayers;
  };
  AztecDetectorResult2.prototype.getNbDatablocks = function() {
    return this.nbDatablocks;
  };
  AztecDetectorResult2.prototype.isCompact = function() {
    return this.compact;
  };
  return AztecDetectorResult2;
}(DetectorResult_default);
var AztecDetectorResult_default = AztecDetectorResult;

// node_modules/@zxing/library/esm/core/common/detector/WhiteRectangleDetector.js
var WhiteRectangleDetector = function() {
  function WhiteRectangleDetector2(image, initSize, x2, y) {
    this.image = image;
    this.height = image.getHeight();
    this.width = image.getWidth();
    if (initSize === void 0 || initSize === null) {
      initSize = WhiteRectangleDetector2.INIT_SIZE;
    }
    if (x2 === void 0 || x2 === null) {
      x2 = image.getWidth() / 2 | 0;
    }
    if (y === void 0 || y === null) {
      y = image.getHeight() / 2 | 0;
    }
    var halfsize = initSize / 2 | 0;
    this.leftInit = x2 - halfsize;
    this.rightInit = x2 + halfsize;
    this.upInit = y - halfsize;
    this.downInit = y + halfsize;
    if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
      throw new NotFoundException_default();
    }
  }
  WhiteRectangleDetector2.prototype.detect = function() {
    var left = this.leftInit;
    var right = this.rightInit;
    var up = this.upInit;
    var down = this.downInit;
    var sizeExceeded = false;
    var aBlackPointFoundOnBorder = true;
    var atLeastOneBlackPointFoundOnBorder = false;
    var atLeastOneBlackPointFoundOnRight = false;
    var atLeastOneBlackPointFoundOnBottom = false;
    var atLeastOneBlackPointFoundOnLeft = false;
    var atLeastOneBlackPointFoundOnTop = false;
    var width = this.width;
    var height = this.height;
    while (aBlackPointFoundOnBorder) {
      aBlackPointFoundOnBorder = false;
      var rightBorderNotWhite = true;
      while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
        rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
        if (rightBorderNotWhite) {
          right++;
          aBlackPointFoundOnBorder = true;
          atLeastOneBlackPointFoundOnRight = true;
        } else if (!atLeastOneBlackPointFoundOnRight) {
          right++;
        }
      }
      if (right >= width) {
        sizeExceeded = true;
        break;
      }
      var bottomBorderNotWhite = true;
      while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
        bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
        if (bottomBorderNotWhite) {
          down++;
          aBlackPointFoundOnBorder = true;
          atLeastOneBlackPointFoundOnBottom = true;
        } else if (!atLeastOneBlackPointFoundOnBottom) {
          down++;
        }
      }
      if (down >= height) {
        sizeExceeded = true;
        break;
      }
      var leftBorderNotWhite = true;
      while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
        leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
        if (leftBorderNotWhite) {
          left--;
          aBlackPointFoundOnBorder = true;
          atLeastOneBlackPointFoundOnLeft = true;
        } else if (!atLeastOneBlackPointFoundOnLeft) {
          left--;
        }
      }
      if (left < 0) {
        sizeExceeded = true;
        break;
      }
      var topBorderNotWhite = true;
      while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
        topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
        if (topBorderNotWhite) {
          up--;
          aBlackPointFoundOnBorder = true;
          atLeastOneBlackPointFoundOnTop = true;
        } else if (!atLeastOneBlackPointFoundOnTop) {
          up--;
        }
      }
      if (up < 0) {
        sizeExceeded = true;
        break;
      }
      if (aBlackPointFoundOnBorder) {
        atLeastOneBlackPointFoundOnBorder = true;
      }
    }
    if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
      var maxSize = right - left;
      var z = null;
      for (var i = 1; z === null && i < maxSize; i++) {
        z = this.getBlackPointOnSegment(left, down - i, left + i, down);
      }
      if (z == null) {
        throw new NotFoundException_default();
      }
      var t = null;
      for (var i = 1; t === null && i < maxSize; i++) {
        t = this.getBlackPointOnSegment(left, up + i, left + i, up);
      }
      if (t == null) {
        throw new NotFoundException_default();
      }
      var x2 = null;
      for (var i = 1; x2 === null && i < maxSize; i++) {
        x2 = this.getBlackPointOnSegment(right, up + i, right - i, up);
      }
      if (x2 == null) {
        throw new NotFoundException_default();
      }
      var y = null;
      for (var i = 1; y === null && i < maxSize; i++) {
        y = this.getBlackPointOnSegment(right, down - i, right - i, down);
      }
      if (y == null) {
        throw new NotFoundException_default();
      }
      return this.centerEdges(y, z, x2, t);
    } else {
      throw new NotFoundException_default();
    }
  };
  WhiteRectangleDetector2.prototype.getBlackPointOnSegment = function(aX, aY, bX, bY) {
    var dist = MathUtils_default.round(MathUtils_default.distance(aX, aY, bX, bY));
    var xStep = (bX - aX) / dist;
    var yStep = (bY - aY) / dist;
    var image = this.image;
    for (var i = 0; i < dist; i++) {
      var x2 = MathUtils_default.round(aX + i * xStep);
      var y = MathUtils_default.round(aY + i * yStep);
      if (image.get(x2, y)) {
        return new ResultPoint_default(x2, y);
      }
    }
    return null;
  };
  WhiteRectangleDetector2.prototype.centerEdges = function(y, z, x2, t) {
    var yi = y.getX();
    var yj = y.getY();
    var zi = z.getX();
    var zj = z.getY();
    var xi = x2.getX();
    var xj = x2.getY();
    var ti = t.getX();
    var tj = t.getY();
    var CORR = WhiteRectangleDetector2.CORR;
    if (yi < this.width / 2) {
      return [
        new ResultPoint_default(ti - CORR, tj + CORR),
        new ResultPoint_default(zi + CORR, zj + CORR),
        new ResultPoint_default(xi - CORR, xj - CORR),
        new ResultPoint_default(yi + CORR, yj - CORR)
      ];
    } else {
      return [
        new ResultPoint_default(ti + CORR, tj + CORR),
        new ResultPoint_default(zi + CORR, zj - CORR),
        new ResultPoint_default(xi - CORR, xj + CORR),
        new ResultPoint_default(yi - CORR, yj - CORR)
      ];
    }
  };
  WhiteRectangleDetector2.prototype.containsBlackPoint = function(a, b, fixed, horizontal) {
    var image = this.image;
    if (horizontal) {
      for (var x2 = a; x2 <= b; x2++) {
        if (image.get(x2, fixed)) {
          return true;
        }
      }
    } else {
      for (var y = a; y <= b; y++) {
        if (image.get(fixed, y)) {
          return true;
        }
      }
    }
    return false;
  };
  WhiteRectangleDetector2.INIT_SIZE = 10;
  WhiteRectangleDetector2.CORR = 1;
  return WhiteRectangleDetector2;
}();
var WhiteRectangleDetector_default = WhiteRectangleDetector;

// node_modules/@zxing/library/esm/core/common/GridSampler.js
var GridSampler = function() {
  function GridSampler2() {
  }
  GridSampler2.checkAndNudgePoints = function(image, points) {
    var width = image.getWidth();
    var height = image.getHeight();
    var nudged = true;
    for (var offset = 0; offset < points.length && nudged; offset += 2) {
      var x2 = Math.floor(points[offset]);
      var y = Math.floor(points[offset + 1]);
      if (x2 < -1 || x2 > width || y < -1 || y > height) {
        throw new NotFoundException_default();
      }
      nudged = false;
      if (x2 === -1) {
        points[offset] = 0;
        nudged = true;
      } else if (x2 === width) {
        points[offset] = width - 1;
        nudged = true;
      }
      if (y === -1) {
        points[offset + 1] = 0;
        nudged = true;
      } else if (y === height) {
        points[offset + 1] = height - 1;
        nudged = true;
      }
    }
    nudged = true;
    for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
      var x2 = Math.floor(points[offset]);
      var y = Math.floor(points[offset + 1]);
      if (x2 < -1 || x2 > width || y < -1 || y > height) {
        throw new NotFoundException_default();
      }
      nudged = false;
      if (x2 === -1) {
        points[offset] = 0;
        nudged = true;
      } else if (x2 === width) {
        points[offset] = width - 1;
        nudged = true;
      }
      if (y === -1) {
        points[offset + 1] = 0;
        nudged = true;
      } else if (y === height) {
        points[offset + 1] = height - 1;
        nudged = true;
      }
    }
  };
  return GridSampler2;
}();
var GridSampler_default = GridSampler;

// node_modules/@zxing/library/esm/core/common/PerspectiveTransform.js
var PerspectiveTransform = function() {
  function PerspectiveTransform2(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
    this.a11 = a11;
    this.a21 = a21;
    this.a31 = a31;
    this.a12 = a12;
    this.a22 = a22;
    this.a32 = a32;
    this.a13 = a13;
    this.a23 = a23;
    this.a33 = a33;
  }
  PerspectiveTransform2.quadrilateralToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
    var qToS = PerspectiveTransform2.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
    var sToQ = PerspectiveTransform2.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
    return sToQ.times(qToS);
  };
  PerspectiveTransform2.prototype.transformPoints = function(points) {
    var max = points.length;
    var a11 = this.a11;
    var a12 = this.a12;
    var a13 = this.a13;
    var a21 = this.a21;
    var a22 = this.a22;
    var a23 = this.a23;
    var a31 = this.a31;
    var a32 = this.a32;
    var a33 = this.a33;
    for (var i = 0; i < max; i += 2) {
      var x2 = points[i];
      var y = points[i + 1];
      var denominator = a13 * x2 + a23 * y + a33;
      points[i] = (a11 * x2 + a21 * y + a31) / denominator;
      points[i + 1] = (a12 * x2 + a22 * y + a32) / denominator;
    }
  };
  PerspectiveTransform2.prototype.transformPointsWithValues = function(xValues, yValues) {
    var a11 = this.a11;
    var a12 = this.a12;
    var a13 = this.a13;
    var a21 = this.a21;
    var a22 = this.a22;
    var a23 = this.a23;
    var a31 = this.a31;
    var a32 = this.a32;
    var a33 = this.a33;
    var n = xValues.length;
    for (var i = 0; i < n; i++) {
      var x2 = xValues[i];
      var y = yValues[i];
      var denominator = a13 * x2 + a23 * y + a33;
      xValues[i] = (a11 * x2 + a21 * y + a31) / denominator;
      yValues[i] = (a12 * x2 + a22 * y + a32) / denominator;
    }
  };
  PerspectiveTransform2.squareToQuadrilateral = function(x0, y0, x1, y1, x2, y2, x3, y3) {
    var dx3 = x0 - x1 + x2 - x3;
    var dy3 = y0 - y1 + y2 - y3;
    if (dx3 === 0 && dy3 === 0) {
      return new PerspectiveTransform2(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0, 0, 1);
    } else {
      var dx1 = x1 - x2;
      var dx2 = x3 - x2;
      var dy1 = y1 - y2;
      var dy2 = y3 - y2;
      var denominator = dx1 * dy2 - dx2 * dy1;
      var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
      var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
      return new PerspectiveTransform2(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1);
    }
  };
  PerspectiveTransform2.quadrilateralToSquare = function(x0, y0, x1, y1, x2, y2, x3, y3) {
    return PerspectiveTransform2.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
  };
  PerspectiveTransform2.prototype.buildAdjoint = function() {
    return new PerspectiveTransform2(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
  };
  PerspectiveTransform2.prototype.times = function(other) {
    return new PerspectiveTransform2(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
  };
  return PerspectiveTransform2;
}();
var PerspectiveTransform_default = PerspectiveTransform;

// node_modules/@zxing/library/esm/core/common/DefaultGridSampler.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DefaultGridSampler = function(_super) {
  __extends20(DefaultGridSampler2, _super);
  function DefaultGridSampler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DefaultGridSampler2.prototype.sampleGrid = function(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
    var transform = PerspectiveTransform_default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
    return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
  };
  DefaultGridSampler2.prototype.sampleGridWithTransform = function(image, dimensionX, dimensionY, transform) {
    if (dimensionX <= 0 || dimensionY <= 0) {
      throw new NotFoundException_default();
    }
    var bits = new BitMatrix_default(dimensionX, dimensionY);
    var points = new Float32Array(2 * dimensionX);
    for (var y = 0; y < dimensionY; y++) {
      var max = points.length;
      var iValue = y + 0.5;
      for (var x2 = 0; x2 < max; x2 += 2) {
        points[x2] = x2 / 2 + 0.5;
        points[x2 + 1] = iValue;
      }
      transform.transformPoints(points);
      GridSampler_default.checkAndNudgePoints(image, points);
      try {
        for (var x2 = 0; x2 < max; x2 += 2) {
          if (image.get(Math.floor(points[x2]), Math.floor(points[x2 + 1]))) {
            bits.set(x2 / 2, y);
          }
        }
      } catch (aioobe) {
        throw new NotFoundException_default();
      }
    }
    return bits;
  };
  return DefaultGridSampler2;
}(GridSampler_default);
var DefaultGridSampler_default = DefaultGridSampler;

// node_modules/@zxing/library/esm/core/common/GridSamplerInstance.js
var GridSamplerInstance = function() {
  function GridSamplerInstance2() {
  }
  GridSamplerInstance2.setGridSampler = function(newGridSampler) {
    GridSamplerInstance2.gridSampler = newGridSampler;
  };
  GridSamplerInstance2.getInstance = function() {
    return GridSamplerInstance2.gridSampler;
  };
  GridSamplerInstance2.gridSampler = new DefaultGridSampler_default();
  return GridSamplerInstance2;
}();
var GridSamplerInstance_default = GridSamplerInstance;

// node_modules/@zxing/library/esm/core/aztec/detector/Detector.js
var Point = function() {
  function Point2(x2, y) {
    this.x = x2;
    this.y = y;
  }
  Point2.prototype.toResultPoint = function() {
    return new ResultPoint_default(this.getX(), this.getY());
  };
  Point2.prototype.getX = function() {
    return this.x;
  };
  Point2.prototype.getY = function() {
    return this.y;
  };
  return Point2;
}();
var Detector = function() {
  function Detector5(image) {
    this.EXPECTED_CORNER_BITS = new Int32Array([
      3808,
      476,
      2107,
      1799
    ]);
    this.image = image;
  }
  Detector5.prototype.detect = function() {
    return this.detectMirror(false);
  };
  Detector5.prototype.detectMirror = function(isMirror) {
    var pCenter = this.getMatrixCenter();
    var bullsEyeCorners = this.getBullsEyeCorners(pCenter);
    if (isMirror) {
      var temp = bullsEyeCorners[0];
      bullsEyeCorners[0] = bullsEyeCorners[2];
      bullsEyeCorners[2] = temp;
    }
    this.extractParameters(bullsEyeCorners);
    var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
    var corners = this.getMatrixCornerPoints(bullsEyeCorners);
    return new AztecDetectorResult_default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
  };
  Detector5.prototype.extractParameters = function(bullsEyeCorners) {
    if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
      throw new NotFoundException_default();
    }
    var length = 2 * this.nbCenterLayers;
    var sides = new Int32Array([
      this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
      this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
      this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
      this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
    ]);
    this.shift = this.getRotation(sides, length);
    var parameterData = 0;
    for (var i = 0; i < 4; i++) {
      var side = sides[(this.shift + i) % 4];
      if (this.compact) {
        parameterData <<= 7;
        parameterData += side >> 1 & 127;
      } else {
        parameterData <<= 10;
        parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
      }
    }
    var correctedData = this.getCorrectedParameterData(parameterData, this.compact);
    if (this.compact) {
      this.nbLayers = (correctedData >> 6) + 1;
      this.nbDataBlocks = (correctedData & 63) + 1;
    } else {
      this.nbLayers = (correctedData >> 11) + 1;
      this.nbDataBlocks = (correctedData & 2047) + 1;
    }
  };
  Detector5.prototype.getRotation = function(sides, length) {
    var cornerBits = 0;
    sides.forEach(function(side, idx, arr) {
      var t = (side >> length - 2 << 1) + (side & 1);
      cornerBits = (cornerBits << 3) + t;
    });
    cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
    for (var shift = 0; shift < 4; shift++) {
      if (Integer_default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
        return shift;
      }
    }
    throw new NotFoundException_default();
  };
  Detector5.prototype.getCorrectedParameterData = function(parameterData, compact) {
    var numCodewords;
    var numDataCodewords;
    if (compact) {
      numCodewords = 7;
      numDataCodewords = 2;
    } else {
      numCodewords = 10;
      numDataCodewords = 4;
    }
    var numECCodewords = numCodewords - numDataCodewords;
    var parameterWords = new Int32Array(numCodewords);
    for (var i = numCodewords - 1; i >= 0; --i) {
      parameterWords[i] = parameterData & 15;
      parameterData >>= 4;
    }
    try {
      var rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.AZTEC_PARAM);
      rsDecoder.decode(parameterWords, numECCodewords);
    } catch (ignored) {
      throw new NotFoundException_default();
    }
    var result = 0;
    for (var i = 0; i < numDataCodewords; i++) {
      result = (result << 4) + parameterWords[i];
    }
    return result;
  };
  Detector5.prototype.getBullsEyeCorners = function(pCenter) {
    var pina = pCenter;
    var pinb = pCenter;
    var pinc = pCenter;
    var pind = pCenter;
    var color = true;
    for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
      var pouta = this.getFirstDifferent(pina, color, 1, -1);
      var poutb = this.getFirstDifferent(pinb, color, 1, 1);
      var poutc = this.getFirstDifferent(pinc, color, -1, 1);
      var poutd = this.getFirstDifferent(pind, color, -1, -1);
      if (this.nbCenterLayers > 2) {
        var q = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
        if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
          break;
        }
      }
      pina = pouta;
      pinb = poutb;
      pinc = poutc;
      pind = poutd;
      color = !color;
    }
    if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
      throw new NotFoundException_default();
    }
    this.compact = this.nbCenterLayers === 5;
    var pinax = new ResultPoint_default(pina.getX() + 0.5, pina.getY() - 0.5);
    var pinbx = new ResultPoint_default(pinb.getX() + 0.5, pinb.getY() + 0.5);
    var pincx = new ResultPoint_default(pinc.getX() - 0.5, pinc.getY() + 0.5);
    var pindx = new ResultPoint_default(pind.getX() - 0.5, pind.getY() - 0.5);
    return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
  };
  Detector5.prototype.getMatrixCenter = function() {
    var pointA;
    var pointB;
    var pointC;
    var pointD;
    try {
      var cornerPoints = new WhiteRectangleDetector_default(this.image).detect();
      pointA = cornerPoints[0];
      pointB = cornerPoints[1];
      pointC = cornerPoints[2];
      pointD = cornerPoints[3];
    } catch (e) {
      var cx_1 = this.image.getWidth() / 2;
      var cy_1 = this.image.getHeight() / 2;
      pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();
      pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();
      pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();
      pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();
    }
    var cx = MathUtils_default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
    var cy = MathUtils_default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
    try {
      var cornerPoints = new WhiteRectangleDetector_default(this.image, 15, cx, cy).detect();
      pointA = cornerPoints[0];
      pointB = cornerPoints[1];
      pointC = cornerPoints[2];
      pointD = cornerPoints[3];
    } catch (e) {
      pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
      pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
      pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
      pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
    }
    cx = MathUtils_default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
    cy = MathUtils_default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
    return new Point(cx, cy);
  };
  Detector5.prototype.getMatrixCornerPoints = function(bullsEyeCorners) {
    return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
  };
  Detector5.prototype.sampleGrid = function(image, topLeft, topRight, bottomRight, bottomLeft) {
    var sampler = GridSamplerInstance_default.getInstance();
    var dimension = this.getDimension();
    var low = dimension / 2 - this.nbCenterLayers;
    var high = dimension / 2 + this.nbCenterLayers;
    return sampler.sampleGrid(image, dimension, dimension, low, low, high, low, high, high, low, high, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
  };
  Detector5.prototype.sampleLine = function(p1, p2, size) {
    var result = 0;
    var d = this.distanceResultPoint(p1, p2);
    var moduleSize = d / size;
    var px = p1.getX();
    var py = p1.getY();
    var dx = moduleSize * (p2.getX() - p1.getX()) / d;
    var dy = moduleSize * (p2.getY() - p1.getY()) / d;
    for (var i = 0; i < size; i++) {
      if (this.image.get(MathUtils_default.round(px + i * dx), MathUtils_default.round(py + i * dy))) {
        result |= 1 << size - i - 1;
      }
    }
    return result;
  };
  Detector5.prototype.isWhiteOrBlackRectangle = function(p1, p2, p3, p4) {
    var corr = 3;
    p1 = new Point(p1.getX() - corr, p1.getY() + corr);
    p2 = new Point(p2.getX() - corr, p2.getY() - corr);
    p3 = new Point(p3.getX() + corr, p3.getY() - corr);
    p4 = new Point(p4.getX() + corr, p4.getY() + corr);
    var cInit = this.getColor(p4, p1);
    if (cInit === 0) {
      return false;
    }
    var c = this.getColor(p1, p2);
    if (c !== cInit) {
      return false;
    }
    c = this.getColor(p2, p3);
    if (c !== cInit) {
      return false;
    }
    c = this.getColor(p3, p4);
    return c === cInit;
  };
  Detector5.prototype.getColor = function(p1, p2) {
    var d = this.distancePoint(p1, p2);
    var dx = (p2.getX() - p1.getX()) / d;
    var dy = (p2.getY() - p1.getY()) / d;
    var error = 0;
    var px = p1.getX();
    var py = p1.getY();
    var colorModel = this.image.get(p1.getX(), p1.getY());
    var iMax = Math.ceil(d);
    for (var i = 0; i < iMax; i++) {
      px += dx;
      py += dy;
      if (this.image.get(MathUtils_default.round(px), MathUtils_default.round(py)) !== colorModel) {
        error++;
      }
    }
    var errRatio = error / d;
    if (errRatio > 0.1 && errRatio < 0.9) {
      return 0;
    }
    return errRatio <= 0.1 === colorModel ? 1 : -1;
  };
  Detector5.prototype.getFirstDifferent = function(init, color, dx, dy) {
    var x2 = init.getX() + dx;
    var y = init.getY() + dy;
    while (this.isValid(x2, y) && this.image.get(x2, y) === color) {
      x2 += dx;
      y += dy;
    }
    x2 -= dx;
    y -= dy;
    while (this.isValid(x2, y) && this.image.get(x2, y) === color) {
      x2 += dx;
    }
    x2 -= dx;
    while (this.isValid(x2, y) && this.image.get(x2, y) === color) {
      y += dy;
    }
    y -= dy;
    return new Point(x2, y);
  };
  Detector5.prototype.expandSquare = function(cornerPoints, oldSide, newSide) {
    var ratio = newSide / (2 * oldSide);
    var dx = cornerPoints[0].getX() - cornerPoints[2].getX();
    var dy = cornerPoints[0].getY() - cornerPoints[2].getY();
    var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
    var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
    var result0 = new ResultPoint_default(centerx + ratio * dx, centery + ratio * dy);
    var result2 = new ResultPoint_default(centerx - ratio * dx, centery - ratio * dy);
    dx = cornerPoints[1].getX() - cornerPoints[3].getX();
    dy = cornerPoints[1].getY() - cornerPoints[3].getY();
    centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
    centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
    var result1 = new ResultPoint_default(centerx + ratio * dx, centery + ratio * dy);
    var result3 = new ResultPoint_default(centerx - ratio * dx, centery - ratio * dy);
    var results = [result0, result1, result2, result3];
    return results;
  };
  Detector5.prototype.isValid = function(x2, y) {
    return x2 >= 0 && x2 < this.image.getWidth() && y > 0 && y < this.image.getHeight();
  };
  Detector5.prototype.isValidPoint = function(point) {
    var x2 = MathUtils_default.round(point.getX());
    var y = MathUtils_default.round(point.getY());
    return this.isValid(x2, y);
  };
  Detector5.prototype.distancePoint = function(a, b) {
    return MathUtils_default.distance(a.getX(), a.getY(), b.getX(), b.getY());
  };
  Detector5.prototype.distanceResultPoint = function(a, b) {
    return MathUtils_default.distance(a.getX(), a.getY(), b.getX(), b.getY());
  };
  Detector5.prototype.getDimension = function() {
    if (this.compact) {
      return 4 * this.nbLayers + 11;
    }
    if (this.nbLayers <= 4) {
      return 4 * this.nbLayers + 15;
    }
    return 4 * this.nbLayers + 2 * (Integer_default.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
  };
  return Detector5;
}();
var Detector_default = Detector;

// node_modules/@zxing/library/esm/core/aztec/AztecReader.js
var AztecReader = function() {
  function AztecReader2() {
  }
  AztecReader2.prototype.decode = function(image, hints) {
    if (hints === void 0) {
      hints = null;
    }
    var exception = null;
    var detector = new Detector_default(image.getBlackMatrix());
    var points = null;
    var decoderResult = null;
    try {
      var detectorResult = detector.detectMirror(false);
      points = detectorResult.getPoints();
      this.reportFoundResultPoints(hints, points);
      decoderResult = new Decoder_default().decode(detectorResult);
    } catch (e) {
      exception = e;
    }
    if (decoderResult == null) {
      try {
        var detectorResult = detector.detectMirror(true);
        points = detectorResult.getPoints();
        this.reportFoundResultPoints(hints, points);
        decoderResult = new Decoder_default().decode(detectorResult);
      } catch (e) {
        if (exception != null) {
          throw exception;
        }
        throw e;
      }
    }
    var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat_default.AZTEC, System_default.currentTimeMillis());
    var byteSegments = decoderResult.getByteSegments();
    if (byteSegments != null) {
      result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
    }
    var ecLevel = decoderResult.getECLevel();
    if (ecLevel != null) {
      result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
    }
    return result;
  };
  AztecReader2.prototype.reportFoundResultPoints = function(hints, points) {
    if (hints != null) {
      var rpcb_1 = hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
      if (rpcb_1 != null) {
        points.forEach(function(point, idx, arr) {
          rpcb_1.foundPossibleResultPoint(point);
        });
      }
    }
  };
  AztecReader2.prototype.reset = function() {
  };
  return AztecReader2;
}();
var AztecReader_default = AztecReader;

// node_modules/@zxing/library/esm/browser/BrowserAztecCodeReader.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserAztecCodeReader = function(_super) {
  __extends21(BrowserAztecCodeReader2, _super);
  function BrowserAztecCodeReader2(timeBetweenScansMillis) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    return _super.call(this, new AztecReader_default(), timeBetweenScansMillis) || this;
  }
  return BrowserAztecCodeReader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/core/oned/OneDReader.js
var OneDReader = function() {
  function OneDReader2() {
  }
  OneDReader2.prototype.decode = function(image, hints) {
    try {
      return this.doDecode(image, hints);
    } catch (nfe) {
      var tryHarder = hints && hints.get(DecodeHintType_default.TRY_HARDER) === true;
      if (tryHarder && image.isRotateSupported()) {
        var rotatedImage = image.rotateCounterClockwise();
        var result = this.doDecode(rotatedImage, hints);
        var metadata = result.getResultMetadata();
        var orientation_1 = 270;
        if (metadata !== null && metadata.get(ResultMetadataType_default.ORIENTATION) === true) {
          orientation_1 = orientation_1 + metadata.get(ResultMetadataType_default.ORIENTATION) % 360;
        }
        result.putMetadata(ResultMetadataType_default.ORIENTATION, orientation_1);
        var points = result.getResultPoints();
        if (points !== null) {
          var height = rotatedImage.getHeight();
          for (var i = 0; i < points.length; i++) {
            points[i] = new ResultPoint_default(height - points[i].getY() - 1, points[i].getX());
          }
        }
        return result;
      } else {
        throw new NotFoundException_default();
      }
    }
  };
  OneDReader2.prototype.reset = function() {
  };
  OneDReader2.prototype.doDecode = function(image, hints) {
    var width = image.getWidth();
    var height = image.getHeight();
    var row = new BitArray_default(width);
    var tryHarder = hints && hints.get(DecodeHintType_default.TRY_HARDER) === true;
    var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
    var maxLines;
    if (tryHarder) {
      maxLines = height;
    } else {
      maxLines = 15;
    }
    var middle = Math.trunc(height / 2);
    for (var x2 = 0; x2 < maxLines; x2++) {
      var rowStepsAboveOrBelow = Math.trunc((x2 + 1) / 2);
      var isAbove = (x2 & 1) === 0;
      var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
      if (rowNumber < 0 || rowNumber >= height) {
        break;
      }
      try {
        row = image.getBlackRow(rowNumber, row);
      } catch (ignored) {
        continue;
      }
      var _loop_1 = function(attempt2) {
        if (attempt2 === 1) {
          row.reverse();
          if (hints && hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK) === true) {
            var newHints_1 = new Map();
            hints.forEach(function(hint, key) {
              return newHints_1.set(key, hint);
            });
            newHints_1.delete(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
            hints = newHints_1;
          }
        }
        try {
          var result = this_1.decodeRow(rowNumber, row, hints);
          if (attempt2 === 1) {
            result.putMetadata(ResultMetadataType_default.ORIENTATION, 180);
            var points = result.getResultPoints();
            if (points !== null) {
              points[0] = new ResultPoint_default(width - points[0].getX() - 1, points[0].getY());
              points[1] = new ResultPoint_default(width - points[1].getX() - 1, points[1].getY());
            }
          }
          return {value: result};
        } catch (re) {
        }
      };
      var this_1 = this;
      for (var attempt = 0; attempt < 2; attempt++) {
        var state_1 = _loop_1(attempt);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    }
    throw new NotFoundException_default();
  };
  OneDReader2.recordPattern = function(row, start, counters) {
    var numCounters = counters.length;
    for (var index = 0; index < numCounters; index++)
      counters[index] = 0;
    var end = row.getSize();
    if (start >= end) {
      throw new NotFoundException_default();
    }
    var isWhite = !row.get(start);
    var counterPosition = 0;
    var i = start;
    while (i < end) {
      if (row.get(i) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (++counterPosition === numCounters) {
          break;
        } else {
          counters[counterPosition] = 1;
          isWhite = !isWhite;
        }
      }
      i++;
    }
    if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i === end)) {
      throw new NotFoundException_default();
    }
  };
  OneDReader2.recordPatternInReverse = function(row, start, counters) {
    var numTransitionsLeft = counters.length;
    var last = row.get(start);
    while (start > 0 && numTransitionsLeft >= 0) {
      if (row.get(--start) !== last) {
        numTransitionsLeft--;
        last = !last;
      }
    }
    if (numTransitionsLeft >= 0) {
      throw new NotFoundException_default();
    }
    OneDReader2.recordPattern(row, start + 1, counters);
  };
  OneDReader2.patternMatchVariance = function(counters, pattern, maxIndividualVariance) {
    var numCounters = counters.length;
    var total = 0;
    var patternLength = 0;
    for (var i = 0; i < numCounters; i++) {
      total += counters[i];
      patternLength += pattern[i];
    }
    if (total < patternLength) {
      return Number.POSITIVE_INFINITY;
    }
    var unitBarWidth = total / patternLength;
    maxIndividualVariance *= unitBarWidth;
    var totalVariance = 0;
    for (var x2 = 0; x2 < numCounters; x2++) {
      var counter = counters[x2];
      var scaledPattern = pattern[x2] * unitBarWidth;
      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
      if (variance > maxIndividualVariance) {
        return Number.POSITIVE_INFINITY;
      }
      totalVariance += variance;
    }
    return totalVariance / total;
  };
  return OneDReader2;
}();
var OneDReader_default = OneDReader;

// node_modules/@zxing/library/esm/core/oned/Code128Reader.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Code128Reader = function(_super) {
  __extends22(Code128Reader2, _super);
  function Code128Reader2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Code128Reader2.findStartPattern = function(row) {
    var width = row.getSize();
    var rowOffset = row.getNextSet(0);
    var counterPosition = 0;
    var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
    var patternStart = rowOffset;
    var isWhite = false;
    var patternLength = 6;
    for (var i = rowOffset; i < width; i++) {
      if (row.get(i) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === patternLength - 1) {
          var bestVariance = Code128Reader2.MAX_AVG_VARIANCE;
          var bestMatch = -1;
          for (var startCode = Code128Reader2.CODE_START_A; startCode <= Code128Reader2.CODE_START_C; startCode++) {
            var variance = OneDReader_default.patternMatchVariance(counters, Code128Reader2.CODE_PATTERNS[startCode], Code128Reader2.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
              bestVariance = variance;
              bestMatch = startCode;
            }
          }
          if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
            return Int32Array.from([patternStart, i, bestMatch]);
          }
          patternStart += counters[0] + counters[1];
          counters = counters.slice(2, counters.length - 1);
          counters[counterPosition - 1] = 0;
          counters[counterPosition] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  Code128Reader2.decodeCode = function(row, counters, rowOffset) {
    OneDReader_default.recordPattern(row, rowOffset, counters);
    var bestVariance = Code128Reader2.MAX_AVG_VARIANCE;
    var bestMatch = -1;
    for (var d = 0; d < Code128Reader2.CODE_PATTERNS.length; d++) {
      var pattern = Code128Reader2.CODE_PATTERNS[d];
      var variance = this.patternMatchVariance(counters, pattern, Code128Reader2.MAX_INDIVIDUAL_VARIANCE);
      if (variance < bestVariance) {
        bestVariance = variance;
        bestMatch = d;
      }
    }
    if (bestMatch >= 0) {
      return bestMatch;
    } else {
      throw new NotFoundException_default();
    }
  };
  Code128Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var convertFNC1 = hints && hints.get(DecodeHintType_default.ASSUME_GS1) === true;
    var startPatternInfo = Code128Reader2.findStartPattern(row);
    var startCode = startPatternInfo[2];
    var currentRawCodesIndex = 0;
    var rawCodes = new Uint8Array(20);
    rawCodes[currentRawCodesIndex++] = startCode;
    var codeSet;
    switch (startCode) {
      case Code128Reader2.CODE_START_A:
        codeSet = Code128Reader2.CODE_CODE_A;
        break;
      case Code128Reader2.CODE_START_B:
        codeSet = Code128Reader2.CODE_CODE_B;
        break;
      case Code128Reader2.CODE_START_C:
        codeSet = Code128Reader2.CODE_CODE_C;
        break;
      default:
        throw new FormatException_default();
    }
    var done = false;
    var isNextShifted = false;
    var result = "";
    var lastStart = startPatternInfo[0];
    var nextStart = startPatternInfo[1];
    var counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
    var lastCode = 0;
    var code = 0;
    var checksumTotal = startCode;
    var multiplier = 0;
    var lastCharacterWasPrintable = true;
    var upperMode = false;
    var shiftUpperMode = false;
    while (!done) {
      var unshift = isNextShifted;
      isNextShifted = false;
      lastCode = code;
      code = Code128Reader2.decodeCode(row, counters, nextStart);
      rawCodes[currentRawCodesIndex++] = code;
      if (code !== Code128Reader2.CODE_STOP) {
        lastCharacterWasPrintable = true;
      }
      if (code !== Code128Reader2.CODE_STOP) {
        multiplier++;
        checksumTotal += multiplier * code;
      }
      lastStart = nextStart;
      nextStart += counters.reduce(function(previous, current) {
        return previous + current;
      }, 0);
      switch (code) {
        case Code128Reader2.CODE_START_A:
        case Code128Reader2.CODE_START_B:
        case Code128Reader2.CODE_START_C:
          throw new FormatException_default();
      }
      switch (codeSet) {
        case Code128Reader2.CODE_CODE_A:
          if (code < 64) {
            if (shiftUpperMode === upperMode) {
              result += String.fromCharCode(" ".charCodeAt(0) + code);
            } else {
              result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
            }
            shiftUpperMode = false;
          } else if (code < 96) {
            if (shiftUpperMode === upperMode) {
              result += String.fromCharCode(code - 64);
            } else {
              result += String.fromCharCode(code + 64);
            }
            shiftUpperMode = false;
          } else {
            if (code !== Code128Reader2.CODE_STOP) {
              lastCharacterWasPrintable = false;
            }
            switch (code) {
              case Code128Reader2.CODE_FNC_1:
                if (convertFNC1) {
                  if (result.length === 0) {
                    result += "]C1";
                  } else {
                    result += String.fromCharCode(29);
                  }
                }
                break;
              case Code128Reader2.CODE_FNC_2:
              case Code128Reader2.CODE_FNC_3:
                break;
              case Code128Reader2.CODE_FNC_4_A:
                if (!upperMode && shiftUpperMode) {
                  upperMode = true;
                  shiftUpperMode = false;
                } else if (upperMode && shiftUpperMode) {
                  upperMode = false;
                  shiftUpperMode = false;
                } else {
                  shiftUpperMode = true;
                }
                break;
              case Code128Reader2.CODE_SHIFT:
                isNextShifted = true;
                codeSet = Code128Reader2.CODE_CODE_B;
                break;
              case Code128Reader2.CODE_CODE_B:
                codeSet = Code128Reader2.CODE_CODE_B;
                break;
              case Code128Reader2.CODE_CODE_C:
                codeSet = Code128Reader2.CODE_CODE_C;
                break;
              case Code128Reader2.CODE_STOP:
                done = true;
                break;
            }
          }
          break;
        case Code128Reader2.CODE_CODE_B:
          if (code < 96) {
            if (shiftUpperMode === upperMode) {
              result += String.fromCharCode(" ".charCodeAt(0) + code);
            } else {
              result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
            }
            shiftUpperMode = false;
          } else {
            if (code !== Code128Reader2.CODE_STOP) {
              lastCharacterWasPrintable = false;
            }
            switch (code) {
              case Code128Reader2.CODE_FNC_1:
                if (convertFNC1) {
                  if (result.length === 0) {
                    result += "]C1";
                  } else {
                    result += String.fromCharCode(29);
                  }
                }
                break;
              case Code128Reader2.CODE_FNC_2:
              case Code128Reader2.CODE_FNC_3:
                break;
              case Code128Reader2.CODE_FNC_4_B:
                if (!upperMode && shiftUpperMode) {
                  upperMode = true;
                  shiftUpperMode = false;
                } else if (upperMode && shiftUpperMode) {
                  upperMode = false;
                  shiftUpperMode = false;
                } else {
                  shiftUpperMode = true;
                }
                break;
              case Code128Reader2.CODE_SHIFT:
                isNextShifted = true;
                codeSet = Code128Reader2.CODE_CODE_A;
                break;
              case Code128Reader2.CODE_CODE_A:
                codeSet = Code128Reader2.CODE_CODE_A;
                break;
              case Code128Reader2.CODE_CODE_C:
                codeSet = Code128Reader2.CODE_CODE_C;
                break;
              case Code128Reader2.CODE_STOP:
                done = true;
                break;
            }
          }
          break;
        case Code128Reader2.CODE_CODE_C:
          if (code < 100) {
            if (code < 10) {
              result += "0";
            }
            result += code;
          } else {
            if (code !== Code128Reader2.CODE_STOP) {
              lastCharacterWasPrintable = false;
            }
            switch (code) {
              case Code128Reader2.CODE_FNC_1:
                if (convertFNC1) {
                  if (result.length === 0) {
                    result += "]C1";
                  } else {
                    result += String.fromCharCode(29);
                  }
                }
                break;
              case Code128Reader2.CODE_CODE_A:
                codeSet = Code128Reader2.CODE_CODE_A;
                break;
              case Code128Reader2.CODE_CODE_B:
                codeSet = Code128Reader2.CODE_CODE_B;
                break;
              case Code128Reader2.CODE_STOP:
                done = true;
                break;
            }
          }
          break;
      }
      if (unshift) {
        codeSet = codeSet === Code128Reader2.CODE_CODE_A ? Code128Reader2.CODE_CODE_B : Code128Reader2.CODE_CODE_A;
      }
    }
    var lastPatternSize = nextStart - lastStart;
    nextStart = row.getNextUnset(nextStart);
    if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
      throw new NotFoundException_default();
    }
    checksumTotal -= multiplier * lastCode;
    if (checksumTotal % 103 !== lastCode) {
      throw new ChecksumException_default();
    }
    var resultLength = result.length;
    if (resultLength === 0) {
      throw new NotFoundException_default();
    }
    if (resultLength > 0 && lastCharacterWasPrintable) {
      if (codeSet === Code128Reader2.CODE_CODE_C) {
        result = result.substring(0, resultLength - 2);
      } else {
        result = result.substring(0, resultLength - 1);
      }
    }
    var left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
    var right = lastStart + lastPatternSize / 2;
    var rawCodesSize = rawCodes.length;
    var rawBytes = new Uint8Array(rawCodesSize);
    for (var i = 0; i < rawCodesSize; i++) {
      rawBytes[i] = rawCodes[i];
    }
    var points = [new ResultPoint_default(left, rowNumber), new ResultPoint_default(right, rowNumber)];
    return new Result_default(result, rawBytes, 0, points, BarcodeFormat_default.CODE_128, new Date().getTime());
  };
  Code128Reader2.CODE_PATTERNS = [
    Int32Array.from([2, 1, 2, 2, 2, 2]),
    Int32Array.from([2, 2, 2, 1, 2, 2]),
    Int32Array.from([2, 2, 2, 2, 2, 1]),
    Int32Array.from([1, 2, 1, 2, 2, 3]),
    Int32Array.from([1, 2, 1, 3, 2, 2]),
    Int32Array.from([1, 3, 1, 2, 2, 2]),
    Int32Array.from([1, 2, 2, 2, 1, 3]),
    Int32Array.from([1, 2, 2, 3, 1, 2]),
    Int32Array.from([1, 3, 2, 2, 1, 2]),
    Int32Array.from([2, 2, 1, 2, 1, 3]),
    Int32Array.from([2, 2, 1, 3, 1, 2]),
    Int32Array.from([2, 3, 1, 2, 1, 2]),
    Int32Array.from([1, 1, 2, 2, 3, 2]),
    Int32Array.from([1, 2, 2, 1, 3, 2]),
    Int32Array.from([1, 2, 2, 2, 3, 1]),
    Int32Array.from([1, 1, 3, 2, 2, 2]),
    Int32Array.from([1, 2, 3, 1, 2, 2]),
    Int32Array.from([1, 2, 3, 2, 2, 1]),
    Int32Array.from([2, 2, 3, 2, 1, 1]),
    Int32Array.from([2, 2, 1, 1, 3, 2]),
    Int32Array.from([2, 2, 1, 2, 3, 1]),
    Int32Array.from([2, 1, 3, 2, 1, 2]),
    Int32Array.from([2, 2, 3, 1, 1, 2]),
    Int32Array.from([3, 1, 2, 1, 3, 1]),
    Int32Array.from([3, 1, 1, 2, 2, 2]),
    Int32Array.from([3, 2, 1, 1, 2, 2]),
    Int32Array.from([3, 2, 1, 2, 2, 1]),
    Int32Array.from([3, 1, 2, 2, 1, 2]),
    Int32Array.from([3, 2, 2, 1, 1, 2]),
    Int32Array.from([3, 2, 2, 2, 1, 1]),
    Int32Array.from([2, 1, 2, 1, 2, 3]),
    Int32Array.from([2, 1, 2, 3, 2, 1]),
    Int32Array.from([2, 3, 2, 1, 2, 1]),
    Int32Array.from([1, 1, 1, 3, 2, 3]),
    Int32Array.from([1, 3, 1, 1, 2, 3]),
    Int32Array.from([1, 3, 1, 3, 2, 1]),
    Int32Array.from([1, 1, 2, 3, 1, 3]),
    Int32Array.from([1, 3, 2, 1, 1, 3]),
    Int32Array.from([1, 3, 2, 3, 1, 1]),
    Int32Array.from([2, 1, 1, 3, 1, 3]),
    Int32Array.from([2, 3, 1, 1, 1, 3]),
    Int32Array.from([2, 3, 1, 3, 1, 1]),
    Int32Array.from([1, 1, 2, 1, 3, 3]),
    Int32Array.from([1, 1, 2, 3, 3, 1]),
    Int32Array.from([1, 3, 2, 1, 3, 1]),
    Int32Array.from([1, 1, 3, 1, 2, 3]),
    Int32Array.from([1, 1, 3, 3, 2, 1]),
    Int32Array.from([1, 3, 3, 1, 2, 1]),
    Int32Array.from([3, 1, 3, 1, 2, 1]),
    Int32Array.from([2, 1, 1, 3, 3, 1]),
    Int32Array.from([2, 3, 1, 1, 3, 1]),
    Int32Array.from([2, 1, 3, 1, 1, 3]),
    Int32Array.from([2, 1, 3, 3, 1, 1]),
    Int32Array.from([2, 1, 3, 1, 3, 1]),
    Int32Array.from([3, 1, 1, 1, 2, 3]),
    Int32Array.from([3, 1, 1, 3, 2, 1]),
    Int32Array.from([3, 3, 1, 1, 2, 1]),
    Int32Array.from([3, 1, 2, 1, 1, 3]),
    Int32Array.from([3, 1, 2, 3, 1, 1]),
    Int32Array.from([3, 3, 2, 1, 1, 1]),
    Int32Array.from([3, 1, 4, 1, 1, 1]),
    Int32Array.from([2, 2, 1, 4, 1, 1]),
    Int32Array.from([4, 3, 1, 1, 1, 1]),
    Int32Array.from([1, 1, 1, 2, 2, 4]),
    Int32Array.from([1, 1, 1, 4, 2, 2]),
    Int32Array.from([1, 2, 1, 1, 2, 4]),
    Int32Array.from([1, 2, 1, 4, 2, 1]),
    Int32Array.from([1, 4, 1, 1, 2, 2]),
    Int32Array.from([1, 4, 1, 2, 2, 1]),
    Int32Array.from([1, 1, 2, 2, 1, 4]),
    Int32Array.from([1, 1, 2, 4, 1, 2]),
    Int32Array.from([1, 2, 2, 1, 1, 4]),
    Int32Array.from([1, 2, 2, 4, 1, 1]),
    Int32Array.from([1, 4, 2, 1, 1, 2]),
    Int32Array.from([1, 4, 2, 2, 1, 1]),
    Int32Array.from([2, 4, 1, 2, 1, 1]),
    Int32Array.from([2, 2, 1, 1, 1, 4]),
    Int32Array.from([4, 1, 3, 1, 1, 1]),
    Int32Array.from([2, 4, 1, 1, 1, 2]),
    Int32Array.from([1, 3, 4, 1, 1, 1]),
    Int32Array.from([1, 1, 1, 2, 4, 2]),
    Int32Array.from([1, 2, 1, 1, 4, 2]),
    Int32Array.from([1, 2, 1, 2, 4, 1]),
    Int32Array.from([1, 1, 4, 2, 1, 2]),
    Int32Array.from([1, 2, 4, 1, 1, 2]),
    Int32Array.from([1, 2, 4, 2, 1, 1]),
    Int32Array.from([4, 1, 1, 2, 1, 2]),
    Int32Array.from([4, 2, 1, 1, 1, 2]),
    Int32Array.from([4, 2, 1, 2, 1, 1]),
    Int32Array.from([2, 1, 2, 1, 4, 1]),
    Int32Array.from([2, 1, 4, 1, 2, 1]),
    Int32Array.from([4, 1, 2, 1, 2, 1]),
    Int32Array.from([1, 1, 1, 1, 4, 3]),
    Int32Array.from([1, 1, 1, 3, 4, 1]),
    Int32Array.from([1, 3, 1, 1, 4, 1]),
    Int32Array.from([1, 1, 4, 1, 1, 3]),
    Int32Array.from([1, 1, 4, 3, 1, 1]),
    Int32Array.from([4, 1, 1, 1, 1, 3]),
    Int32Array.from([4, 1, 1, 3, 1, 1]),
    Int32Array.from([1, 1, 3, 1, 4, 1]),
    Int32Array.from([1, 1, 4, 1, 3, 1]),
    Int32Array.from([3, 1, 1, 1, 4, 1]),
    Int32Array.from([4, 1, 1, 1, 3, 1]),
    Int32Array.from([2, 1, 1, 4, 1, 2]),
    Int32Array.from([2, 1, 1, 2, 1, 4]),
    Int32Array.from([2, 1, 1, 2, 3, 2]),
    Int32Array.from([2, 3, 3, 1, 1, 1, 2])
  ];
  Code128Reader2.MAX_AVG_VARIANCE = 0.25;
  Code128Reader2.MAX_INDIVIDUAL_VARIANCE = 0.7;
  Code128Reader2.CODE_SHIFT = 98;
  Code128Reader2.CODE_CODE_C = 99;
  Code128Reader2.CODE_CODE_B = 100;
  Code128Reader2.CODE_CODE_A = 101;
  Code128Reader2.CODE_FNC_1 = 102;
  Code128Reader2.CODE_FNC_2 = 97;
  Code128Reader2.CODE_FNC_3 = 96;
  Code128Reader2.CODE_FNC_4_A = 101;
  Code128Reader2.CODE_FNC_4_B = 100;
  Code128Reader2.CODE_START_A = 103;
  Code128Reader2.CODE_START_B = 104;
  Code128Reader2.CODE_START_C = 105;
  Code128Reader2.CODE_STOP = 106;
  return Code128Reader2;
}(OneDReader_default);
var Code128Reader_default = Code128Reader;

// node_modules/@zxing/library/esm/core/oned/Code39Reader.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values4 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Code39Reader = function(_super) {
  __extends23(Code39Reader2, _super);
  function Code39Reader2(usingCheckDigit, extendedMode) {
    if (usingCheckDigit === void 0) {
      usingCheckDigit = false;
    }
    if (extendedMode === void 0) {
      extendedMode = false;
    }
    var _this = _super.call(this) || this;
    _this.usingCheckDigit = usingCheckDigit;
    _this.extendedMode = extendedMode;
    _this.decodeRowResult = "";
    _this.counters = new Int32Array(9);
    return _this;
  }
  Code39Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var e_1, _a, e_2, _b;
    var theCounters = this.counters;
    theCounters.fill(0);
    this.decodeRowResult = "";
    var start = Code39Reader2.findAsteriskPattern(row, theCounters);
    var nextStart = row.getNextSet(start[1]);
    var end = row.getSize();
    var decodedChar;
    var lastStart;
    do {
      Code39Reader2.recordPattern(row, nextStart, theCounters);
      var pattern = Code39Reader2.toNarrowWidePattern(theCounters);
      if (pattern < 0) {
        throw new NotFoundException_default();
      }
      decodedChar = Code39Reader2.patternToChar(pattern);
      this.decodeRowResult += decodedChar;
      lastStart = nextStart;
      try {
        for (var theCounters_1 = (e_1 = void 0, __values4(theCounters)), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {
          var counter = theCounters_1_1.value;
          nextStart += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return))
            _a.call(theCounters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      nextStart = row.getNextSet(nextStart);
    } while (decodedChar !== "*");
    this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
    var lastPatternSize = 0;
    try {
      for (var theCounters_2 = __values4(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {
        var counter = theCounters_2_1.value;
        lastPatternSize += counter;
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return))
          _b.call(theCounters_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
    if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
      throw new NotFoundException_default();
    }
    if (this.usingCheckDigit) {
      var max = this.decodeRowResult.length - 1;
      var total = 0;
      for (var i = 0; i < max; i++) {
        total += Code39Reader2.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
      }
      if (this.decodeRowResult.charAt(max) !== Code39Reader2.ALPHABET_STRING.charAt(total % 43)) {
        throw new ChecksumException_default();
      }
      this.decodeRowResult = this.decodeRowResult.substring(0, max);
    }
    if (this.decodeRowResult.length === 0) {
      throw new NotFoundException_default();
    }
    var resultString;
    if (this.extendedMode) {
      resultString = Code39Reader2.decodeExtended(this.decodeRowResult);
    } else {
      resultString = this.decodeRowResult;
    }
    var left = (start[1] + start[0]) / 2;
    var right = lastStart + lastPatternSize / 2;
    return new Result_default(resultString, null, 0, [new ResultPoint_default(left, rowNumber), new ResultPoint_default(right, rowNumber)], BarcodeFormat_default.CODE_39, new Date().getTime());
  };
  Code39Reader2.findAsteriskPattern = function(row, counters) {
    var width = row.getSize();
    var rowOffset = row.getNextSet(0);
    var counterPosition = 0;
    var patternStart = rowOffset;
    var isWhite = false;
    var patternLength = counters.length;
    for (var i = rowOffset; i < width; i++) {
      if (row.get(i) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === patternLength - 1) {
          if (this.toNarrowWidePattern(counters) === Code39Reader2.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
            return [patternStart, i];
          }
          patternStart += counters[0] + counters[1];
          counters.copyWithin(0, 2, 2 + counterPosition - 1);
          counters[counterPosition - 1] = 0;
          counters[counterPosition] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  Code39Reader2.toNarrowWidePattern = function(counters) {
    var e_3, _a;
    var numCounters = counters.length;
    var maxNarrowCounter = 0;
    var wideCounters;
    do {
      var minCounter = 2147483647;
      try {
        for (var counters_1 = (e_3 = void 0, __values4(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          if (counter < minCounter && counter > maxNarrowCounter) {
            minCounter = counter;
          }
        }
      } catch (e_3_1) {
        e_3 = {error: e_3_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      maxNarrowCounter = minCounter;
      wideCounters = 0;
      var totalWideCountersWidth = 0;
      var pattern = 0;
      for (var i = 0; i < numCounters; i++) {
        var counter = counters[i];
        if (counter > maxNarrowCounter) {
          pattern |= 1 << numCounters - 1 - i;
          wideCounters++;
          totalWideCountersWidth += counter;
        }
      }
      if (wideCounters === 3) {
        for (var i = 0; i < numCounters && wideCounters > 0; i++) {
          var counter = counters[i];
          if (counter > maxNarrowCounter) {
            wideCounters--;
            if (counter * 2 >= totalWideCountersWidth) {
              return -1;
            }
          }
        }
        return pattern;
      }
    } while (wideCounters > 3);
    return -1;
  };
  Code39Reader2.patternToChar = function(pattern) {
    for (var i = 0; i < Code39Reader2.CHARACTER_ENCODINGS.length; i++) {
      if (Code39Reader2.CHARACTER_ENCODINGS[i] === pattern) {
        return Code39Reader2.ALPHABET_STRING.charAt(i);
      }
    }
    if (pattern === Code39Reader2.ASTERISK_ENCODING) {
      return "*";
    }
    throw new NotFoundException_default();
  };
  Code39Reader2.decodeExtended = function(encoded) {
    var length = encoded.length;
    var decoded = "";
    for (var i = 0; i < length; i++) {
      var c = encoded.charAt(i);
      if (c === "+" || c === "$" || c === "%" || c === "/") {
        var next = encoded.charAt(i + 1);
        var decodedChar = "\0";
        switch (c) {
          case "+":
            if (next >= "A" && next <= "Z") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
            } else {
              throw new FormatException_default();
            }
            break;
          case "$":
            if (next >= "A" && next <= "Z") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
            } else {
              throw new FormatException_default();
            }
            break;
          case "%":
            if (next >= "A" && next <= "E") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
            } else if (next >= "F" && next <= "J") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
            } else if (next >= "K" && next <= "O") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
            } else if (next >= "P" && next <= "T") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
            } else if (next === "U") {
              decodedChar = "\0";
            } else if (next === "V") {
              decodedChar = "@";
            } else if (next === "W") {
              decodedChar = "`";
            } else if (next === "X" || next === "Y" || next === "Z") {
              decodedChar = "\x7F";
            } else {
              throw new FormatException_default();
            }
            break;
          case "/":
            if (next >= "A" && next <= "O") {
              decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
            } else if (next === "Z") {
              decodedChar = ":";
            } else {
              throw new FormatException_default();
            }
            break;
        }
        decoded += decodedChar;
        i++;
      } else {
        decoded += c;
      }
    }
    return decoded;
  };
  Code39Reader2.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
  Code39Reader2.CHARACTER_ENCODINGS = [
    52,
    289,
    97,
    352,
    49,
    304,
    112,
    37,
    292,
    100,
    265,
    73,
    328,
    25,
    280,
    88,
    13,
    268,
    76,
    28,
    259,
    67,
    322,
    19,
    274,
    82,
    7,
    262,
    70,
    22,
    385,
    193,
    448,
    145,
    400,
    208,
    133,
    388,
    196,
    168,
    162,
    138,
    42
  ];
  Code39Reader2.ASTERISK_ENCODING = 148;
  return Code39Reader2;
}(OneDReader_default);
var Code39Reader_default = Code39Reader;

// node_modules/@zxing/library/esm/core/oned/ITFReader.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values5 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ITFReader = function(_super) {
  __extends24(ITFReader2, _super);
  function ITFReader2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.narrowLineWidth = -1;
    return _this;
  }
  ITFReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var e_1, _a;
    var startRange = this.decodeStart(row);
    var endRange = this.decodeEnd(row);
    var result = new StringBuilder_default();
    ITFReader2.decodeMiddle(row, startRange[1], endRange[0], result);
    var resultString = result.toString();
    var allowedLengths = null;
    if (hints != null) {
      allowedLengths = hints.get(DecodeHintType_default.ALLOWED_LENGTHS);
    }
    if (allowedLengths == null) {
      allowedLengths = ITFReader2.DEFAULT_ALLOWED_LENGTHS;
    }
    var length = resultString.length;
    var lengthOK = false;
    var maxAllowedLength = 0;
    try {
      for (var allowedLengths_1 = __values5(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {
        var value = allowedLengths_1_1.value;
        if (length === value) {
          lengthOK = true;
          break;
        }
        if (value > maxAllowedLength) {
          maxAllowedLength = value;
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return))
          _a.call(allowedLengths_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (!lengthOK && length > maxAllowedLength) {
      lengthOK = true;
    }
    if (!lengthOK) {
      throw new FormatException_default();
    }
    var points = [new ResultPoint_default(startRange[1], rowNumber), new ResultPoint_default(endRange[0], rowNumber)];
    var resultReturn = new Result_default(resultString, null, 0, points, BarcodeFormat_default.ITF, new Date().getTime());
    return resultReturn;
  };
  ITFReader2.decodeMiddle = function(row, payloadStart, payloadEnd, resultString) {
    var counterDigitPair = new Int32Array(10);
    var counterBlack = new Int32Array(5);
    var counterWhite = new Int32Array(5);
    counterDigitPair.fill(0);
    counterBlack.fill(0);
    counterWhite.fill(0);
    while (payloadStart < payloadEnd) {
      OneDReader_default.recordPattern(row, payloadStart, counterDigitPair);
      for (var k = 0; k < 5; k++) {
        var twoK = 2 * k;
        counterBlack[k] = counterDigitPair[twoK];
        counterWhite[k] = counterDigitPair[twoK + 1];
      }
      var bestMatch = ITFReader2.decodeDigit(counterBlack);
      resultString.append(bestMatch.toString());
      bestMatch = this.decodeDigit(counterWhite);
      resultString.append(bestMatch.toString());
      counterDigitPair.forEach(function(counterDigit) {
        payloadStart += counterDigit;
      });
    }
  };
  ITFReader2.prototype.decodeStart = function(row) {
    var endStart = ITFReader2.skipWhiteSpace(row);
    var startPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.START_PATTERN);
    this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
    this.validateQuietZone(row, startPattern[0]);
    return startPattern;
  };
  ITFReader2.prototype.validateQuietZone = function(row, startPattern) {
    var quietCount = this.narrowLineWidth * 10;
    quietCount = quietCount < startPattern ? quietCount : startPattern;
    for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
      if (row.get(i)) {
        break;
      }
      quietCount--;
    }
    if (quietCount !== 0) {
      throw new NotFoundException_default();
    }
  };
  ITFReader2.skipWhiteSpace = function(row) {
    var width = row.getSize();
    var endStart = row.getNextSet(0);
    if (endStart === width) {
      throw new NotFoundException_default();
    }
    return endStart;
  };
  ITFReader2.prototype.decodeEnd = function(row) {
    row.reverse();
    try {
      var endStart = ITFReader2.skipWhiteSpace(row);
      var endPattern = void 0;
      try {
        endPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.END_PATTERN_REVERSED[0]);
      } catch (error) {
        if (error instanceof NotFoundException_default) {
          endPattern = ITFReader2.findGuardPattern(row, endStart, ITFReader2.END_PATTERN_REVERSED[1]);
        }
      }
      this.validateQuietZone(row, endPattern[0]);
      var temp = endPattern[0];
      endPattern[0] = row.getSize() - endPattern[1];
      endPattern[1] = row.getSize() - temp;
      return endPattern;
    } finally {
      row.reverse();
    }
  };
  ITFReader2.findGuardPattern = function(row, rowOffset, pattern) {
    var patternLength = pattern.length;
    var counters = new Int32Array(patternLength);
    var width = row.getSize();
    var isWhite = false;
    var counterPosition = 0;
    var patternStart = rowOffset;
    counters.fill(0);
    for (var x2 = rowOffset; x2 < width; x2++) {
      if (row.get(x2) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === patternLength - 1) {
          if (OneDReader_default.patternMatchVariance(counters, pattern, ITFReader2.MAX_INDIVIDUAL_VARIANCE) < ITFReader2.MAX_AVG_VARIANCE) {
            return [patternStart, x2];
          }
          patternStart += counters[0] + counters[1];
          System_default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
          counters[counterPosition - 1] = 0;
          counters[counterPosition] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  ITFReader2.decodeDigit = function(counters) {
    var bestVariance = ITFReader2.MAX_AVG_VARIANCE;
    var bestMatch = -1;
    var max = ITFReader2.PATTERNS.length;
    for (var i = 0; i < max; i++) {
      var pattern = ITFReader2.PATTERNS[i];
      var variance = OneDReader_default.patternMatchVariance(counters, pattern, ITFReader2.MAX_INDIVIDUAL_VARIANCE);
      if (variance < bestVariance) {
        bestVariance = variance;
        bestMatch = i;
      } else if (variance === bestVariance) {
        bestMatch = -1;
      }
    }
    if (bestMatch >= 0) {
      return bestMatch % 10;
    } else {
      throw new NotFoundException_default();
    }
  };
  ITFReader2.PATTERNS = [
    Int32Array.from([1, 1, 2, 2, 1]),
    Int32Array.from([2, 1, 1, 1, 2]),
    Int32Array.from([1, 2, 1, 1, 2]),
    Int32Array.from([2, 2, 1, 1, 1]),
    Int32Array.from([1, 1, 2, 1, 2]),
    Int32Array.from([2, 1, 2, 1, 1]),
    Int32Array.from([1, 2, 2, 1, 1]),
    Int32Array.from([1, 1, 1, 2, 2]),
    Int32Array.from([2, 1, 1, 2, 1]),
    Int32Array.from([1, 2, 1, 2, 1]),
    Int32Array.from([1, 1, 3, 3, 1]),
    Int32Array.from([3, 1, 1, 1, 3]),
    Int32Array.from([1, 3, 1, 1, 3]),
    Int32Array.from([3, 3, 1, 1, 1]),
    Int32Array.from([1, 1, 3, 1, 3]),
    Int32Array.from([3, 1, 3, 1, 1]),
    Int32Array.from([1, 3, 3, 1, 1]),
    Int32Array.from([1, 1, 1, 3, 3]),
    Int32Array.from([3, 1, 1, 3, 1]),
    Int32Array.from([1, 3, 1, 3, 1])
  ];
  ITFReader2.MAX_AVG_VARIANCE = 0.38;
  ITFReader2.MAX_INDIVIDUAL_VARIANCE = 0.5;
  ITFReader2.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
  ITFReader2.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
  ITFReader2.END_PATTERN_REVERSED = [
    Int32Array.from([1, 1, 2]),
    Int32Array.from([1, 1, 3])
  ];
  return ITFReader2;
}(OneDReader_default);
var ITFReader_default = ITFReader;

// node_modules/@zxing/library/esm/core/oned/AbstractUPCEANReader.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AbstractUPCEANReader = function(_super) {
  __extends25(AbstractUPCEANReader2, _super);
  function AbstractUPCEANReader2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.decodeRowStringBuffer = "";
    return _this;
  }
  AbstractUPCEANReader2.findStartGuardPattern = function(row) {
    var foundStart = false;
    var startRange;
    var nextStart = 0;
    var counters = Int32Array.from([0, 0, 0]);
    while (!foundStart) {
      counters = Int32Array.from([0, 0, 0]);
      startRange = AbstractUPCEANReader2.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
      var start = startRange[0];
      nextStart = startRange[1];
      var quietStart = start - (nextStart - start);
      if (quietStart >= 0) {
        foundStart = row.isRange(quietStart, start, false);
      }
    }
    return startRange;
  };
  AbstractUPCEANReader2.checkChecksum = function(s) {
    return AbstractUPCEANReader2.checkStandardUPCEANChecksum(s);
  };
  AbstractUPCEANReader2.checkStandardUPCEANChecksum = function(s) {
    var length = s.length;
    if (length === 0)
      return false;
    var check = parseInt(s.charAt(length - 1), 10);
    return AbstractUPCEANReader2.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
  };
  AbstractUPCEANReader2.getStandardUPCEANChecksum = function(s) {
    var length = s.length;
    var sum = 0;
    for (var i = length - 1; i >= 0; i -= 2) {
      var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
      if (digit < 0 || digit > 9) {
        throw new FormatException_default();
      }
      sum += digit;
    }
    sum *= 3;
    for (var i = length - 2; i >= 0; i -= 2) {
      var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
      if (digit < 0 || digit > 9) {
        throw new FormatException_default();
      }
      sum += digit;
    }
    return (1e3 - sum) % 10;
  };
  AbstractUPCEANReader2.decodeEnd = function(row, endStart) {
    return AbstractUPCEANReader2.findGuardPattern(row, endStart, false, AbstractUPCEANReader2.START_END_PATTERN, new Int32Array(AbstractUPCEANReader2.START_END_PATTERN.length).fill(0));
  };
  AbstractUPCEANReader2.findGuardPatternWithoutCounters = function(row, rowOffset, whiteFirst, pattern) {
    return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
  };
  AbstractUPCEANReader2.findGuardPattern = function(row, rowOffset, whiteFirst, pattern, counters) {
    var width = row.getSize();
    rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
    var counterPosition = 0;
    var patternStart = rowOffset;
    var patternLength = pattern.length;
    var isWhite = whiteFirst;
    for (var x2 = rowOffset; x2 < width; x2++) {
      if (row.get(x2) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === patternLength - 1) {
          if (OneDReader_default.patternMatchVariance(counters, pattern, AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader2.MAX_AVG_VARIANCE) {
            return Int32Array.from([patternStart, x2]);
          }
          patternStart += counters[0] + counters[1];
          var slice = counters.slice(2, counters.length - 1);
          for (var i = 0; i < counterPosition - 1; i++) {
            counters[i] = slice[i];
          }
          counters[counterPosition - 1] = 0;
          counters[counterPosition] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  AbstractUPCEANReader2.decodeDigit = function(row, counters, rowOffset, patterns) {
    this.recordPattern(row, rowOffset, counters);
    var bestVariance = this.MAX_AVG_VARIANCE;
    var bestMatch = -1;
    var max = patterns.length;
    for (var i = 0; i < max; i++) {
      var pattern = patterns[i];
      var variance = OneDReader_default.patternMatchVariance(counters, pattern, AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE);
      if (variance < bestVariance) {
        bestVariance = variance;
        bestMatch = i;
      }
    }
    if (bestMatch >= 0) {
      return bestMatch;
    } else {
      throw new NotFoundException_default();
    }
  };
  AbstractUPCEANReader2.MAX_AVG_VARIANCE = 0.48;
  AbstractUPCEANReader2.MAX_INDIVIDUAL_VARIANCE = 0.7;
  AbstractUPCEANReader2.START_END_PATTERN = Int32Array.from([1, 1, 1]);
  AbstractUPCEANReader2.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
  AbstractUPCEANReader2.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
  AbstractUPCEANReader2.L_PATTERNS = [
    Int32Array.from([3, 2, 1, 1]),
    Int32Array.from([2, 2, 2, 1]),
    Int32Array.from([2, 1, 2, 2]),
    Int32Array.from([1, 4, 1, 1]),
    Int32Array.from([1, 1, 3, 2]),
    Int32Array.from([1, 2, 3, 1]),
    Int32Array.from([1, 1, 1, 4]),
    Int32Array.from([1, 3, 1, 2]),
    Int32Array.from([1, 2, 1, 3]),
    Int32Array.from([3, 1, 1, 2])
  ];
  return AbstractUPCEANReader2;
}(OneDReader_default);
var AbstractUPCEANReader_default = AbstractUPCEANReader;

// node_modules/@zxing/library/esm/core/oned/UPCEANExtension5Support.js
var __values6 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var UPCEANExtension5Support = function() {
  function UPCEANExtension5Support2() {
    this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
    this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
    this.decodeRowStringBuffer = "";
  }
  UPCEANExtension5Support2.prototype.decodeRow = function(rowNumber, row, extensionStartRange) {
    var result = this.decodeRowStringBuffer;
    var end = this.decodeMiddle(row, extensionStartRange, result);
    var resultString = result.toString();
    var extensionData = UPCEANExtension5Support2.parseExtensionString(resultString);
    var resultPoints = [
      new ResultPoint_default((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
      new ResultPoint_default(end, rowNumber)
    ];
    var extensionResult = new Result_default(resultString, null, 0, resultPoints, BarcodeFormat_default.UPC_EAN_EXTENSION, new Date().getTime());
    if (extensionData != null) {
      extensionResult.putAllMetadata(extensionData);
    }
    return extensionResult;
  };
  UPCEANExtension5Support2.prototype.decodeMiddle = function(row, startRange, resultString) {
    var e_1, _a;
    var counters = this.decodeMiddleCounters;
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var end = row.getSize();
    var rowOffset = startRange[1];
    var lgPatternFound = 0;
    for (var x2 = 0; x2 < 5 && rowOffset < end; x2++) {
      var bestMatch = AbstractUPCEANReader_default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_default.L_AND_G_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
      try {
        for (var counters_1 = (e_1 = void 0, __values6(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          rowOffset += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (bestMatch >= 10) {
        lgPatternFound |= 1 << 4 - x2;
      }
      if (x2 !== 4) {
        rowOffset = row.getNextSet(rowOffset);
        rowOffset = row.getNextUnset(rowOffset);
      }
    }
    if (resultString.length !== 5) {
      throw new NotFoundException_default();
    }
    var checkDigit = this.determineCheckDigit(lgPatternFound);
    if (UPCEANExtension5Support2.extensionChecksum(resultString.toString()) !== checkDigit) {
      throw new NotFoundException_default();
    }
    return rowOffset;
  };
  UPCEANExtension5Support2.extensionChecksum = function(s) {
    var length = s.length;
    var sum = 0;
    for (var i = length - 2; i >= 0; i -= 2) {
      sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
    }
    sum *= 3;
    for (var i = length - 1; i >= 0; i -= 2) {
      sum += s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
    }
    sum *= 3;
    return sum % 10;
  };
  UPCEANExtension5Support2.prototype.determineCheckDigit = function(lgPatternFound) {
    for (var d = 0; d < 10; d++) {
      if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
        return d;
      }
    }
    throw new NotFoundException_default();
  };
  UPCEANExtension5Support2.parseExtensionString = function(raw) {
    if (raw.length !== 5) {
      return null;
    }
    var value = UPCEANExtension5Support2.parseExtension5String(raw);
    if (value == null) {
      return null;
    }
    return new Map([[ResultMetadataType_default.SUGGESTED_PRICE, value]]);
  };
  UPCEANExtension5Support2.parseExtension5String = function(raw) {
    var currency;
    switch (raw.charAt(0)) {
      case "0":
        currency = "\xA3";
        break;
      case "5":
        currency = "$";
        break;
      case "9":
        switch (raw) {
          case "90000":
            return null;
          case "99991":
            return "0.00";
          case "99990":
            return "Used";
        }
        currency = "";
        break;
      default:
        currency = "";
        break;
    }
    var rawAmount = parseInt(raw.substring(1));
    var unitsString = (rawAmount / 100).toString();
    var hundredths = rawAmount % 100;
    var hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
    return currency + unitsString + "." + hundredthsString;
  };
  return UPCEANExtension5Support2;
}();
var UPCEANExtension5Support_default = UPCEANExtension5Support;

// node_modules/@zxing/library/esm/core/oned/UPCEANExtension2Support.js
var __values7 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var UPCEANExtension2Support = function() {
  function UPCEANExtension2Support2() {
    this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
    this.decodeRowStringBuffer = "";
  }
  UPCEANExtension2Support2.prototype.decodeRow = function(rowNumber, row, extensionStartRange) {
    var result = this.decodeRowStringBuffer;
    var end = this.decodeMiddle(row, extensionStartRange, result);
    var resultString = result.toString();
    var extensionData = UPCEANExtension2Support2.parseExtensionString(resultString);
    var resultPoints = [
      new ResultPoint_default((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
      new ResultPoint_default(end, rowNumber)
    ];
    var extensionResult = new Result_default(resultString, null, 0, resultPoints, BarcodeFormat_default.UPC_EAN_EXTENSION, new Date().getTime());
    if (extensionData != null) {
      extensionResult.putAllMetadata(extensionData);
    }
    return extensionResult;
  };
  UPCEANExtension2Support2.prototype.decodeMiddle = function(row, startRange, resultString) {
    var e_1, _a;
    var counters = this.decodeMiddleCounters;
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var end = row.getSize();
    var rowOffset = startRange[1];
    var checkParity = 0;
    for (var x2 = 0; x2 < 2 && rowOffset < end; x2++) {
      var bestMatch = AbstractUPCEANReader_default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_default.L_AND_G_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
      try {
        for (var counters_1 = (e_1 = void 0, __values7(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          rowOffset += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (bestMatch >= 10) {
        checkParity |= 1 << 1 - x2;
      }
      if (x2 !== 1) {
        rowOffset = row.getNextSet(rowOffset);
        rowOffset = row.getNextUnset(rowOffset);
      }
    }
    if (resultString.length !== 2) {
      throw new NotFoundException_default();
    }
    if (parseInt(resultString.toString()) % 4 !== checkParity) {
      throw new NotFoundException_default();
    }
    return rowOffset;
  };
  UPCEANExtension2Support2.parseExtensionString = function(raw) {
    if (raw.length !== 2) {
      return null;
    }
    return new Map([[ResultMetadataType_default.ISSUE_NUMBER, parseInt(raw)]]);
  };
  return UPCEANExtension2Support2;
}();
var UPCEANExtension2Support_default = UPCEANExtension2Support;

// node_modules/@zxing/library/esm/core/oned/UPCEANExtensionSupport.js
var UPCEANExtensionSupport = function() {
  function UPCEANExtensionSupport2() {
  }
  UPCEANExtensionSupport2.decodeRow = function(rowNumber, row, rowOffset) {
    var extensionStartRange = AbstractUPCEANReader_default.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0));
    try {
      var fiveSupport = new UPCEANExtension5Support_default();
      return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
    } catch (err2) {
      var twoSupport = new UPCEANExtension2Support_default();
      return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
    }
  };
  UPCEANExtensionSupport2.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
  return UPCEANExtensionSupport2;
}();
var UPCEANExtensionSupport_default = UPCEANExtensionSupport;

// node_modules/@zxing/library/esm/core/oned/UPCEANReader.js
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var UPCEANReader = function(_super) {
  __extends26(UPCEANReader2, _super);
  function UPCEANReader2() {
    var _this = _super.call(this) || this;
    _this.decodeRowStringBuffer = "";
    UPCEANReader2.L_AND_G_PATTERNS = UPCEANReader2.L_PATTERNS.map(function(arr) {
      return Int32Array.from(arr);
    });
    for (var i = 10; i < 20; i++) {
      var widths = UPCEANReader2.L_PATTERNS[i - 10];
      var reversedWidths = new Int32Array(widths.length);
      for (var j = 0; j < widths.length; j++) {
        reversedWidths[j] = widths[widths.length - j - 1];
      }
      UPCEANReader2.L_AND_G_PATTERNS[i] = reversedWidths;
    }
    return _this;
  }
  UPCEANReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var startGuardRange = UPCEANReader2.findStartGuardPattern(row);
    var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
    if (resultPointCallback != null) {
      var resultPoint_1 = new ResultPoint_default((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
      resultPointCallback.foundPossibleResultPoint(resultPoint_1);
    }
    var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
    var endStart = budello.rowOffset;
    var result = budello.resultString;
    if (resultPointCallback != null) {
      var resultPoint_2 = new ResultPoint_default(endStart, rowNumber);
      resultPointCallback.foundPossibleResultPoint(resultPoint_2);
    }
    var endRange = UPCEANReader2.decodeEnd(row, endStart);
    if (resultPointCallback != null) {
      var resultPoint_3 = new ResultPoint_default((endRange[0] + endRange[1]) / 2, rowNumber);
      resultPointCallback.foundPossibleResultPoint(resultPoint_3);
    }
    var end = endRange[1];
    var quietEnd = end + (end - endRange[0]);
    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
      throw new NotFoundException_default();
    }
    var resultString = result.toString();
    if (resultString.length < 8) {
      throw new FormatException_default();
    }
    if (!UPCEANReader2.checkChecksum(resultString)) {
      throw new ChecksumException_default();
    }
    var left = (startGuardRange[1] + startGuardRange[0]) / 2;
    var right = (endRange[1] + endRange[0]) / 2;
    var format = this.getBarcodeFormat();
    var resultPoint = [new ResultPoint_default(left, rowNumber), new ResultPoint_default(right, rowNumber)];
    var decodeResult = new Result_default(resultString, null, 0, resultPoint, format, new Date().getTime());
    var extensionLength = 0;
    try {
      var extensionResult = UPCEANExtensionSupport_default.decodeRow(rowNumber, row, endRange[1]);
      decodeResult.putMetadata(ResultMetadataType_default.UPC_EAN_EXTENSION, extensionResult.getText());
      decodeResult.putAllMetadata(extensionResult.getResultMetadata());
      decodeResult.addResultPoints(extensionResult.getResultPoints());
      extensionLength = extensionResult.getText().length;
    } catch (err2) {
    }
    var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_default.ALLOWED_EAN_EXTENSIONS);
    if (allowedExtensions != null) {
      var valid = false;
      for (var length_1 in allowedExtensions) {
        if (extensionLength.toString() === length_1) {
          valid = true;
          break;
        }
      }
      if (!valid) {
        throw new NotFoundException_default();
      }
    }
    if (format === BarcodeFormat_default.EAN_13 || format === BarcodeFormat_default.UPC_A) {
    }
    return decodeResult;
  };
  UPCEANReader2.checkChecksum = function(s) {
    return UPCEANReader2.checkStandardUPCEANChecksum(s);
  };
  UPCEANReader2.checkStandardUPCEANChecksum = function(s) {
    var length = s.length;
    if (length === 0)
      return false;
    var check = parseInt(s.charAt(length - 1), 10);
    return UPCEANReader2.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
  };
  UPCEANReader2.getStandardUPCEANChecksum = function(s) {
    var length = s.length;
    var sum = 0;
    for (var i = length - 1; i >= 0; i -= 2) {
      var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
      if (digit < 0 || digit > 9) {
        throw new FormatException_default();
      }
      sum += digit;
    }
    sum *= 3;
    for (var i = length - 2; i >= 0; i -= 2) {
      var digit = s.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
      if (digit < 0 || digit > 9) {
        throw new FormatException_default();
      }
      sum += digit;
    }
    return (1e3 - sum) % 10;
  };
  UPCEANReader2.decodeEnd = function(row, endStart) {
    return UPCEANReader2.findGuardPattern(row, endStart, false, UPCEANReader2.START_END_PATTERN, new Int32Array(UPCEANReader2.START_END_PATTERN.length).fill(0));
  };
  return UPCEANReader2;
}(AbstractUPCEANReader_default);
var UPCEANReader_default = UPCEANReader;

// node_modules/@zxing/library/esm/core/oned/EAN13Reader.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values8 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var EAN13Reader = function(_super) {
  __extends27(EAN13Reader2, _super);
  function EAN13Reader2() {
    var _this = _super.call(this) || this;
    _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
    return _this;
  }
  EAN13Reader2.prototype.decodeMiddle = function(row, startRange, resultString) {
    var e_1, _a, e_2, _b;
    var counters = this.decodeMiddleCounters;
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var end = row.getSize();
    var rowOffset = startRange[1];
    var lgPatternFound = 0;
    for (var x2 = 0; x2 < 6 && rowOffset < end; x2++) {
      var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_AND_G_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
      try {
        for (var counters_1 = (e_1 = void 0, __values8(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          rowOffset += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (bestMatch >= 10) {
        lgPatternFound |= 1 << 5 - x2;
      }
    }
    resultString = EAN13Reader2.determineFirstDigit(resultString, lgPatternFound);
    var middleRange = UPCEANReader_default.findGuardPattern(row, rowOffset, true, UPCEANReader_default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_default.MIDDLE_PATTERN.length).fill(0));
    rowOffset = middleRange[1];
    for (var x2 = 0; x2 < 6 && rowOffset < end; x2++) {
      var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
      try {
        for (var counters_2 = (e_2 = void 0, __values8(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
          var counter = counters_2_1.value;
          rowOffset += counter;
        }
      } catch (e_2_1) {
        e_2 = {error: e_2_1};
      } finally {
        try {
          if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return))
            _b.call(counters_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    return {rowOffset, resultString};
  };
  EAN13Reader2.prototype.getBarcodeFormat = function() {
    return BarcodeFormat_default.EAN_13;
  };
  EAN13Reader2.determineFirstDigit = function(resultString, lgPatternFound) {
    for (var d = 0; d < 10; d++) {
      if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
        resultString = String.fromCharCode("0".charCodeAt(0) + d) + resultString;
        return resultString;
      }
    }
    throw new NotFoundException_default();
  };
  EAN13Reader2.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
  return EAN13Reader2;
}(UPCEANReader_default);
var EAN13Reader_default = EAN13Reader;

// node_modules/@zxing/library/esm/core/oned/EAN8Reader.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values9 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var EAN8Reader = function(_super) {
  __extends28(EAN8Reader2, _super);
  function EAN8Reader2() {
    var _this = _super.call(this) || this;
    _this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
    return _this;
  }
  EAN8Reader2.prototype.decodeMiddle = function(row, startRange, resultString) {
    var e_1, _a, e_2, _b;
    var counters = this.decodeMiddleCounters;
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var end = row.getSize();
    var rowOffset = startRange[1];
    for (var x2 = 0; x2 < 4 && rowOffset < end; x2++) {
      var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
      try {
        for (var counters_1 = (e_1 = void 0, __values9(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          rowOffset += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    var middleRange = UPCEANReader_default.findGuardPattern(row, rowOffset, true, UPCEANReader_default.MIDDLE_PATTERN, new Int32Array(UPCEANReader_default.MIDDLE_PATTERN.length).fill(0));
    rowOffset = middleRange[1];
    for (var x2 = 0; x2 < 4 && rowOffset < end; x2++) {
      var bestMatch = UPCEANReader_default.decodeDigit(row, counters, rowOffset, UPCEANReader_default.L_PATTERNS);
      resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
      try {
        for (var counters_2 = (e_2 = void 0, __values9(counters)), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
          var counter = counters_2_1.value;
          rowOffset += counter;
        }
      } catch (e_2_1) {
        e_2 = {error: e_2_1};
      } finally {
        try {
          if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return))
            _b.call(counters_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    return {rowOffset, resultString};
  };
  EAN8Reader2.prototype.getBarcodeFormat = function() {
    return BarcodeFormat_default.EAN_8;
  };
  return EAN8Reader2;
}(UPCEANReader_default);
var EAN8Reader_default = EAN8Reader;

// node_modules/@zxing/library/esm/core/oned/UPCAReader.js
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var UPCAReader = function(_super) {
  __extends29(UPCAReader2, _super);
  function UPCAReader2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ean13Reader = new EAN13Reader_default();
    return _this;
  }
  UPCAReader2.prototype.getBarcodeFormat = function() {
    return BarcodeFormat_default.UPC_A;
  };
  UPCAReader2.prototype.decode = function(image, hints) {
    return this.maybeReturnResult(this.ean13Reader.decode(image));
  };
  UPCAReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
  };
  UPCAReader2.prototype.decodeMiddle = function(row, startRange, resultString) {
    return this.ean13Reader.decodeMiddle(row, startRange, resultString);
  };
  UPCAReader2.prototype.maybeReturnResult = function(result) {
    var text = result.getText();
    if (text.charAt(0) === "0") {
      var upcaResult = new Result_default(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat_default.UPC_A);
      if (result.getResultMetadata() != null) {
        upcaResult.putAllMetadata(result.getResultMetadata());
      }
      return upcaResult;
    } else {
      throw new NotFoundException_default();
    }
  };
  UPCAReader2.prototype.reset = function() {
    this.ean13Reader.reset();
  };
  return UPCAReader2;
}(UPCEANReader_default);
var UPCAReader_default = UPCAReader;

// node_modules/@zxing/library/esm/core/oned/UPCEReader.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values10 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var UPCEReader = function(_super) {
  __extends30(UPCEReader2, _super);
  function UPCEReader2() {
    var _this = _super.call(this) || this;
    _this.decodeMiddleCounters = new Int32Array(4);
    return _this;
  }
  UPCEReader2.prototype.decodeMiddle = function(row, startRange, result) {
    var e_1, _a;
    var counters = this.decodeMiddleCounters.map(function(x3) {
      return x3;
    });
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var end = row.getSize();
    var rowOffset = startRange[1];
    var lgPatternFound = 0;
    for (var x2 = 0; x2 < 6 && rowOffset < end; x2++) {
      var bestMatch = UPCEReader2.decodeDigit(row, counters, rowOffset, UPCEReader2.L_AND_G_PATTERNS);
      result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
      try {
        for (var counters_1 = (e_1 = void 0, __values10(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          rowOffset += counter;
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (bestMatch >= 10) {
        lgPatternFound |= 1 << 5 - x2;
      }
    }
    UPCEReader2.determineNumSysAndCheckDigit(new StringBuilder_default(result), lgPatternFound);
    return rowOffset;
  };
  UPCEReader2.prototype.decodeEnd = function(row, endStart) {
    return UPCEReader2.findGuardPatternWithoutCounters(row, endStart, true, UPCEReader2.MIDDLE_END_PATTERN);
  };
  UPCEReader2.prototype.checkChecksum = function(s) {
    return UPCEANReader_default.checkChecksum(UPCEReader2.convertUPCEtoUPCA(s));
  };
  UPCEReader2.determineNumSysAndCheckDigit = function(resultString, lgPatternFound) {
    for (var numSys = 0; numSys <= 1; numSys++) {
      for (var d = 0; d < 10; d++) {
        if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d]) {
          resultString.insert(0, "0" + numSys);
          resultString.append("0" + d);
          return;
        }
      }
    }
    throw NotFoundException_default.getNotFoundInstance();
  };
  UPCEReader2.prototype.getBarcodeFormat = function() {
    return BarcodeFormat_default.UPC_E;
  };
  UPCEReader2.convertUPCEtoUPCA = function(upce) {
    var upceChars = upce.slice(1, 7).split("").map(function(x2) {
      return x2.charCodeAt(0);
    });
    var result = new StringBuilder_default();
    result.append(upce.charAt(0));
    var lastChar = upceChars[5];
    switch (lastChar) {
      case 0:
      case 1:
      case 2:
        result.appendChars(upceChars, 0, 2);
        result.append(lastChar);
        result.append("0000");
        result.appendChars(upceChars, 2, 3);
        break;
      case 3:
        result.appendChars(upceChars, 0, 3);
        result.append("00000");
        result.appendChars(upceChars, 3, 2);
        break;
      case 4:
        result.appendChars(upceChars, 0, 4);
        result.append("00000");
        result.append(upceChars[4]);
        break;
      default:
        result.appendChars(upceChars, 0, 5);
        result.append("0000");
        result.append(lastChar);
        break;
    }
    if (upce.length >= 8) {
      result.append(upce.charAt(7));
    }
    return result.toString();
  };
  UPCEReader2.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
  UPCEReader2.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
    Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
    Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 1])
  ];
  return UPCEReader2;
}(UPCEANReader_default);
var UPCEReader_default = UPCEReader;

// node_modules/@zxing/library/esm/core/oned/MultiFormatUPCEANReader.js
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values11 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiFormatUPCEANReader = function(_super) {
  __extends31(MultiFormatUPCEANReader2, _super);
  function MultiFormatUPCEANReader2(hints) {
    var _this = _super.call(this) || this;
    var possibleFormats = hints == null ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
    var readers = [];
    if (possibleFormats != null) {
      if (possibleFormats.indexOf(BarcodeFormat_default.EAN_13) > -1) {
        readers.push(new EAN13Reader_default());
      } else if (possibleFormats.indexOf(BarcodeFormat_default.UPC_A) > -1) {
        readers.push(new UPCAReader_default());
      }
      if (possibleFormats.indexOf(BarcodeFormat_default.EAN_8) > -1) {
        readers.push(new EAN8Reader_default());
      }
      if (possibleFormats.indexOf(BarcodeFormat_default.UPC_E) > -1) {
        readers.push(new UPCEReader_default());
      }
    }
    if (readers.length === 0) {
      readers.push(new EAN13Reader_default());
      readers.push(new EAN8Reader_default());
      readers.push(new UPCEReader_default());
    }
    _this.readers = readers;
    return _this;
  }
  MultiFormatUPCEANReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var e_1, _a;
    try {
      for (var _b = __values11(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
        var reader = _c.value;
        try {
          var result = reader.decodeRow(rowNumber, row, hints);
          var ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat_default.EAN_13 && result.getText().charAt(0) === "0";
          var possibleFormats = hints == null ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
          var canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat_default.UPC_A);
          if (ean13MayBeUPCA && canReturnUPCA) {
            var rawBytes = result.getRawBytes();
            var resultUPCA = new Result_default(result.getText().substring(1), rawBytes, rawBytes.length, result.getResultPoints(), BarcodeFormat_default.UPC_A);
            resultUPCA.putAllMetadata(result.getResultMetadata());
            return resultUPCA;
          }
          return result;
        } catch (err2) {
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    throw new NotFoundException_default();
  };
  MultiFormatUPCEANReader2.prototype.reset = function() {
    var e_2, _a;
    try {
      for (var _b = __values11(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
        var reader = _c.value;
        reader.reset();
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  return MultiFormatUPCEANReader2;
}(OneDReader_default);
var MultiFormatUPCEANReader_default = MultiFormatUPCEANReader;

// node_modules/@zxing/library/esm/core/oned/rss/AbstractRSSReader.js
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values12 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var AbstractRSSReader = function(_super) {
  __extends32(AbstractRSSReader2, _super);
  function AbstractRSSReader2() {
    var _this = _super.call(this) || this;
    _this.decodeFinderCounters = new Int32Array(4);
    _this.dataCharacterCounters = new Int32Array(8);
    _this.oddRoundingErrors = new Array(4);
    _this.evenRoundingErrors = new Array(4);
    _this.oddCounts = new Array(_this.dataCharacterCounters.length / 2);
    _this.evenCounts = new Array(_this.dataCharacterCounters.length / 2);
    return _this;
  }
  AbstractRSSReader2.prototype.getDecodeFinderCounters = function() {
    return this.decodeFinderCounters;
  };
  AbstractRSSReader2.prototype.getDataCharacterCounters = function() {
    return this.dataCharacterCounters;
  };
  AbstractRSSReader2.prototype.getOddRoundingErrors = function() {
    return this.oddRoundingErrors;
  };
  AbstractRSSReader2.prototype.getEvenRoundingErrors = function() {
    return this.evenRoundingErrors;
  };
  AbstractRSSReader2.prototype.getOddCounts = function() {
    return this.oddCounts;
  };
  AbstractRSSReader2.prototype.getEvenCounts = function() {
    return this.evenCounts;
  };
  AbstractRSSReader2.prototype.parseFinderValue = function(counters, finderPatterns) {
    for (var value = 0; value < finderPatterns.length; value++) {
      if (OneDReader_default.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader2.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader2.MAX_AVG_VARIANCE) {
        return value;
      }
    }
    throw new NotFoundException_default();
  };
  AbstractRSSReader2.count = function(array) {
    return MathUtils_default.sum(new Int32Array(array));
  };
  AbstractRSSReader2.increment = function(array, errors) {
    var index = 0;
    var biggestError = errors[0];
    for (var i = 1; i < array.length; i++) {
      if (errors[i] > biggestError) {
        biggestError = errors[i];
        index = i;
      }
    }
    array[index]++;
  };
  AbstractRSSReader2.decrement = function(array, errors) {
    var index = 0;
    var biggestError = errors[0];
    for (var i = 1; i < array.length; i++) {
      if (errors[i] < biggestError) {
        biggestError = errors[i];
        index = i;
      }
    }
    array[index]--;
  };
  AbstractRSSReader2.isFinderPattern = function(counters) {
    var e_1, _a;
    var firstTwoSum = counters[0] + counters[1];
    var sum = firstTwoSum + counters[2] + counters[3];
    var ratio = firstTwoSum / sum;
    if (ratio >= AbstractRSSReader2.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader2.MAX_FINDER_PATTERN_RATIO) {
      var minCounter = Number.MAX_SAFE_INTEGER;
      var maxCounter = Number.MIN_SAFE_INTEGER;
      try {
        for (var counters_1 = __values12(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
          var counter = counters_1_1.value;
          if (counter > maxCounter) {
            maxCounter = counter;
          }
          if (counter < minCounter) {
            minCounter = counter;
          }
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return))
            _a.call(counters_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return maxCounter < 10 * minCounter;
    }
    return false;
  };
  AbstractRSSReader2.MAX_AVG_VARIANCE = 0.2;
  AbstractRSSReader2.MAX_INDIVIDUAL_VARIANCE = 0.45;
  AbstractRSSReader2.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
  AbstractRSSReader2.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
  return AbstractRSSReader2;
}(OneDReader_default);
var AbstractRSSReader_default = AbstractRSSReader;

// node_modules/@zxing/library/esm/core/oned/rss/DataCharacter.js
var DataCharacter = function() {
  function DataCharacter2(value, checksumPortion) {
    this.value = value;
    this.checksumPortion = checksumPortion;
  }
  DataCharacter2.prototype.getValue = function() {
    return this.value;
  };
  DataCharacter2.prototype.getChecksumPortion = function() {
    return this.checksumPortion;
  };
  DataCharacter2.prototype.toString = function() {
    return this.value + "(" + this.checksumPortion + ")";
  };
  DataCharacter2.prototype.equals = function(o) {
    if (!(o instanceof DataCharacter2)) {
      return false;
    }
    var that = o;
    return this.value === that.value && this.checksumPortion === that.checksumPortion;
  };
  DataCharacter2.prototype.hashCode = function() {
    return this.value ^ this.checksumPortion;
  };
  return DataCharacter2;
}();
var DataCharacter_default = DataCharacter;

// node_modules/@zxing/library/esm/core/oned/rss/FinderPattern.js
var FinderPattern = function() {
  function FinderPattern3(value, startEnd, start, end, rowNumber) {
    this.value = value;
    this.startEnd = startEnd;
    this.value = value;
    this.startEnd = startEnd;
    this.resultPoints = new Array();
    this.resultPoints.push(new ResultPoint_default(start, rowNumber));
    this.resultPoints.push(new ResultPoint_default(end, rowNumber));
  }
  FinderPattern3.prototype.getValue = function() {
    return this.value;
  };
  FinderPattern3.prototype.getStartEnd = function() {
    return this.startEnd;
  };
  FinderPattern3.prototype.getResultPoints = function() {
    return this.resultPoints;
  };
  FinderPattern3.prototype.equals = function(o) {
    if (!(o instanceof FinderPattern3)) {
      return false;
    }
    var that = o;
    return this.value === that.value;
  };
  FinderPattern3.prototype.hashCode = function() {
    return this.value;
  };
  return FinderPattern3;
}();
var FinderPattern_default = FinderPattern;

// node_modules/@zxing/library/esm/core/oned/rss/RSSUtils.js
var __values13 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var RSSUtils = function() {
  function RSSUtils2() {
  }
  RSSUtils2.getRSSvalue = function(widths, maxWidth, noNarrow) {
    var e_1, _a;
    var n = 0;
    try {
      for (var widths_1 = __values13(widths), widths_1_1 = widths_1.next(); !widths_1_1.done; widths_1_1 = widths_1.next()) {
        var width = widths_1_1.value;
        n += width;
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (widths_1_1 && !widths_1_1.done && (_a = widths_1.return))
          _a.call(widths_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var val = 0;
    var narrowMask = 0;
    var elements = widths.length;
    for (var bar = 0; bar < elements - 1; bar++) {
      var elmWidth = void 0;
      for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
        var subVal = RSSUtils2.combins(n - elmWidth - 1, elements - bar - 2);
        if (noNarrow && narrowMask === 0 && n - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
          subVal -= RSSUtils2.combins(n - elmWidth - (elements - bar), elements - bar - 2);
        }
        if (elements - bar - 1 > 1) {
          var lessVal = 0;
          for (var mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
            lessVal += RSSUtils2.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
          }
          subVal -= lessVal * (elements - 1 - bar);
        } else if (n - elmWidth > maxWidth) {
          subVal--;
        }
        val += subVal;
      }
      n -= elmWidth;
    }
    return val;
  };
  RSSUtils2.combins = function(n, r) {
    var maxDenom;
    var minDenom;
    if (n - r > r) {
      minDenom = r;
      maxDenom = n - r;
    } else {
      minDenom = n - r;
      maxDenom = r;
    }
    var val = 1;
    var j = 1;
    for (var i = n; i > maxDenom; i--) {
      val *= i;
      if (j <= minDenom) {
        val /= j;
        j++;
      }
    }
    while (j <= minDenom) {
      val /= j;
      j++;
    }
    return val;
  };
  return RSSUtils2;
}();
var RSSUtils_default = RSSUtils;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/BitArrayBuilder.js
var BitArrayBuilder = function() {
  function BitArrayBuilder2() {
  }
  BitArrayBuilder2.buildBitArray = function(pairs) {
    var charNumber = pairs.length * 2 - 1;
    if (pairs[pairs.length - 1].getRightChar() == null) {
      charNumber -= 1;
    }
    var size = 12 * charNumber;
    var binary = new BitArray_default(size);
    var accPos = 0;
    var firstPair = pairs[0];
    var firstValue = firstPair.getRightChar().getValue();
    for (var i = 11; i >= 0; --i) {
      if ((firstValue & 1 << i) != 0) {
        binary.set(accPos);
      }
      accPos++;
    }
    for (var i = 1; i < pairs.length; ++i) {
      var currentPair = pairs[i];
      var leftValue = currentPair.getLeftChar().getValue();
      for (var j = 11; j >= 0; --j) {
        if ((leftValue & 1 << j) != 0) {
          binary.set(accPos);
        }
        accPos++;
      }
      if (currentPair.getRightChar() != null) {
        var rightValue = currentPair.getRightChar().getValue();
        for (var j = 11; j >= 0; --j) {
          if ((rightValue & 1 << j) != 0) {
            binary.set(accPos);
          }
          accPos++;
        }
      }
    }
    return binary;
  };
  return BitArrayBuilder2;
}();
var BitArrayBuilder_default = BitArrayBuilder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/BlockParsedResult.js
var BlockParsedResult = function() {
  function BlockParsedResult2(finished, decodedInformation) {
    if (decodedInformation) {
      this.decodedInformation = null;
    } else {
      this.finished = finished;
      this.decodedInformation = decodedInformation;
    }
  }
  BlockParsedResult2.prototype.getDecodedInformation = function() {
    return this.decodedInformation;
  };
  BlockParsedResult2.prototype.isFinished = function() {
    return this.finished;
  };
  return BlockParsedResult2;
}();
var BlockParsedResult_default = BlockParsedResult;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedObject.js
var DecodedObject = function() {
  function DecodedObject2(newPosition) {
    this.newPosition = newPosition;
  }
  DecodedObject2.prototype.getNewPosition = function() {
    return this.newPosition;
  };
  return DecodedObject2;
}();
var DecodedObject_default = DecodedObject;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedChar.js
var __extends33 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DecodedChar = function(_super) {
  __extends33(DecodedChar2, _super);
  function DecodedChar2(newPosition, value) {
    var _this = _super.call(this, newPosition) || this;
    _this.value = value;
    return _this;
  }
  DecodedChar2.prototype.getValue = function() {
    return this.value;
  };
  DecodedChar2.prototype.isFNC1 = function() {
    return this.value === DecodedChar2.FNC1;
  };
  DecodedChar2.FNC1 = "$";
  return DecodedChar2;
}(DecodedObject_default);
var DecodedChar_default = DecodedChar;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedInformation.js
var __extends34 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DecodedInformation = function(_super) {
  __extends34(DecodedInformation2, _super);
  function DecodedInformation2(newPosition, newString, remainingValue) {
    var _this = _super.call(this, newPosition) || this;
    if (remainingValue) {
      _this.remaining = true;
      _this.remainingValue = _this.remainingValue;
    } else {
      _this.remaining = false;
      _this.remainingValue = 0;
    }
    _this.newString = newString;
    return _this;
  }
  DecodedInformation2.prototype.getNewString = function() {
    return this.newString;
  };
  DecodedInformation2.prototype.isRemaining = function() {
    return this.remaining;
  };
  DecodedInformation2.prototype.getRemainingValue = function() {
    return this.remainingValue;
  };
  return DecodedInformation2;
}(DecodedObject_default);
var DecodedInformation_default = DecodedInformation;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/DecodedNumeric.js
var __extends35 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DecodedNumeric = function(_super) {
  __extends35(DecodedNumeric2, _super);
  function DecodedNumeric2(newPosition, firstDigit, secondDigit) {
    var _this = _super.call(this, newPosition) || this;
    if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
      throw new FormatException_default();
    }
    _this.firstDigit = firstDigit;
    _this.secondDigit = secondDigit;
    return _this;
  }
  DecodedNumeric2.prototype.getFirstDigit = function() {
    return this.firstDigit;
  };
  DecodedNumeric2.prototype.getSecondDigit = function() {
    return this.secondDigit;
  };
  DecodedNumeric2.prototype.getValue = function() {
    return this.firstDigit * 10 + this.secondDigit;
  };
  DecodedNumeric2.prototype.isFirstDigitFNC1 = function() {
    return this.firstDigit === DecodedNumeric2.FNC1;
  };
  DecodedNumeric2.prototype.isSecondDigitFNC1 = function() {
    return this.secondDigit === DecodedNumeric2.FNC1;
  };
  DecodedNumeric2.prototype.isAnyFNC1 = function() {
    return this.firstDigit === DecodedNumeric2.FNC1 || this.secondDigit === DecodedNumeric2.FNC1;
  };
  DecodedNumeric2.FNC1 = 10;
  return DecodedNumeric2;
}(DecodedObject_default);
var DecodedNumeric_default = DecodedNumeric;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/FieldParser.js
var __values14 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var FieldParser = function() {
  function FieldParser2() {
  }
  FieldParser2.parseFieldsInGeneralPurpose = function(rawInformation) {
    var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
    if (!rawInformation) {
      return null;
    }
    if (rawInformation.length < 2) {
      throw new NotFoundException_default();
    }
    var firstTwoDigits = rawInformation.substring(0, 2);
    try {
      for (var _e = __values14(FieldParser2.TWO_DIGIT_DATA_LENGTH), _f = _e.next(); !_f.done; _f = _e.next()) {
        var dataLength = _f.value;
        if (dataLength[0] === firstTwoDigits) {
          if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
            return FieldParser2.processVariableAI(2, dataLength[2], rawInformation);
          }
          return FieldParser2.processFixedAI(2, dataLength[1], rawInformation);
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_f && !_f.done && (_a = _e.return))
          _a.call(_e);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (rawInformation.length < 3) {
      throw new NotFoundException_default();
    }
    var firstThreeDigits = rawInformation.substring(0, 3);
    try {
      for (var _g = __values14(FieldParser2.THREE_DIGIT_DATA_LENGTH), _h = _g.next(); !_h.done; _h = _g.next()) {
        var dataLength = _h.value;
        if (dataLength[0] === firstThreeDigits) {
          if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
            return FieldParser2.processVariableAI(3, dataLength[2], rawInformation);
          }
          return FieldParser2.processFixedAI(3, dataLength[1], rawInformation);
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return))
          _b.call(_g);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    try {
      for (var _j = __values14(FieldParser2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), _k = _j.next(); !_k.done; _k = _j.next()) {
        var dataLength = _k.value;
        if (dataLength[0] === firstThreeDigits) {
          if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
            return FieldParser2.processVariableAI(4, dataLength[2], rawInformation);
          }
          return FieldParser2.processFixedAI(4, dataLength[1], rawInformation);
        }
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return))
          _c.call(_j);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    if (rawInformation.length < 4) {
      throw new NotFoundException_default();
    }
    var firstFourDigits = rawInformation.substring(0, 4);
    try {
      for (var _l = __values14(FieldParser2.FOUR_DIGIT_DATA_LENGTH), _m = _l.next(); !_m.done; _m = _l.next()) {
        var dataLength = _m.value;
        if (dataLength[0] === firstFourDigits) {
          if (dataLength[1] === FieldParser2.VARIABLE_LENGTH) {
            return FieldParser2.processVariableAI(4, dataLength[2], rawInformation);
          }
          return FieldParser2.processFixedAI(4, dataLength[1], rawInformation);
        }
      }
    } catch (e_4_1) {
      e_4 = {error: e_4_1};
    } finally {
      try {
        if (_m && !_m.done && (_d = _l.return))
          _d.call(_l);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
    throw new NotFoundException_default();
  };
  FieldParser2.processFixedAI = function(aiSize, fieldSize, rawInformation) {
    if (rawInformation.length < aiSize) {
      throw new NotFoundException_default();
    }
    var ai = rawInformation.substring(0, aiSize);
    if (rawInformation.length < aiSize + fieldSize) {
      throw new NotFoundException_default();
    }
    var field = rawInformation.substring(aiSize, aiSize + fieldSize);
    var remaining = rawInformation.substring(aiSize + fieldSize);
    var result = "(" + ai + ")" + field;
    var parsedAI = FieldParser2.parseFieldsInGeneralPurpose(remaining);
    return parsedAI == null ? result : result + parsedAI;
  };
  FieldParser2.processVariableAI = function(aiSize, variableFieldSize, rawInformation) {
    var ai = rawInformation.substring(0, aiSize);
    var maxSize;
    if (rawInformation.length < aiSize + variableFieldSize) {
      maxSize = rawInformation.length;
    } else {
      maxSize = aiSize + variableFieldSize;
    }
    var field = rawInformation.substring(aiSize, maxSize);
    var remaining = rawInformation.substring(maxSize);
    var result = "(" + ai + ")" + field;
    var parsedAI = FieldParser2.parseFieldsInGeneralPurpose(remaining);
    return parsedAI == null ? result : result + parsedAI;
  };
  FieldParser2.VARIABLE_LENGTH = [];
  FieldParser2.TWO_DIGIT_DATA_LENGTH = [
    ["00", 18],
    ["01", 14],
    ["02", 14],
    ["10", FieldParser2.VARIABLE_LENGTH, 20],
    ["11", 6],
    ["12", 6],
    ["13", 6],
    ["15", 6],
    ["17", 6],
    ["20", 2],
    ["21", FieldParser2.VARIABLE_LENGTH, 20],
    ["22", FieldParser2.VARIABLE_LENGTH, 29],
    ["30", FieldParser2.VARIABLE_LENGTH, 8],
    ["37", FieldParser2.VARIABLE_LENGTH, 8],
    ["90", FieldParser2.VARIABLE_LENGTH, 30],
    ["91", FieldParser2.VARIABLE_LENGTH, 30],
    ["92", FieldParser2.VARIABLE_LENGTH, 30],
    ["93", FieldParser2.VARIABLE_LENGTH, 30],
    ["94", FieldParser2.VARIABLE_LENGTH, 30],
    ["95", FieldParser2.VARIABLE_LENGTH, 30],
    ["96", FieldParser2.VARIABLE_LENGTH, 30],
    ["97", FieldParser2.VARIABLE_LENGTH, 3],
    ["98", FieldParser2.VARIABLE_LENGTH, 30],
    ["99", FieldParser2.VARIABLE_LENGTH, 30]
  ];
  FieldParser2.THREE_DIGIT_DATA_LENGTH = [
    ["240", FieldParser2.VARIABLE_LENGTH, 30],
    ["241", FieldParser2.VARIABLE_LENGTH, 30],
    ["242", FieldParser2.VARIABLE_LENGTH, 6],
    ["250", FieldParser2.VARIABLE_LENGTH, 30],
    ["251", FieldParser2.VARIABLE_LENGTH, 30],
    ["253", FieldParser2.VARIABLE_LENGTH, 17],
    ["254", FieldParser2.VARIABLE_LENGTH, 20],
    ["400", FieldParser2.VARIABLE_LENGTH, 30],
    ["401", FieldParser2.VARIABLE_LENGTH, 30],
    ["402", 17],
    ["403", FieldParser2.VARIABLE_LENGTH, 30],
    ["410", 13],
    ["411", 13],
    ["412", 13],
    ["413", 13],
    ["414", 13],
    ["420", FieldParser2.VARIABLE_LENGTH, 20],
    ["421", FieldParser2.VARIABLE_LENGTH, 15],
    ["422", 3],
    ["423", FieldParser2.VARIABLE_LENGTH, 15],
    ["424", 3],
    ["425", 3],
    ["426", 3]
  ];
  FieldParser2.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
    ["310", 6],
    ["311", 6],
    ["312", 6],
    ["313", 6],
    ["314", 6],
    ["315", 6],
    ["316", 6],
    ["320", 6],
    ["321", 6],
    ["322", 6],
    ["323", 6],
    ["324", 6],
    ["325", 6],
    ["326", 6],
    ["327", 6],
    ["328", 6],
    ["329", 6],
    ["330", 6],
    ["331", 6],
    ["332", 6],
    ["333", 6],
    ["334", 6],
    ["335", 6],
    ["336", 6],
    ["340", 6],
    ["341", 6],
    ["342", 6],
    ["343", 6],
    ["344", 6],
    ["345", 6],
    ["346", 6],
    ["347", 6],
    ["348", 6],
    ["349", 6],
    ["350", 6],
    ["351", 6],
    ["352", 6],
    ["353", 6],
    ["354", 6],
    ["355", 6],
    ["356", 6],
    ["357", 6],
    ["360", 6],
    ["361", 6],
    ["362", 6],
    ["363", 6],
    ["364", 6],
    ["365", 6],
    ["366", 6],
    ["367", 6],
    ["368", 6],
    ["369", 6],
    ["390", FieldParser2.VARIABLE_LENGTH, 15],
    ["391", FieldParser2.VARIABLE_LENGTH, 18],
    ["392", FieldParser2.VARIABLE_LENGTH, 15],
    ["393", FieldParser2.VARIABLE_LENGTH, 18],
    ["703", FieldParser2.VARIABLE_LENGTH, 30]
  ];
  FieldParser2.FOUR_DIGIT_DATA_LENGTH = [
    ["7001", 13],
    ["7002", FieldParser2.VARIABLE_LENGTH, 30],
    ["7003", 10],
    ["8001", 14],
    ["8002", FieldParser2.VARIABLE_LENGTH, 20],
    ["8003", FieldParser2.VARIABLE_LENGTH, 30],
    ["8004", FieldParser2.VARIABLE_LENGTH, 30],
    ["8005", 6],
    ["8006", 18],
    ["8007", FieldParser2.VARIABLE_LENGTH, 30],
    ["8008", FieldParser2.VARIABLE_LENGTH, 12],
    ["8018", 18],
    ["8020", FieldParser2.VARIABLE_LENGTH, 25],
    ["8100", 6],
    ["8101", 10],
    ["8102", 2],
    ["8110", FieldParser2.VARIABLE_LENGTH, 70],
    ["8200", FieldParser2.VARIABLE_LENGTH, 70]
  ];
  return FieldParser2;
}();
var FieldParser_default = FieldParser;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js
var GeneralAppIdDecoder = function() {
  function GeneralAppIdDecoder2(information) {
    this.buffer = new StringBuilder_default();
    this.information = information;
  }
  GeneralAppIdDecoder2.prototype.decodeAllCodes = function(buff, initialPosition) {
    var currentPosition = initialPosition;
    var remaining = null;
    do {
      var info = this.decodeGeneralPurposeField(currentPosition, remaining);
      var parsedFields = FieldParser_default.parseFieldsInGeneralPurpose(info.getNewString());
      if (parsedFields != null) {
        buff.append(parsedFields);
      }
      if (info.isRemaining()) {
        remaining = "" + info.getRemainingValue();
      } else {
        remaining = null;
      }
      if (currentPosition === info.getNewPosition()) {
        break;
      }
      currentPosition = info.getNewPosition();
    } while (true);
    return buff.toString();
  };
  GeneralAppIdDecoder2.prototype.isStillNumeric = function(pos) {
    if (pos + 7 > this.information.getSize()) {
      return pos + 4 <= this.information.getSize();
    }
    for (var i = pos; i < pos + 3; ++i) {
      if (this.information.get(i)) {
        return true;
      }
    }
    return this.information.get(pos + 3);
  };
  GeneralAppIdDecoder2.prototype.decodeNumeric = function(pos) {
    if (pos + 7 > this.information.getSize()) {
      var numeric_1 = this.extractNumericValueFromBitArray(pos, 4);
      if (numeric_1 === 0) {
        return new DecodedNumeric_default(this.information.getSize(), DecodedNumeric_default.FNC1, DecodedNumeric_default.FNC1);
      }
      return new DecodedNumeric_default(this.information.getSize(), numeric_1 - 1, DecodedNumeric_default.FNC1);
    }
    var numeric = this.extractNumericValueFromBitArray(pos, 7);
    var digit1 = (numeric - 8) / 11;
    var digit2 = (numeric - 8) % 11;
    return new DecodedNumeric_default(pos + 7, digit1, digit2);
  };
  GeneralAppIdDecoder2.prototype.extractNumericValueFromBitArray = function(pos, bits) {
    return GeneralAppIdDecoder2.extractNumericValueFromBitArray(this.information, pos, bits);
  };
  GeneralAppIdDecoder2.extractNumericValueFromBitArray = function(information, pos, bits) {
    var value = 0;
    for (var i = 0; i < bits; ++i) {
      if (information.get(pos + i)) {
        value |= 1 << bits - i - 1;
      }
    }
    return value;
  };
  GeneralAppIdDecoder2.prototype.decodeGeneralPurposeField = function(pos, remaining) {
    this.buffer.setLengthToZero();
    if (remaining != null) {
      this.buffer.append(remaining);
    }
    this.current.setPosition(pos);
    var lastDecoded = this.parseBlocks();
    if (lastDecoded != null && lastDecoded.isRemaining()) {
      return new DecodedInformation_default(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
    }
    return new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
  };
  GeneralAppIdDecoder2.prototype.parseBlocks = function() {
    var isFinished;
    var result;
    do {
      var initialPosition = this.current.getPosition();
      if (this.current.isAlpha()) {
        result = this.parseAlphaBlock();
        isFinished = result.isFinished();
      } else if (this.current.isIsoIec646()) {
        result = this.parseIsoIec646Block();
        isFinished = result.isFinished();
      } else {
        result = this.parseNumericBlock();
        isFinished = result.isFinished();
      }
      var positionChanged = initialPosition !== this.current.getPosition();
      if (!positionChanged && !isFinished) {
        break;
      }
    } while (!isFinished);
    return result.getDecodedInformation();
  };
  GeneralAppIdDecoder2.prototype.parseNumericBlock = function() {
    while (this.isStillNumeric(this.current.getPosition())) {
      var numeric = this.decodeNumeric(this.current.getPosition());
      this.current.setPosition(numeric.getNewPosition());
      if (numeric.isFirstDigitFNC1()) {
        var information = void 0;
        if (numeric.isSecondDigitFNC1()) {
          information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
        } else {
          information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
        }
        return new BlockParsedResult_default(true, information);
      }
      this.buffer.append(numeric.getFirstDigit());
      if (numeric.isSecondDigitFNC1()) {
        var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
        return new BlockParsedResult_default(true, information);
      }
      this.buffer.append(numeric.getSecondDigit());
    }
    if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
      this.current.setAlpha();
      this.current.incrementPosition(4);
    }
    return new BlockParsedResult_default(false);
  };
  GeneralAppIdDecoder2.prototype.parseIsoIec646Block = function() {
    while (this.isStillIsoIec646(this.current.getPosition())) {
      var iso = this.decodeIsoIec646(this.current.getPosition());
      this.current.setPosition(iso.getNewPosition());
      if (iso.isFNC1()) {
        var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
        return new BlockParsedResult_default(true, information);
      }
      this.buffer.append(iso.getValue());
    }
    if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
      this.current.incrementPosition(3);
      this.current.setNumeric();
    } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
      if (this.current.getPosition() + 5 < this.information.getSize()) {
        this.current.incrementPosition(5);
      } else {
        this.current.setPosition(this.information.getSize());
      }
      this.current.setAlpha();
    }
    return new BlockParsedResult_default(false);
  };
  GeneralAppIdDecoder2.prototype.parseAlphaBlock = function() {
    while (this.isStillAlpha(this.current.getPosition())) {
      var alpha = this.decodeAlphanumeric(this.current.getPosition());
      this.current.setPosition(alpha.getNewPosition());
      if (alpha.isFNC1()) {
        var information = new DecodedInformation_default(this.current.getPosition(), this.buffer.toString());
        return new BlockParsedResult_default(true, information);
      }
      this.buffer.append(alpha.getValue());
    }
    if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
      this.current.incrementPosition(3);
      this.current.setNumeric();
    } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
      if (this.current.getPosition() + 5 < this.information.getSize()) {
        this.current.incrementPosition(5);
      } else {
        this.current.setPosition(this.information.getSize());
      }
      this.current.setIsoIec646();
    }
    return new BlockParsedResult_default(false);
  };
  GeneralAppIdDecoder2.prototype.isStillIsoIec646 = function(pos) {
    if (pos + 5 > this.information.getSize()) {
      return false;
    }
    var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
    if (fiveBitValue >= 5 && fiveBitValue < 16) {
      return true;
    }
    if (pos + 7 > this.information.getSize()) {
      return false;
    }
    var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
    if (sevenBitValue >= 64 && sevenBitValue < 116) {
      return true;
    }
    if (pos + 8 > this.information.getSize()) {
      return false;
    }
    var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
    return eightBitValue >= 232 && eightBitValue < 253;
  };
  GeneralAppIdDecoder2.prototype.decodeIsoIec646 = function(pos) {
    var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
    if (fiveBitValue === 15) {
      return new DecodedChar_default(pos + 5, DecodedChar_default.FNC1);
    }
    if (fiveBitValue >= 5 && fiveBitValue < 15) {
      return new DecodedChar_default(pos + 5, "0" + (fiveBitValue - 5));
    }
    var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
    if (sevenBitValue >= 64 && sevenBitValue < 90) {
      return new DecodedChar_default(pos + 7, "" + (sevenBitValue + 1));
    }
    if (sevenBitValue >= 90 && sevenBitValue < 116) {
      return new DecodedChar_default(pos + 7, "" + (sevenBitValue + 7));
    }
    var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
    var c;
    switch (eightBitValue) {
      case 232:
        c = "!";
        break;
      case 233:
        c = '"';
        break;
      case 234:
        c = "%";
        break;
      case 235:
        c = "&";
        break;
      case 236:
        c = "'";
        break;
      case 237:
        c = "(";
        break;
      case 238:
        c = ")";
        break;
      case 239:
        c = "*";
        break;
      case 240:
        c = "+";
        break;
      case 241:
        c = ",";
        break;
      case 242:
        c = "-";
        break;
      case 243:
        c = ".";
        break;
      case 244:
        c = "/";
        break;
      case 245:
        c = ":";
        break;
      case 246:
        c = ";";
        break;
      case 247:
        c = "<";
        break;
      case 248:
        c = "=";
        break;
      case 249:
        c = ">";
        break;
      case 250:
        c = "?";
        break;
      case 251:
        c = "_";
        break;
      case 252:
        c = " ";
        break;
      default:
        throw new FormatException_default();
    }
    return new DecodedChar_default(pos + 8, c);
  };
  GeneralAppIdDecoder2.prototype.isStillAlpha = function(pos) {
    if (pos + 5 > this.information.getSize()) {
      return false;
    }
    var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
    if (fiveBitValue >= 5 && fiveBitValue < 16) {
      return true;
    }
    if (pos + 6 > this.information.getSize()) {
      return false;
    }
    var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
    return sixBitValue >= 16 && sixBitValue < 63;
  };
  GeneralAppIdDecoder2.prototype.decodeAlphanumeric = function(pos) {
    var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
    if (fiveBitValue === 15) {
      return new DecodedChar_default(pos + 5, DecodedChar_default.FNC1);
    }
    if (fiveBitValue >= 5 && fiveBitValue < 15) {
      return new DecodedChar_default(pos + 5, "0" + (fiveBitValue - 5));
    }
    var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
    if (sixBitValue >= 32 && sixBitValue < 58) {
      return new DecodedChar_default(pos + 6, "" + (sixBitValue + 33));
    }
    var c;
    switch (sixBitValue) {
      case 58:
        c = "*";
        break;
      case 59:
        c = ",";
        break;
      case 60:
        c = "-";
        break;
      case 61:
        c = ".";
        break;
      case 62:
        c = "/";
        break;
      default:
        throw new IllegalStateException_default("Decoding invalid alphanumeric value: " + sixBitValue);
    }
    return new DecodedChar_default(pos + 6, c);
  };
  GeneralAppIdDecoder2.prototype.isAlphaTo646ToAlphaLatch = function(pos) {
    if (pos + 1 > this.information.getSize()) {
      return false;
    }
    for (var i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
      if (i === 2) {
        if (!this.information.get(pos + 2)) {
          return false;
        }
      } else if (this.information.get(pos + i)) {
        return false;
      }
    }
    return true;
  };
  GeneralAppIdDecoder2.prototype.isAlphaOr646ToNumericLatch = function(pos) {
    if (pos + 3 > this.information.getSize()) {
      return false;
    }
    for (var i = pos; i < pos + 3; ++i) {
      if (this.information.get(i)) {
        return false;
      }
    }
    return true;
  };
  GeneralAppIdDecoder2.prototype.isNumericToAlphaNumericLatch = function(pos) {
    if (pos + 1 > this.information.getSize()) {
      return false;
    }
    for (var i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
      if (this.information.get(pos + i)) {
        return false;
      }
    }
    return true;
  };
  return GeneralAppIdDecoder2;
}();
var GeneralAppIdDecoder_default = GeneralAppIdDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js
var AbstractExpandedDecoder = function() {
  function AbstractExpandedDecoder2(information) {
    this.information = information;
    this.generalDecoder = new GeneralAppIdDecoder_default(information);
  }
  AbstractExpandedDecoder2.prototype.getInformation = function() {
    return this.information;
  };
  AbstractExpandedDecoder2.prototype.getGeneralDecoder = function() {
    return this.generalDecoder;
  };
  return AbstractExpandedDecoder2;
}();
var AbstractExpandedDecoder_default = AbstractExpandedDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01decoder.js
var __extends36 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01decoder = function(_super) {
  __extends36(AI01decoder2, _super);
  function AI01decoder2(information) {
    return _super.call(this, information) || this;
  }
  AI01decoder2.prototype.encodeCompressedGtin = function(buf, currentPos) {
    buf.append("(01)");
    var initialPosition = buf.length();
    buf.append("9");
    this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
  };
  AI01decoder2.prototype.encodeCompressedGtinWithoutAI = function(buf, currentPos, initialBufferPosition) {
    for (var i = 0; i < 4; ++i) {
      var currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
      if (currentBlock / 100 === 0) {
        buf.append("0");
      }
      if (currentBlock / 10 === 0) {
        buf.append("0");
      }
      buf.append(currentBlock);
    }
    AI01decoder2.appendCheckDigit(buf, initialBufferPosition);
  };
  AI01decoder2.appendCheckDigit = function(buf, currentPos) {
    var checkDigit = 0;
    for (var i = 0; i < 13; i++) {
      var digit = buf.charAt(i + currentPos).charCodeAt(0) - "0".charCodeAt(0);
      checkDigit += (i & 1) === 0 ? 3 * digit : digit;
    }
    checkDigit = 10 - checkDigit % 10;
    if (checkDigit === 10) {
      checkDigit = 0;
    }
    buf.append(checkDigit);
  };
  AI01decoder2.GTIN_SIZE = 40;
  return AI01decoder2;
}(AbstractExpandedDecoder_default);
var AI01decoder_default = AI01decoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js
var __extends37 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01AndOtherAIs = function(_super) {
  __extends37(AI01AndOtherAIs2, _super);
  function AI01AndOtherAIs2(information) {
    return _super.call(this, information) || this;
  }
  AI01AndOtherAIs2.prototype.parseInformation = function() {
    var buff = new StringBuilder_default();
    buff.append("(01)");
    var initialGtinPosition = buff.length();
    var firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs2.HEADER_SIZE, 4);
    buff.append(firstGtinDigit);
    this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs2.HEADER_SIZE + 4, initialGtinPosition);
    return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs2.HEADER_SIZE + 44);
  };
  AI01AndOtherAIs2.HEADER_SIZE = 1 + 1 + 2;
  return AI01AndOtherAIs2;
}(AI01decoder_default);
var AI01AndOtherAIs_default = AI01AndOtherAIs;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AnyAIDecoder.js
var __extends38 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AnyAIDecoder = function(_super) {
  __extends38(AnyAIDecoder2, _super);
  function AnyAIDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AnyAIDecoder2.prototype.parseInformation = function() {
    var buf = new StringBuilder_default();
    return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder2.HEADER_SIZE);
  };
  AnyAIDecoder2.HEADER_SIZE = 2 + 1 + 2;
  return AnyAIDecoder2;
}(AbstractExpandedDecoder_default);
var AnyAIDecoder_default = AnyAIDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01weightDecoder.js
var __extends39 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01weightDecoder = function(_super) {
  __extends39(AI01weightDecoder2, _super);
  function AI01weightDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AI01weightDecoder2.prototype.encodeCompressedWeight = function(buf, currentPos, weightSize) {
    var originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
    this.addWeightCode(buf, originalWeightNumeric);
    var weightNumeric = this.checkWeight(originalWeightNumeric);
    var currentDivisor = 1e5;
    for (var i = 0; i < 5; ++i) {
      if (weightNumeric / currentDivisor === 0) {
        buf.append("0");
      }
      currentDivisor /= 10;
    }
    buf.append(weightNumeric);
  };
  return AI01weightDecoder2;
}(AI01decoder_default);
var AI01weightDecoder_default = AI01weightDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013x0xDecoder.js
var __extends40 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI013x0xDecoder = function(_super) {
  __extends40(AI013x0xDecoder2, _super);
  function AI013x0xDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AI013x0xDecoder2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() != AI013x0xDecoder2.HEADER_SIZE + AI01weightDecoder_default.GTIN_SIZE + AI013x0xDecoder2.WEIGHT_SIZE) {
      throw new NotFoundException_default();
    }
    var buf = new StringBuilder_default();
    this.encodeCompressedGtin(buf, AI013x0xDecoder2.HEADER_SIZE);
    this.encodeCompressedWeight(buf, AI013x0xDecoder2.HEADER_SIZE + AI01weightDecoder_default.GTIN_SIZE, AI013x0xDecoder2.WEIGHT_SIZE);
    return buf.toString();
  };
  AI013x0xDecoder2.HEADER_SIZE = 4 + 1;
  AI013x0xDecoder2.WEIGHT_SIZE = 15;
  return AI013x0xDecoder2;
}(AI01weightDecoder_default);
var AI013x0xDecoder_default = AI013x0xDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013103decoder.js
var __extends41 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI013103decoder = function(_super) {
  __extends41(AI013103decoder2, _super);
  function AI013103decoder2(information) {
    return _super.call(this, information) || this;
  }
  AI013103decoder2.prototype.addWeightCode = function(buf, weight) {
    buf.append("(3103)");
  };
  AI013103decoder2.prototype.checkWeight = function(weight) {
    return weight;
  };
  return AI013103decoder2;
}(AI013x0xDecoder_default);
var AI013103decoder_default = AI013103decoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01320xDecoder.js
var __extends42 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01320xDecoder = function(_super) {
  __extends42(AI01320xDecoder2, _super);
  function AI01320xDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AI01320xDecoder2.prototype.addWeightCode = function(buf, weight) {
    if (weight < 1e4) {
      buf.append("(3202)");
    } else {
      buf.append("(3203)");
    }
  };
  AI01320xDecoder2.prototype.checkWeight = function(weight) {
    if (weight < 1e4) {
      return weight;
    }
    return weight - 1e4;
  };
  return AI01320xDecoder2;
}(AI013x0xDecoder_default);
var AI01320xDecoder_default = AI01320xDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01392xDecoder.js
var __extends43 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01392xDecoder = function(_super) {
  __extends43(AI01392xDecoder2, _super);
  function AI01392xDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AI01392xDecoder2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() < AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE) {
      throw new NotFoundException_default();
    }
    var buf = new StringBuilder_default();
    this.encodeCompressedGtin(buf, AI01392xDecoder2.HEADER_SIZE);
    var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE, AI01392xDecoder2.LAST_DIGIT_SIZE);
    buf.append("(392");
    buf.append(lastAIdigit);
    buf.append(")");
    var decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01392xDecoder2.LAST_DIGIT_SIZE, null);
    buf.append(decodedInformation.getNewString());
    return buf.toString();
  };
  AI01392xDecoder2.HEADER_SIZE = 5 + 1 + 2;
  AI01392xDecoder2.LAST_DIGIT_SIZE = 2;
  return AI01392xDecoder2;
}(AI01decoder_default);
var AI01392xDecoder_default = AI01392xDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI01393xDecoder.js
var __extends44 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI01393xDecoder = function(_super) {
  __extends44(AI01393xDecoder2, _super);
  function AI01393xDecoder2(information) {
    return _super.call(this, information) || this;
  }
  AI01393xDecoder2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() < AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE) {
      throw new NotFoundException_default();
    }
    var buf = new StringBuilder_default();
    this.encodeCompressedGtin(buf, AI01393xDecoder2.HEADER_SIZE);
    var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE, AI01393xDecoder2.LAST_DIGIT_SIZE);
    buf.append("(393");
    buf.append(lastAIdigit);
    buf.append(")");
    var firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01393xDecoder2.LAST_DIGIT_SIZE, AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE);
    if (firstThreeDigits / 100 == 0) {
      buf.append("0");
    }
    if (firstThreeDigits / 10 == 0) {
      buf.append("0");
    }
    buf.append(firstThreeDigits);
    var generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder2.HEADER_SIZE + AI01decoder_default.GTIN_SIZE + AI01393xDecoder2.LAST_DIGIT_SIZE + AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE, null);
    buf.append(generalInformation.getNewString());
    return buf.toString();
  };
  AI01393xDecoder2.HEADER_SIZE = 5 + 1 + 2;
  AI01393xDecoder2.LAST_DIGIT_SIZE = 2;
  AI01393xDecoder2.FIRST_THREE_DIGITS_SIZE = 10;
  return AI01393xDecoder2;
}(AI01decoder_default);
var AI01393xDecoder_default = AI01393xDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js
var __extends45 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AI013x0x1xDecoder = function(_super) {
  __extends45(AI013x0x1xDecoder2, _super);
  function AI013x0x1xDecoder2(information, firstAIdigits, dateCode) {
    var _this = _super.call(this, information) || this;
    _this.dateCode = dateCode;
    _this.firstAIdigits = firstAIdigits;
    return _this;
  }
  AI013x0x1xDecoder2.prototype.parseInformation = function() {
    if (this.getInformation().getSize() != AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE + AI013x0x1xDecoder2.WEIGHT_SIZE + AI013x0x1xDecoder2.DATE_SIZE) {
      throw new NotFoundException_default();
    }
    var buf = new StringBuilder_default();
    this.encodeCompressedGtin(buf, AI013x0x1xDecoder2.HEADER_SIZE);
    this.encodeCompressedWeight(buf, AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE, AI013x0x1xDecoder2.WEIGHT_SIZE);
    this.encodeCompressedDate(buf, AI013x0x1xDecoder2.HEADER_SIZE + AI013x0x1xDecoder2.GTIN_SIZE + AI013x0x1xDecoder2.WEIGHT_SIZE);
    return buf.toString();
  };
  AI013x0x1xDecoder2.prototype.encodeCompressedDate = function(buf, currentPos) {
    var numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder2.DATE_SIZE);
    if (numericDate == 38400) {
      return;
    }
    buf.append("(");
    buf.append(this.dateCode);
    buf.append(")");
    var day = numericDate % 32;
    numericDate /= 32;
    var month = numericDate % 12 + 1;
    numericDate /= 12;
    var year = numericDate;
    if (year / 10 == 0) {
      buf.append("0");
    }
    buf.append(year);
    if (month / 10 == 0) {
      buf.append("0");
    }
    buf.append(month);
    if (day / 10 == 0) {
      buf.append("0");
    }
    buf.append(day);
  };
  AI013x0x1xDecoder2.prototype.addWeightCode = function(buf, weight) {
    buf.append("(");
    buf.append(this.firstAIdigits);
    buf.append(weight / 1e5);
    buf.append(")");
  };
  AI013x0x1xDecoder2.prototype.checkWeight = function(weight) {
    return weight % 1e5;
  };
  AI013x0x1xDecoder2.HEADER_SIZE = 7 + 1;
  AI013x0x1xDecoder2.WEIGHT_SIZE = 20;
  AI013x0x1xDecoder2.DATE_SIZE = 16;
  return AI013x0x1xDecoder2;
}(AI01weightDecoder_default);
var AI013x0x1xDecoder_default = AI013x0x1xDecoder;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js
function createDecoder(information) {
  try {
    if (information.get(1)) {
      return new AI01AndOtherAIs_default(information);
    }
    if (!information.get(2)) {
      return new AnyAIDecoder_default(information);
    }
    var fourBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 4);
    switch (fourBitEncodationMethod) {
      case 4:
        return new AI013103decoder_default(information);
      case 5:
        return new AI01320xDecoder_default(information);
    }
    var fiveBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 5);
    switch (fiveBitEncodationMethod) {
      case 12:
        return new AI01392xDecoder_default(information);
      case 13:
        return new AI01393xDecoder_default(information);
    }
    var sevenBitEncodationMethod = GeneralAppIdDecoder_default.extractNumericValueFromBitArray(information, 1, 7);
    switch (sevenBitEncodationMethod) {
      case 56:
        return new AI013x0x1xDecoder_default(information, "310", "11");
      case 57:
        return new AI013x0x1xDecoder_default(information, "320", "11");
      case 58:
        return new AI013x0x1xDecoder_default(information, "310", "13");
      case 59:
        return new AI013x0x1xDecoder_default(information, "320", "13");
      case 60:
        return new AI013x0x1xDecoder_default(information, "310", "15");
      case 61:
        return new AI013x0x1xDecoder_default(information, "320", "15");
      case 62:
        return new AI013x0x1xDecoder_default(information, "310", "17");
      case 63:
        return new AI013x0x1xDecoder_default(information, "320", "17");
    }
  } catch (e) {
    console.log(e);
    throw new IllegalStateException_default("unknown decoder: " + information);
  }
}

// node_modules/@zxing/library/esm/core/oned/rss/expanded/ExpandedPair.js
var ExpandedPair = function() {
  function ExpandedPair2(leftChar, rightChar, finderPatter, mayBeLast) {
    this.leftchar = leftChar;
    this.rightchar = rightChar;
    this.finderpattern = finderPatter;
    this.maybeLast = mayBeLast;
  }
  ExpandedPair2.prototype.mayBeLast = function() {
    return this.maybeLast;
  };
  ExpandedPair2.prototype.getLeftChar = function() {
    return this.leftchar;
  };
  ExpandedPair2.prototype.getRightChar = function() {
    return this.rightchar;
  };
  ExpandedPair2.prototype.getFinderPattern = function() {
    return this.finderpattern;
  };
  ExpandedPair2.prototype.mustBeLast = function() {
    return this.rightchar == null;
  };
  ExpandedPair2.prototype.toString = function() {
    return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
  };
  ExpandedPair2.equals = function(o1, o2) {
    if (!(o1 instanceof ExpandedPair2)) {
      return false;
    }
    return ExpandedPair2.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair2.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair2.equalsOrNull(o1.finderpattern, o2.finderpattern);
  };
  ExpandedPair2.equalsOrNull = function(o1, o2) {
    return o1 === null ? o2 === null : ExpandedPair2.equals(o1, o2);
  };
  ExpandedPair2.prototype.hashCode = function() {
    var value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
    return value;
  };
  return ExpandedPair2;
}();
var ExpandedPair_default = ExpandedPair;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/ExpandedRow.js
var ExpandedRow = function() {
  function ExpandedRow2(pairs, rowNumber, wasReversed) {
    this.pairs = pairs;
    this.rowNumber = rowNumber;
    this.wasReversed = wasReversed;
  }
  ExpandedRow2.prototype.getPairs = function() {
    return this.pairs;
  };
  ExpandedRow2.prototype.getRowNumber = function() {
    return this.rowNumber;
  };
  ExpandedRow2.prototype.isReversed = function() {
    return this.wasReversed;
  };
  ExpandedRow2.prototype.isEquivalent = function(otherPairs) {
    return this.checkEqualitity(this, otherPairs);
  };
  ExpandedRow2.prototype.toString = function() {
    return "{ " + this.pairs + " }";
  };
  ExpandedRow2.prototype.equals = function(o1, o2) {
    if (!(o1 instanceof ExpandedRow2)) {
      return false;
    }
    return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
  };
  ExpandedRow2.prototype.checkEqualitity = function(pair1, pair2) {
    if (!pair1 || !pair2)
      return;
    var result;
    pair1.forEach(function(e1, i) {
      pair2.forEach(function(e2) {
        if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
          result = true;
        }
      });
    });
    return result;
  };
  return ExpandedRow2;
}();
var ExpandedRow_default = ExpandedRow;

// node_modules/@zxing/library/esm/core/oned/rss/expanded/RSSExpandedReader.js
var __extends46 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values15 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var RSSExpandedReader = function(_super) {
  __extends46(RSSExpandedReader2, _super);
  function RSSExpandedReader2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.pairs = new Array(RSSExpandedReader2.MAX_PAIRS);
    _this.rows = new Array();
    _this.startEnd = [2];
    return _this;
  }
  RSSExpandedReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    this.pairs.length = 0;
    this.startFromEven = false;
    try {
      return RSSExpandedReader2.constructResult(this.decodeRow2pairs(rowNumber, row));
    } catch (e) {
    }
    this.pairs.length = 0;
    this.startFromEven = true;
    return RSSExpandedReader2.constructResult(this.decodeRow2pairs(rowNumber, row));
  };
  RSSExpandedReader2.prototype.reset = function() {
    this.pairs.length = 0;
    this.rows.length = 0;
  };
  RSSExpandedReader2.prototype.decodeRow2pairs = function(rowNumber, row) {
    var done = false;
    while (!done) {
      try {
        this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
      } catch (error) {
        if (error instanceof NotFoundException_default) {
          if (!this.pairs.length) {
            throw new NotFoundException_default();
          }
          done = true;
        }
      }
    }
    if (this.checkChecksum()) {
      return this.pairs;
    }
    var tryStackedDecode;
    if (this.rows.length) {
      tryStackedDecode = true;
    } else {
      tryStackedDecode = false;
    }
    this.storeRow(rowNumber, false);
    if (tryStackedDecode) {
      var ps = this.checkRowsBoolean(false);
      if (ps != null) {
        return ps;
      }
      ps = this.checkRowsBoolean(true);
      if (ps != null) {
        return ps;
      }
    }
    throw new NotFoundException_default();
  };
  RSSExpandedReader2.prototype.checkRowsBoolean = function(reverse) {
    if (this.rows.length > 25) {
      this.rows.length = 0;
      return null;
    }
    this.pairs.length = 0;
    if (reverse) {
      this.rows = this.rows.reverse();
    }
    var ps = null;
    try {
      ps = this.checkRows(new Array(), 0);
    } catch (e) {
      console.log(e);
    }
    if (reverse) {
      this.rows = this.rows.reverse();
    }
    return ps;
  };
  RSSExpandedReader2.prototype.checkRows = function(collectedRows, currentRow) {
    var e_1, _a;
    for (var i = currentRow; i < this.rows.length; i++) {
      var row = this.rows[i];
      this.pairs.length = 0;
      try {
        for (var collectedRows_1 = (e_1 = void 0, __values15(collectedRows)), collectedRows_1_1 = collectedRows_1.next(); !collectedRows_1_1.done; collectedRows_1_1 = collectedRows_1.next()) {
          var collectedRow = collectedRows_1_1.value;
          this.pairs.push(collectedRow.getPairs());
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (collectedRows_1_1 && !collectedRows_1_1.done && (_a = collectedRows_1.return))
            _a.call(collectedRows_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      this.pairs.push(row.getPairs());
      if (!RSSExpandedReader2.isValidSequence(this.pairs)) {
        continue;
      }
      if (this.checkChecksum()) {
        return this.pairs;
      }
      var rs = new Array(collectedRows);
      rs.push(row);
      try {
        return this.checkRows(rs, i + 1);
      } catch (e) {
        console.log(e);
      }
    }
    throw new NotFoundException_default();
  };
  RSSExpandedReader2.isValidSequence = function(pairs) {
    var e_2, _a;
    try {
      for (var _b = __values15(RSSExpandedReader2.FINDER_PATTERN_SEQUENCES), _c = _b.next(); !_c.done; _c = _b.next()) {
        var sequence = _c.value;
        if (pairs.length > sequence.length) {
          continue;
        }
        var stop_1 = true;
        for (var j = 0; j < pairs.length; j++) {
          if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
            stop_1 = false;
            break;
          }
        }
        if (stop_1) {
          return true;
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return false;
  };
  RSSExpandedReader2.prototype.storeRow = function(rowNumber, wasReversed) {
    var insertPos = 0;
    var prevIsSame = false;
    var nextIsSame = false;
    while (insertPos < this.rows.length) {
      var erow = this.rows[insertPos];
      if (erow.getRowNumber() > rowNumber) {
        nextIsSame = erow.isEquivalent(this.pairs);
        break;
      }
      prevIsSame = erow.isEquivalent(this.pairs);
      insertPos++;
    }
    if (nextIsSame || prevIsSame) {
      return;
    }
    if (RSSExpandedReader2.isPartialRow(this.pairs, this.rows)) {
      return;
    }
    this.rows.push(insertPos, new ExpandedRow_default(this.pairs, rowNumber, wasReversed));
    this.removePartialRows(this.pairs, this.rows);
  };
  RSSExpandedReader2.prototype.removePartialRows = function(pairs, rows) {
    var e_3, _a, e_4, _b, e_5, _c;
    try {
      for (var rows_1 = __values15(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
        var row = rows_1_1.value;
        if (row.getPairs().length === pairs.length) {
          continue;
        }
        var allFound = true;
        try {
          for (var _d = (e_4 = void 0, __values15(row.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {
            var p = _e.value;
            var found = false;
            try {
              for (var pairs_1 = (e_5 = void 0, __values15(pairs)), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                var pp = pairs_1_1.value;
                if (ExpandedPair_default.equals(p, pp)) {
                  found = true;
                  break;
                }
              }
            } catch (e_5_1) {
              e_5 = {error: e_5_1};
            } finally {
              try {
                if (pairs_1_1 && !pairs_1_1.done && (_c = pairs_1.return))
                  _c.call(pairs_1);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
            if (!found) {
              allFound = false;
            }
          }
        } catch (e_4_1) {
          e_4 = {error: e_4_1};
        } finally {
          try {
            if (_e && !_e.done && (_b = _d.return))
              _b.call(_d);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return))
          _a.call(rows_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  RSSExpandedReader2.isPartialRow = function(pairs, rows) {
    var e_6, _a, e_7, _b, e_8, _c;
    try {
      for (var rows_2 = __values15(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {
        var r = rows_2_1.value;
        var allFound = true;
        try {
          for (var pairs_2 = (e_7 = void 0, __values15(pairs)), pairs_2_1 = pairs_2.next(); !pairs_2_1.done; pairs_2_1 = pairs_2.next()) {
            var p = pairs_2_1.value;
            var found = false;
            try {
              for (var _d = (e_8 = void 0, __values15(r.getPairs())), _e = _d.next(); !_e.done; _e = _d.next()) {
                var pp = _e.value;
                if (p.equals(pp)) {
                  found = true;
                  break;
                }
              }
            } catch (e_8_1) {
              e_8 = {error: e_8_1};
            } finally {
              try {
                if (_e && !_e.done && (_c = _d.return))
                  _c.call(_d);
              } finally {
                if (e_8)
                  throw e_8.error;
              }
            }
            if (!found) {
              allFound = false;
              break;
            }
          }
        } catch (e_7_1) {
          e_7 = {error: e_7_1};
        } finally {
          try {
            if (pairs_2_1 && !pairs_2_1.done && (_b = pairs_2.return))
              _b.call(pairs_2);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
        if (allFound) {
          return true;
        }
      }
    } catch (e_6_1) {
      e_6 = {error: e_6_1};
    } finally {
      try {
        if (rows_2_1 && !rows_2_1.done && (_a = rows_2.return))
          _a.call(rows_2);
      } finally {
        if (e_6)
          throw e_6.error;
      }
    }
    return false;
  };
  RSSExpandedReader2.prototype.getRows = function() {
    return this.rows;
  };
  RSSExpandedReader2.constructResult = function(pairs) {
    var binary = BitArrayBuilder_default.buildBitArray(pairs);
    var decoder = createDecoder(binary);
    var resultingString = decoder.parseInformation();
    var firstPoints = pairs[0].getFinderPattern().getResultPoints();
    var lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
    var points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
    return new Result_default(resultingString, null, null, points, BarcodeFormat_default.RSS_EXPANDED, null);
  };
  RSSExpandedReader2.prototype.checkChecksum = function() {
    var firstPair = this.pairs.get(0);
    var checkCharacter = firstPair.getLeftChar();
    var firstCharacter = firstPair.getRightChar();
    if (firstCharacter == null) {
      return false;
    }
    var checksum = firstCharacter.getChecksumPortion();
    var s = 2;
    for (var i = 1; i < this.pairs.size(); ++i) {
      var currentPair = this.pairs.get(i);
      checksum += currentPair.getLeftChar().getChecksumPortion();
      s++;
      var currentRightChar = currentPair.getRightChar();
      if (currentRightChar != null) {
        checksum += currentRightChar.getChecksumPortion();
        s++;
      }
    }
    checksum %= 211;
    var checkCharacterValue = 211 * (s - 4) + checksum;
    return checkCharacterValue == checkCharacter.getValue();
  };
  RSSExpandedReader2.getNextSecondBar = function(row, initialPos) {
    var currentPos;
    if (row.get(initialPos)) {
      currentPos = row.getNextUnset(initialPos);
      currentPos = row.getNextSet(currentPos);
    } else {
      currentPos = row.getNextSet(initialPos);
      currentPos = row.getNextUnset(currentPos);
    }
    return currentPos;
  };
  RSSExpandedReader2.prototype.retrieveNextPair = function(row, previousPairs, rowNumber) {
    var isOddPattern = previousPairs.length % 2 == 0;
    if (this.startFromEven) {
      isOddPattern = !isOddPattern;
    }
    var pattern;
    var keepFinding = true;
    var forcedOffset = -1;
    do {
      this.findNextPair(row, previousPairs, forcedOffset);
      pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
      if (pattern == null) {
        forcedOffset = RSSExpandedReader2.getNextSecondBar(row, this.startEnd[0]);
      } else {
        keepFinding = false;
      }
    } while (keepFinding);
    var leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
    if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
      throw new NotFoundException_default();
    }
    var rightChar;
    try {
      rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
    } catch (e) {
      rightChar = null;
      console.log(e);
    }
    return new ExpandedPair_default(leftChar, rightChar, pattern, true);
  };
  RSSExpandedReader2.prototype.isEmptyPair = function(pairs) {
    if (pairs.length === 0) {
      return true;
    }
    return false;
  };
  RSSExpandedReader2.prototype.findNextPair = function(row, previousPairs, forcedOffset) {
    var counters = this.getDecodeFinderCounters();
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var width = row.getSize();
    var rowOffset;
    if (forcedOffset >= 0) {
      rowOffset = forcedOffset;
    } else if (this.isEmptyPair(previousPairs)) {
      rowOffset = 0;
    } else {
      var lastPair = previousPairs[previousPairs.length - 1];
      rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
    }
    var searchingEvenPair = previousPairs.length % 2 != 0;
    if (this.startFromEven) {
      searchingEvenPair = !searchingEvenPair;
    }
    var isWhite = false;
    while (rowOffset < width) {
      isWhite = !row.get(rowOffset);
      if (!isWhite) {
        break;
      }
      rowOffset++;
    }
    var counterPosition = 0;
    var patternStart = rowOffset;
    for (var x2 = rowOffset; x2 < width; x2++) {
      if (row.get(x2) != isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition == 3) {
          if (searchingEvenPair) {
            RSSExpandedReader2.reverseCounters(counters);
          }
          if (RSSExpandedReader2.isFinderPattern(counters)) {
            this.startEnd[0] = patternStart;
            this.startEnd[1] = x2;
            return;
          }
          if (searchingEvenPair) {
            RSSExpandedReader2.reverseCounters(counters);
          }
          patternStart += counters[0] + counters[1];
          counters[0] = counters[2];
          counters[1] = counters[3];
          counters[2] = 0;
          counters[3] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  RSSExpandedReader2.reverseCounters = function(counters) {
    var length = counters.length;
    for (var i = 0; i < length / 2; ++i) {
      var tmp = counters[i];
      counters[i] = counters[length - i - 1];
      counters[length - i - 1] = tmp;
    }
  };
  RSSExpandedReader2.prototype.parseFoundFinderPattern = function(row, rowNumber, oddPattern) {
    var firstCounter;
    var start;
    var end;
    if (oddPattern) {
      var firstElementStart = this.startEnd[0] - 1;
      while (firstElementStart >= 0 && !row.get(firstElementStart)) {
        firstElementStart--;
      }
      firstElementStart++;
      firstCounter = this.startEnd[0] - firstElementStart;
      start = firstElementStart;
      end = this.startEnd[1];
    } else {
      start = this.startEnd[0];
      end = row.getNextUnset(this.startEnd[1] + 1);
      firstCounter = end - this.startEnd[1];
    }
    var counters = this.getDecodeFinderCounters();
    System_default.arraycopy(counters, 0, counters, 1, counters.length - 1);
    counters[0] = firstCounter;
    var value;
    try {
      value = this.parseFinderValue(counters, RSSExpandedReader2.FINDER_PATTERNS);
    } catch (e) {
      return null;
      console.log(e);
    }
    return new FinderPattern_default(value, [start, end], start, end, rowNumber);
  };
  RSSExpandedReader2.prototype.decodeDataCharacter = function(row, pattern, isOddPattern, leftChar) {
    var counters = this.getDataCharacterCounters();
    for (var x2 = 0; x2 < counters.length; x2++) {
      counters[x2] = 0;
    }
    if (leftChar) {
      RSSExpandedReader2.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
    } else {
      RSSExpandedReader2.recordPattern(row, pattern.getStartEnd()[1], counters);
      for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
        var temp = counters[i];
        counters[i] = counters[j];
        counters[j] = temp;
      }
    }
    var numModules = 17;
    var elementWidth = MathUtils_default.sum(new Int32Array(counters)) / numModules;
    var expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
    if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
      throw new NotFoundException_default();
    }
    var oddCounts = this.getOddCounts();
    var evenCounts = this.getEvenCounts();
    var oddRoundingErrors = this.getOddRoundingErrors();
    var evenRoundingErrors = this.getEvenRoundingErrors();
    for (var i = 0; i < counters.length; i++) {
      var value_1 = 1 * counters[i] / elementWidth;
      var count = value_1 + 0.5;
      if (count < 1) {
        if (value_1 < 0.3) {
          throw new NotFoundException_default();
        }
        count = 1;
      } else if (count > 8) {
        if (value_1 > 8.7) {
          throw new NotFoundException_default();
        }
        count = 8;
      }
      var offset = i / 2;
      if ((i & 1) == 0) {
        oddCounts[offset] = count;
        oddRoundingErrors[offset] = value_1 - count;
      } else {
        evenCounts[offset] = count;
        evenRoundingErrors[offset] = value_1 - count;
      }
    }
    this.adjustOddEvenCounts(numModules);
    var weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
    var oddSum = 0;
    var oddChecksumPortion = 0;
    for (var i = oddCounts.length - 1; i >= 0; i--) {
      if (RSSExpandedReader2.isNotA1left(pattern, isOddPattern, leftChar)) {
        var weight = RSSExpandedReader2.WEIGHTS[weightRowNumber][2 * i];
        oddChecksumPortion += oddCounts[i] * weight;
      }
      oddSum += oddCounts[i];
    }
    var evenChecksumPortion = 0;
    for (var i = evenCounts.length - 1; i >= 0; i--) {
      if (RSSExpandedReader2.isNotA1left(pattern, isOddPattern, leftChar)) {
        var weight = RSSExpandedReader2.WEIGHTS[weightRowNumber][2 * i + 1];
        evenChecksumPortion += evenCounts[i] * weight;
      }
    }
    var checksumPortion = oddChecksumPortion + evenChecksumPortion;
    if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
      throw new NotFoundException_default();
    }
    var group = (13 - oddSum) / 2;
    var oddWidest = RSSExpandedReader2.SYMBOL_WIDEST[group];
    var evenWidest = 9 - oddWidest;
    var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, true);
    var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, false);
    var tEven = RSSExpandedReader2.EVEN_TOTAL_SUBSET[group];
    var gSum = RSSExpandedReader2.GSUM[group];
    var value = vOdd * tEven + vEven + gSum;
    return new DataCharacter_default(value, checksumPortion);
  };
  RSSExpandedReader2.isNotA1left = function(pattern, isOddPattern, leftChar) {
    return !(pattern.getValue() == 0 && isOddPattern && leftChar);
  };
  RSSExpandedReader2.prototype.adjustOddEvenCounts = function(numModules) {
    var oddSum = MathUtils_default.sum(new Int32Array(this.getOddCounts()));
    var evenSum = MathUtils_default.sum(new Int32Array(this.getEvenCounts()));
    var incrementOdd = false;
    var decrementOdd = false;
    if (oddSum > 13) {
      decrementOdd = true;
    } else if (oddSum < 4) {
      incrementOdd = true;
    }
    var incrementEven = false;
    var decrementEven = false;
    if (evenSum > 13) {
      decrementEven = true;
    } else if (evenSum < 4) {
      incrementEven = true;
    }
    var mismatch = oddSum + evenSum - numModules;
    var oddParityBad = (oddSum & 1) == 1;
    var evenParityBad = (evenSum & 1) == 0;
    if (mismatch == 1) {
      if (oddParityBad) {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
        decrementOdd = true;
      } else {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        decrementEven = true;
      }
    } else if (mismatch == -1) {
      if (oddParityBad) {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
        incrementOdd = true;
      } else {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        incrementEven = true;
      }
    } else if (mismatch == 0) {
      if (oddParityBad) {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        if (oddSum < evenSum) {
          incrementOdd = true;
          decrementEven = true;
        } else {
          decrementOdd = true;
          incrementEven = true;
        }
      } else {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
      }
    } else {
      throw new NotFoundException_default();
    }
    if (incrementOdd) {
      if (decrementOdd) {
        throw new NotFoundException_default();
      }
      RSSExpandedReader2.increment(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (decrementOdd) {
      RSSExpandedReader2.decrement(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (incrementEven) {
      if (decrementEven) {
        throw new NotFoundException_default();
      }
      RSSExpandedReader2.increment(this.getEvenCounts(), this.getOddRoundingErrors());
    }
    if (decrementEven) {
      RSSExpandedReader2.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
    }
  };
  RSSExpandedReader2.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
  RSSExpandedReader2.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
  RSSExpandedReader2.GSUM = [0, 348, 1388, 2948, 3988];
  RSSExpandedReader2.FINDER_PATTERNS = [
    Int32Array.from([1, 8, 4, 1]),
    Int32Array.from([3, 6, 4, 1]),
    Int32Array.from([3, 4, 6, 1]),
    Int32Array.from([3, 2, 8, 1]),
    Int32Array.from([2, 6, 5, 1]),
    Int32Array.from([2, 2, 9, 1])
  ];
  RSSExpandedReader2.WEIGHTS = [
    [1, 3, 9, 27, 81, 32, 96, 77],
    [20, 60, 180, 118, 143, 7, 21, 63],
    [189, 145, 13, 39, 117, 140, 209, 205],
    [193, 157, 49, 147, 19, 57, 171, 91],
    [62, 186, 136, 197, 169, 85, 44, 132],
    [185, 133, 188, 142, 4, 12, 36, 108],
    [113, 128, 173, 97, 80, 29, 87, 50],
    [150, 28, 84, 41, 123, 158, 52, 156],
    [46, 138, 203, 187, 139, 206, 196, 166],
    [76, 17, 51, 153, 37, 111, 122, 155],
    [43, 129, 176, 106, 107, 110, 119, 146],
    [16, 48, 144, 10, 30, 90, 59, 177],
    [109, 116, 137, 200, 178, 112, 125, 164],
    [70, 210, 208, 202, 184, 130, 179, 115],
    [134, 191, 151, 31, 93, 68, 204, 190],
    [148, 22, 66, 198, 172, 94, 71, 2],
    [6, 18, 54, 162, 64, 192, 154, 40],
    [120, 149, 25, 75, 14, 42, 126, 167],
    [79, 26, 78, 23, 69, 207, 199, 175],
    [103, 98, 83, 38, 114, 131, 182, 124],
    [161, 61, 183, 127, 170, 88, 53, 159],
    [55, 165, 73, 8, 24, 72, 5, 15],
    [45, 135, 194, 160, 58, 174, 100, 89]
  ];
  RSSExpandedReader2.FINDER_PAT_A = 0;
  RSSExpandedReader2.FINDER_PAT_B = 1;
  RSSExpandedReader2.FINDER_PAT_C = 2;
  RSSExpandedReader2.FINDER_PAT_D = 3;
  RSSExpandedReader2.FINDER_PAT_E = 4;
  RSSExpandedReader2.FINDER_PAT_F = 5;
  RSSExpandedReader2.FINDER_PATTERN_SEQUENCES = [
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_B],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_D],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_C],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_F],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_F, RSSExpandedReader2.FINDER_PAT_F],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_D],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_E],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_F, RSSExpandedReader2.FINDER_PAT_F],
    [RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_A, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_B, RSSExpandedReader2.FINDER_PAT_C, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_D, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_E, RSSExpandedReader2.FINDER_PAT_F, RSSExpandedReader2.FINDER_PAT_F]
  ];
  RSSExpandedReader2.MAX_PAIRS = 11;
  return RSSExpandedReader2;
}(AbstractRSSReader_default);
var RSSExpandedReader_default = RSSExpandedReader;

// node_modules/@zxing/library/esm/core/oned/rss/Pair.js
var __extends47 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Pair = function(_super) {
  __extends47(Pair2, _super);
  function Pair2(value, checksumPortion, finderPattern) {
    var _this = _super.call(this, value, checksumPortion) || this;
    _this.count = 0;
    _this.finderPattern = finderPattern;
    return _this;
  }
  Pair2.prototype.getFinderPattern = function() {
    return this.finderPattern;
  };
  Pair2.prototype.getCount = function() {
    return this.count;
  };
  Pair2.prototype.incrementCount = function() {
    this.count++;
  };
  return Pair2;
}(DataCharacter_default);
var Pair_default = Pair;

// node_modules/@zxing/library/esm/core/oned/rss/RSS14Reader.js
var __extends48 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values16 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var RSS14Reader = function(_super) {
  __extends48(RSS14Reader2, _super);
  function RSS14Reader2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.possibleLeftPairs = [];
    _this.possibleRightPairs = [];
    return _this;
  }
  RSS14Reader2.prototype.decodeRow = function(rowNumber, row, hints) {
    var e_1, _a, e_2, _b;
    var leftPair = this.decodePair(row, false, rowNumber, hints);
    RSS14Reader2.addOrTally(this.possibleLeftPairs, leftPair);
    row.reverse();
    var rightPair = this.decodePair(row, true, rowNumber, hints);
    RSS14Reader2.addOrTally(this.possibleRightPairs, rightPair);
    row.reverse();
    try {
      for (var _c = __values16(this.possibleLeftPairs), _d = _c.next(); !_d.done; _d = _c.next()) {
        var left = _d.value;
        if (left.getCount() > 1) {
          try {
            for (var _e = (e_2 = void 0, __values16(this.possibleRightPairs)), _f = _e.next(); !_f.done; _f = _e.next()) {
              var right = _f.value;
              if (right.getCount() > 1 && RSS14Reader2.checkChecksum(left, right)) {
                return RSS14Reader2.constructResult(left, right);
              }
            }
          } catch (e_2_1) {
            e_2 = {error: e_2_1};
          } finally {
            try {
              if (_f && !_f.done && (_b = _e.return))
                _b.call(_e);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    throw new NotFoundException_default();
  };
  RSS14Reader2.addOrTally = function(possiblePairs, pair) {
    var e_3, _a;
    if (pair == null) {
      return;
    }
    var found = false;
    try {
      for (var possiblePairs_1 = __values16(possiblePairs), possiblePairs_1_1 = possiblePairs_1.next(); !possiblePairs_1_1.done; possiblePairs_1_1 = possiblePairs_1.next()) {
        var other = possiblePairs_1_1.value;
        if (other.getValue() === pair.getValue()) {
          other.incrementCount();
          found = true;
          break;
        }
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (possiblePairs_1_1 && !possiblePairs_1_1.done && (_a = possiblePairs_1.return))
          _a.call(possiblePairs_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    if (!found) {
      possiblePairs.push(pair);
    }
  };
  RSS14Reader2.prototype.reset = function() {
    this.possibleLeftPairs.length = 0;
    this.possibleRightPairs.length = 0;
  };
  RSS14Reader2.constructResult = function(leftPair, rightPair) {
    var symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
    var text = new String(symbolValue).toString();
    var buffer = new StringBuilder_default();
    for (var i = 13 - text.length; i > 0; i--) {
      buffer.append("0");
    }
    buffer.append(text);
    var checkDigit = 0;
    for (var i = 0; i < 13; i++) {
      var digit = buffer.charAt(i).charCodeAt(0) - "0".charCodeAt(0);
      checkDigit += (i & 1) === 0 ? 3 * digit : digit;
    }
    checkDigit = 10 - checkDigit % 10;
    if (checkDigit === 10) {
      checkDigit = 0;
    }
    buffer.append(checkDigit.toString());
    var leftPoints = leftPair.getFinderPattern().getResultPoints();
    var rightPoints = rightPair.getFinderPattern().getResultPoints();
    return new Result_default(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat_default.RSS_14, new Date().getTime());
  };
  RSS14Reader2.checkChecksum = function(leftPair, rightPair) {
    var checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
    var targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
    if (targetCheckValue > 72) {
      targetCheckValue--;
    }
    if (targetCheckValue > 8) {
      targetCheckValue--;
    }
    return checkValue === targetCheckValue;
  };
  RSS14Reader2.prototype.decodePair = function(row, right, rowNumber, hints) {
    try {
      var startEnd = this.findFinderPattern(row, right);
      var pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
      var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
      if (resultPointCallback != null) {
        var center = (startEnd[0] + startEnd[1]) / 2;
        if (right) {
          center = row.getSize() - 1 - center;
        }
        resultPointCallback.foundPossibleResultPoint(new ResultPoint_default(center, rowNumber));
      }
      var outside = this.decodeDataCharacter(row, pattern, true);
      var inside = this.decodeDataCharacter(row, pattern, false);
      return new Pair_default(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
    } catch (err2) {
      return null;
    }
  };
  RSS14Reader2.prototype.decodeDataCharacter = function(row, pattern, outsideChar) {
    var counters = this.getDataCharacterCounters();
    for (var x2 = 0; x2 < counters.length; x2++) {
      counters[x2] = 0;
    }
    if (outsideChar) {
      OneDReader_default.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
    } else {
      OneDReader_default.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
      for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
        var temp = counters[i];
        counters[i] = counters[j];
        counters[j] = temp;
      }
    }
    var numModules = outsideChar ? 16 : 15;
    var elementWidth = MathUtils_default.sum(new Int32Array(counters)) / numModules;
    var oddCounts = this.getOddCounts();
    var evenCounts = this.getEvenCounts();
    var oddRoundingErrors = this.getOddRoundingErrors();
    var evenRoundingErrors = this.getEvenRoundingErrors();
    for (var i = 0; i < counters.length; i++) {
      var value = counters[i] / elementWidth;
      var count = Math.floor(value + 0.5);
      if (count < 1) {
        count = 1;
      } else if (count > 8) {
        count = 8;
      }
      var offset = Math.floor(i / 2);
      if ((i & 1) === 0) {
        oddCounts[offset] = count;
        oddRoundingErrors[offset] = value - count;
      } else {
        evenCounts[offset] = count;
        evenRoundingErrors[offset] = value - count;
      }
    }
    this.adjustOddEvenCounts(outsideChar, numModules);
    var oddSum = 0;
    var oddChecksumPortion = 0;
    for (var i = oddCounts.length - 1; i >= 0; i--) {
      oddChecksumPortion *= 9;
      oddChecksumPortion += oddCounts[i];
      oddSum += oddCounts[i];
    }
    var evenChecksumPortion = 0;
    var evenSum = 0;
    for (var i = evenCounts.length - 1; i >= 0; i--) {
      evenChecksumPortion *= 9;
      evenChecksumPortion += evenCounts[i];
      evenSum += evenCounts[i];
    }
    var checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
    if (outsideChar) {
      if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
        throw new NotFoundException_default();
      }
      var group = (12 - oddSum) / 2;
      var oddWidest = RSS14Reader2.OUTSIDE_ODD_WIDEST[group];
      var evenWidest = 9 - oddWidest;
      var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, false);
      var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, true);
      var tEven = RSS14Reader2.OUTSIDE_EVEN_TOTAL_SUBSET[group];
      var gSum = RSS14Reader2.OUTSIDE_GSUM[group];
      return new DataCharacter_default(vOdd * tEven + vEven + gSum, checksumPortion);
    } else {
      if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
        throw new NotFoundException_default();
      }
      var group = (10 - evenSum) / 2;
      var oddWidest = RSS14Reader2.INSIDE_ODD_WIDEST[group];
      var evenWidest = 9 - oddWidest;
      var vOdd = RSSUtils_default.getRSSvalue(oddCounts, oddWidest, true);
      var vEven = RSSUtils_default.getRSSvalue(evenCounts, evenWidest, false);
      var tOdd = RSS14Reader2.INSIDE_ODD_TOTAL_SUBSET[group];
      var gSum = RSS14Reader2.INSIDE_GSUM[group];
      return new DataCharacter_default(vEven * tOdd + vOdd + gSum, checksumPortion);
    }
  };
  RSS14Reader2.prototype.findFinderPattern = function(row, rightFinderPattern) {
    var counters = this.getDecodeFinderCounters();
    counters[0] = 0;
    counters[1] = 0;
    counters[2] = 0;
    counters[3] = 0;
    var width = row.getSize();
    var isWhite = false;
    var rowOffset = 0;
    while (rowOffset < width) {
      isWhite = !row.get(rowOffset);
      if (rightFinderPattern === isWhite) {
        break;
      }
      rowOffset++;
    }
    var counterPosition = 0;
    var patternStart = rowOffset;
    for (var x2 = rowOffset; x2 < width; x2++) {
      if (row.get(x2) !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === 3) {
          if (AbstractRSSReader_default.isFinderPattern(counters)) {
            return [patternStart, x2];
          }
          patternStart += counters[0] + counters[1];
          counters[0] = counters[2];
          counters[1] = counters[3];
          counters[2] = 0;
          counters[3] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    throw new NotFoundException_default();
  };
  RSS14Reader2.prototype.parseFoundFinderPattern = function(row, rowNumber, right, startEnd) {
    var firstIsBlack = row.get(startEnd[0]);
    var firstElementStart = startEnd[0] - 1;
    while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
      firstElementStart--;
    }
    firstElementStart++;
    var firstCounter = startEnd[0] - firstElementStart;
    var counters = this.getDecodeFinderCounters();
    var copy = new Int32Array(counters.length);
    System_default.arraycopy(counters, 0, copy, 1, counters.length - 1);
    copy[0] = firstCounter;
    var value = this.parseFinderValue(copy, RSS14Reader2.FINDER_PATTERNS);
    var start = firstElementStart;
    var end = startEnd[1];
    if (right) {
      start = row.getSize() - 1 - start;
      end = row.getSize() - 1 - end;
    }
    return new FinderPattern_default(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
  };
  RSS14Reader2.prototype.adjustOddEvenCounts = function(outsideChar, numModules) {
    var oddSum = MathUtils_default.sum(new Int32Array(this.getOddCounts()));
    var evenSum = MathUtils_default.sum(new Int32Array(this.getEvenCounts()));
    var incrementOdd = false;
    var decrementOdd = false;
    var incrementEven = false;
    var decrementEven = false;
    if (outsideChar) {
      if (oddSum > 12) {
        decrementOdd = true;
      } else if (oddSum < 4) {
        incrementOdd = true;
      }
      if (evenSum > 12) {
        decrementEven = true;
      } else if (evenSum < 4) {
        incrementEven = true;
      }
    } else {
      if (oddSum > 11) {
        decrementOdd = true;
      } else if (oddSum < 5) {
        incrementOdd = true;
      }
      if (evenSum > 10) {
        decrementEven = true;
      } else if (evenSum < 4) {
        incrementEven = true;
      }
    }
    var mismatch = oddSum + evenSum - numModules;
    var oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
    var evenParityBad = (evenSum & 1) === 1;
    if (mismatch === 1) {
      if (oddParityBad) {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
        decrementOdd = true;
      } else {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        decrementEven = true;
      }
    } else if (mismatch === -1) {
      if (oddParityBad) {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
        incrementOdd = true;
      } else {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        incrementEven = true;
      }
    } else if (mismatch === 0) {
      if (oddParityBad) {
        if (!evenParityBad) {
          throw new NotFoundException_default();
        }
        if (oddSum < evenSum) {
          incrementOdd = true;
          decrementEven = true;
        } else {
          decrementOdd = true;
          incrementEven = true;
        }
      } else {
        if (evenParityBad) {
          throw new NotFoundException_default();
        }
      }
    } else {
      throw new NotFoundException_default();
    }
    if (incrementOdd) {
      if (decrementOdd) {
        throw new NotFoundException_default();
      }
      AbstractRSSReader_default.increment(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (decrementOdd) {
      AbstractRSSReader_default.decrement(this.getOddCounts(), this.getOddRoundingErrors());
    }
    if (incrementEven) {
      if (decrementEven) {
        throw new NotFoundException_default();
      }
      AbstractRSSReader_default.increment(this.getEvenCounts(), this.getOddRoundingErrors());
    }
    if (decrementEven) {
      AbstractRSSReader_default.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
    }
  };
  RSS14Reader2.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
  RSS14Reader2.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
  RSS14Reader2.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
  RSS14Reader2.INSIDE_GSUM = [0, 336, 1036, 1516];
  RSS14Reader2.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
  RSS14Reader2.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
  RSS14Reader2.FINDER_PATTERNS = [
    Int32Array.from([3, 8, 2, 1]),
    Int32Array.from([3, 5, 5, 1]),
    Int32Array.from([3, 3, 7, 1]),
    Int32Array.from([3, 1, 9, 1]),
    Int32Array.from([2, 7, 4, 1]),
    Int32Array.from([2, 5, 6, 1]),
    Int32Array.from([2, 3, 8, 1]),
    Int32Array.from([1, 5, 7, 1]),
    Int32Array.from([1, 3, 9, 1])
  ];
  return RSS14Reader2;
}(AbstractRSSReader_default);
var RSS14Reader_default = RSS14Reader;

// node_modules/@zxing/library/esm/core/oned/MultiFormatOneDReader.js
var __extends49 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var MultiFormatOneDReader = function(_super) {
  __extends49(MultiFormatOneDReader2, _super);
  function MultiFormatOneDReader2(hints) {
    var _this = _super.call(this) || this;
    _this.readers = [];
    var possibleFormats = !hints ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
    var useCode39CheckDigit = hints && hints.get(DecodeHintType_default.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
    if (possibleFormats) {
      if (possibleFormats.includes(BarcodeFormat_default.EAN_13) || possibleFormats.includes(BarcodeFormat_default.UPC_A) || possibleFormats.includes(BarcodeFormat_default.EAN_8) || possibleFormats.includes(BarcodeFormat_default.UPC_E)) {
        _this.readers.push(new MultiFormatUPCEANReader_default(hints));
      }
      if (possibleFormats.includes(BarcodeFormat_default.CODE_39)) {
        _this.readers.push(new Code39Reader_default(useCode39CheckDigit));
      }
      if (possibleFormats.includes(BarcodeFormat_default.CODE_128)) {
        _this.readers.push(new Code128Reader_default());
      }
      if (possibleFormats.includes(BarcodeFormat_default.ITF)) {
        _this.readers.push(new ITFReader_default());
      }
      if (possibleFormats.includes(BarcodeFormat_default.RSS_14)) {
        _this.readers.push(new RSS14Reader_default());
      }
      if (possibleFormats.includes(BarcodeFormat_default.RSS_EXPANDED)) {
        console.warn("RSS Expanded reader IS NOT ready for production yet! use at your own risk.");
        _this.readers.push(new RSSExpandedReader_default());
      }
    }
    if (_this.readers.length === 0) {
      _this.readers.push(new MultiFormatUPCEANReader_default(hints));
      _this.readers.push(new Code39Reader_default());
      _this.readers.push(new MultiFormatUPCEANReader_default(hints));
      _this.readers.push(new Code128Reader_default());
      _this.readers.push(new ITFReader_default());
      _this.readers.push(new RSS14Reader_default());
    }
    return _this;
  }
  MultiFormatOneDReader2.prototype.decodeRow = function(rowNumber, row, hints) {
    for (var i = 0; i < this.readers.length; i++) {
      try {
        return this.readers[i].decodeRow(rowNumber, row, hints);
      } catch (re) {
      }
    }
    throw new NotFoundException_default();
  };
  MultiFormatOneDReader2.prototype.reset = function() {
    this.readers.forEach(function(reader) {
      return reader.reset();
    });
  };
  return MultiFormatOneDReader2;
}(OneDReader_default);
var MultiFormatOneDReader_default = MultiFormatOneDReader;

// node_modules/@zxing/library/esm/browser/BrowserBarcodeReader.js
var __extends50 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserBarcodeReader = function(_super) {
  __extends50(BrowserBarcodeReader2, _super);
  function BrowserBarcodeReader2(timeBetweenScansMillis, hints) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    return _super.call(this, new MultiFormatOneDReader_default(hints), timeBetweenScansMillis, hints) || this;
  }
  return BrowserBarcodeReader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/core/datamatrix/decoder/Version.js
var __values17 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ECBlocks = function() {
  function ECBlocks3(ecCodewords, ecBlocks1, ecBlocks2) {
    this.ecCodewords = ecCodewords;
    this.ecBlocks = [ecBlocks1];
    ecBlocks2 && this.ecBlocks.push(ecBlocks2);
  }
  ECBlocks3.prototype.getECCodewords = function() {
    return this.ecCodewords;
  };
  ECBlocks3.prototype.getECBlocks = function() {
    return this.ecBlocks;
  };
  return ECBlocks3;
}();
var ECB = function() {
  function ECB3(count, dataCodewords) {
    this.count = count;
    this.dataCodewords = dataCodewords;
  }
  ECB3.prototype.getCount = function() {
    return this.count;
  };
  ECB3.prototype.getDataCodewords = function() {
    return this.dataCodewords;
  };
  return ECB3;
}();
var Version = function() {
  function Version3(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
    var e_1, _a;
    this.versionNumber = versionNumber;
    this.symbolSizeRows = symbolSizeRows;
    this.symbolSizeColumns = symbolSizeColumns;
    this.dataRegionSizeRows = dataRegionSizeRows;
    this.dataRegionSizeColumns = dataRegionSizeColumns;
    this.ecBlocks = ecBlocks;
    var total = 0;
    var ecCodewords = ecBlocks.getECCodewords();
    var ecbArray = ecBlocks.getECBlocks();
    try {
      for (var ecbArray_1 = __values17(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
        var ecBlock = ecbArray_1_1.value;
        total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return))
          _a.call(ecbArray_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.totalCodewords = total;
  }
  Version3.prototype.getVersionNumber = function() {
    return this.versionNumber;
  };
  Version3.prototype.getSymbolSizeRows = function() {
    return this.symbolSizeRows;
  };
  Version3.prototype.getSymbolSizeColumns = function() {
    return this.symbolSizeColumns;
  };
  Version3.prototype.getDataRegionSizeRows = function() {
    return this.dataRegionSizeRows;
  };
  Version3.prototype.getDataRegionSizeColumns = function() {
    return this.dataRegionSizeColumns;
  };
  Version3.prototype.getTotalCodewords = function() {
    return this.totalCodewords;
  };
  Version3.prototype.getECBlocks = function() {
    return this.ecBlocks;
  };
  Version3.getVersionForDimensions = function(numRows, numColumns) {
    var e_2, _a;
    if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
      throw new FormatException_default();
    }
    try {
      for (var _b = __values17(Version3.VERSIONS), _c = _b.next(); !_c.done; _c = _b.next()) {
        var version = _c.value;
        if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
          return version;
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    throw new FormatException_default();
  };
  Version3.prototype.toString = function() {
    return "" + this.versionNumber;
  };
  Version3.buildVersions = function() {
    return [
      new Version3(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
      new Version3(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
      new Version3(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
      new Version3(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
      new Version3(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
      new Version3(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
      new Version3(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
      new Version3(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
      new Version3(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
      new Version3(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
      new Version3(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
      new Version3(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
      new Version3(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
      new Version3(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
      new Version3(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
      new Version3(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
      new Version3(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
      new Version3(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
      new Version3(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
      new Version3(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
      new Version3(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
      new Version3(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
      new Version3(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
      new Version3(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
      new Version3(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
      new Version3(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
      new Version3(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
      new Version3(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
      new Version3(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
      new Version3(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
    ];
  };
  Version3.VERSIONS = Version3.buildVersions();
  return Version3;
}();
var Version_default = Version;

// node_modules/@zxing/library/esm/core/datamatrix/decoder/BitMatrixParser.js
var BitMatrixParser = function() {
  function BitMatrixParser3(bitMatrix) {
    var dimension = bitMatrix.getHeight();
    if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
      throw new FormatException_default();
    }
    this.version = BitMatrixParser3.readVersion(bitMatrix);
    this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
    this.readMappingMatrix = new BitMatrix_default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
  }
  BitMatrixParser3.prototype.getVersion = function() {
    return this.version;
  };
  BitMatrixParser3.readVersion = function(bitMatrix) {
    var numRows = bitMatrix.getHeight();
    var numColumns = bitMatrix.getWidth();
    return Version_default.getVersionForDimensions(numRows, numColumns);
  };
  BitMatrixParser3.prototype.readCodewords = function() {
    var result = new Int8Array(this.version.getTotalCodewords());
    var resultOffset = 0;
    var row = 4;
    var column = 0;
    var numRows = this.mappingBitMatrix.getHeight();
    var numColumns = this.mappingBitMatrix.getWidth();
    var corner1Read = false;
    var corner2Read = false;
    var corner3Read = false;
    var corner4Read = false;
    do {
      if (row === numRows && column === 0 && !corner1Read) {
        result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
        row -= 2;
        column += 2;
        corner1Read = true;
      } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
        result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
        row -= 2;
        column += 2;
        corner2Read = true;
      } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
        result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
        row -= 2;
        column += 2;
        corner3Read = true;
      } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
        result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
        row -= 2;
        column += 2;
        corner4Read = true;
      } else {
        do {
          if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
          }
          row -= 2;
          column += 2;
        } while (row >= 0 && column < numColumns);
        row += 1;
        column += 3;
        do {
          if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
            result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
          }
          row += 2;
          column -= 2;
        } while (row < numRows && column >= 0);
        row += 3;
        column += 1;
      }
    } while (row < numRows || column < numColumns);
    if (resultOffset !== this.version.getTotalCodewords()) {
      throw new FormatException_default();
    }
    return result;
  };
  BitMatrixParser3.prototype.readModule = function(row, column, numRows, numColumns) {
    if (row < 0) {
      row += numRows;
      column += 4 - (numRows + 4 & 7);
    }
    if (column < 0) {
      column += numColumns;
      row += 4 - (numColumns + 4 & 7);
    }
    this.readMappingMatrix.set(column, row);
    return this.mappingBitMatrix.get(column, row);
  };
  BitMatrixParser3.prototype.readUtah = function(row, column, numRows, numColumns) {
    var currentByte = 0;
    if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row - 1, column, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row, column - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row, column - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(row, column, numRows, numColumns)) {
      currentByte |= 1;
    }
    return currentByte;
  };
  BitMatrixParser3.prototype.readCorner1 = function(numRows, numColumns) {
    var currentByte = 0;
    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    return currentByte;
  };
  BitMatrixParser3.prototype.readCorner2 = function(numRows, numColumns) {
    var currentByte = 0;
    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    return currentByte;
  };
  BitMatrixParser3.prototype.readCorner3 = function(numRows, numColumns) {
    var currentByte = 0;
    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    return currentByte;
  };
  BitMatrixParser3.prototype.readCorner4 = function(numRows, numColumns) {
    var currentByte = 0;
    if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    currentByte <<= 1;
    if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
      currentByte |= 1;
    }
    return currentByte;
  };
  BitMatrixParser3.prototype.extractDataRegion = function(bitMatrix) {
    var symbolSizeRows = this.version.getSymbolSizeRows();
    var symbolSizeColumns = this.version.getSymbolSizeColumns();
    if (bitMatrix.getHeight() !== symbolSizeRows) {
      throw new IllegalArgumentException_default("Dimension of bitMatrix must match the version size");
    }
    var dataRegionSizeRows = this.version.getDataRegionSizeRows();
    var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
    var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
    var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
    var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
    var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
    var bitMatrixWithoutAlignment = new BitMatrix_default(sizeDataRegionColumn, sizeDataRegionRow);
    for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
      var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
      for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
        var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
        for (var i = 0; i < dataRegionSizeRows; ++i) {
          var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
          var writeRowOffset = dataRegionRowOffset + i;
          for (var j = 0; j < dataRegionSizeColumns; ++j) {
            var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
            if (bitMatrix.get(readColumnOffset, readRowOffset)) {
              var writeColumnOffset = dataRegionColumnOffset + j;
              bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
            }
          }
        }
      }
    }
    return bitMatrixWithoutAlignment;
  };
  return BitMatrixParser3;
}();
var BitMatrixParser_default = BitMatrixParser;

// node_modules/@zxing/library/esm/core/datamatrix/decoder/DataBlock.js
var __values18 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DataBlock = function() {
  function DataBlock3(numDataCodewords, codewords) {
    this.numDataCodewords = numDataCodewords;
    this.codewords = codewords;
  }
  DataBlock3.getDataBlocks = function(rawCodewords, version) {
    var e_1, _a, e_2, _b;
    var ecBlocks = version.getECBlocks();
    var totalBlocks = 0;
    var ecBlockArray = ecBlocks.getECBlocks();
    try {
      for (var ecBlockArray_1 = __values18(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
        var ecBlock = ecBlockArray_1_1.value;
        totalBlocks += ecBlock.getCount();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return))
          _a.call(ecBlockArray_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var result = new Array(totalBlocks);
    var numResultBlocks = 0;
    try {
      for (var ecBlockArray_2 = __values18(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
        var ecBlock = ecBlockArray_2_1.value;
        for (var i = 0; i < ecBlock.getCount(); i++) {
          var numDataCodewords = ecBlock.getDataCodewords();
          var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
          result[numResultBlocks++] = new DataBlock3(numDataCodewords, new Uint8Array(numBlockCodewords));
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return))
          _b.call(ecBlockArray_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    var longerBlocksTotalCodewords = result[0].codewords.length;
    var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
    var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
    var rawCodewordsOffset = 0;
    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
      }
    }
    var specialVersion = version.getVersionNumber() === 24;
    var numLongerBlocks = specialVersion ? 8 : numResultBlocks;
    for (var j = 0; j < numLongerBlocks; j++) {
      result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
    }
    var max = result[0].codewords.length;
    for (var i = longerBlocksNumDataCodewords; i < max; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
        var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
        result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
      }
    }
    if (rawCodewordsOffset !== rawCodewords.length) {
      throw new IllegalArgumentException_default();
    }
    return result;
  };
  DataBlock3.prototype.getNumDataCodewords = function() {
    return this.numDataCodewords;
  };
  DataBlock3.prototype.getCodewords = function() {
    return this.codewords;
  };
  return DataBlock3;
}();
var DataBlock_default = DataBlock;

// node_modules/@zxing/library/esm/core/common/BitSource.js
var BitSource = function() {
  function BitSource2(bytes) {
    this.bytes = bytes;
    this.byteOffset = 0;
    this.bitOffset = 0;
  }
  BitSource2.prototype.getBitOffset = function() {
    return this.bitOffset;
  };
  BitSource2.prototype.getByteOffset = function() {
    return this.byteOffset;
  };
  BitSource2.prototype.readBits = function(numBits) {
    if (numBits < 1 || numBits > 32 || numBits > this.available()) {
      throw new IllegalArgumentException_default("" + numBits);
    }
    var result = 0;
    var bitOffset = this.bitOffset;
    var byteOffset = this.byteOffset;
    var bytes = this.bytes;
    if (bitOffset > 0) {
      var bitsLeft = 8 - bitOffset;
      var toRead = numBits < bitsLeft ? numBits : bitsLeft;
      var bitsToNotRead = bitsLeft - toRead;
      var mask = 255 >> 8 - toRead << bitsToNotRead;
      result = (bytes[byteOffset] & mask) >> bitsToNotRead;
      numBits -= toRead;
      bitOffset += toRead;
      if (bitOffset === 8) {
        bitOffset = 0;
        byteOffset++;
      }
    }
    if (numBits > 0) {
      while (numBits >= 8) {
        result = result << 8 | bytes[byteOffset] & 255;
        byteOffset++;
        numBits -= 8;
      }
      if (numBits > 0) {
        var bitsToNotRead = 8 - numBits;
        var mask = 255 >> bitsToNotRead << bitsToNotRead;
        result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
        bitOffset += numBits;
      }
    }
    this.bitOffset = bitOffset;
    this.byteOffset = byteOffset;
    return result;
  };
  BitSource2.prototype.available = function() {
    return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
  };
  return BitSource2;
}();
var BitSource_default = BitSource;

// node_modules/@zxing/library/esm/core/datamatrix/decoder/DecodedBitStreamParser.js
var Mode;
(function(Mode4) {
  Mode4[Mode4["PAD_ENCODE"] = 0] = "PAD_ENCODE";
  Mode4[Mode4["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
  Mode4[Mode4["C40_ENCODE"] = 2] = "C40_ENCODE";
  Mode4[Mode4["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
  Mode4[Mode4["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
  Mode4[Mode4["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
  Mode4[Mode4["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
})(Mode || (Mode = {}));
var DecodedBitStreamParser = function() {
  function DecodedBitStreamParser4() {
  }
  DecodedBitStreamParser4.decode = function(bytes) {
    var bits = new BitSource_default(bytes);
    var result = new StringBuilder_default();
    var resultTrailer = new StringBuilder_default();
    var byteSegments = new Array();
    var mode = Mode.ASCII_ENCODE;
    do {
      if (mode === Mode.ASCII_ENCODE) {
        mode = this.decodeAsciiSegment(bits, result, resultTrailer);
      } else {
        switch (mode) {
          case Mode.C40_ENCODE:
            this.decodeC40Segment(bits, result);
            break;
          case Mode.TEXT_ENCODE:
            this.decodeTextSegment(bits, result);
            break;
          case Mode.ANSIX12_ENCODE:
            this.decodeAnsiX12Segment(bits, result);
            break;
          case Mode.EDIFACT_ENCODE:
            this.decodeEdifactSegment(bits, result);
            break;
          case Mode.BASE256_ENCODE:
            this.decodeBase256Segment(bits, result, byteSegments);
            break;
          default:
            throw new FormatException_default();
        }
        mode = Mode.ASCII_ENCODE;
      }
    } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
    if (resultTrailer.length() > 0) {
      result.append(resultTrailer.toString());
    }
    return new DecoderResult_default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
  };
  DecodedBitStreamParser4.decodeAsciiSegment = function(bits, result, resultTrailer) {
    var upperShift = false;
    do {
      var oneByte = bits.readBits(8);
      if (oneByte === 0) {
        throw new FormatException_default();
      } else if (oneByte <= 128) {
        if (upperShift) {
          oneByte += 128;
        }
        result.append(String.fromCharCode(oneByte - 1));
        return Mode.ASCII_ENCODE;
      } else if (oneByte === 129) {
        return Mode.PAD_ENCODE;
      } else if (oneByte <= 229) {
        var value = oneByte - 130;
        if (value < 10) {
          result.append("0");
        }
        result.append("" + value);
      } else {
        switch (oneByte) {
          case 230:
            return Mode.C40_ENCODE;
          case 231:
            return Mode.BASE256_ENCODE;
          case 232:
            result.append(String.fromCharCode(29));
            break;
          case 233:
          case 234:
            break;
          case 235:
            upperShift = true;
            break;
          case 236:
            result.append("[)>05");
            resultTrailer.insert(0, "");
            break;
          case 237:
            result.append("[)>06");
            resultTrailer.insert(0, "");
            break;
          case 238:
            return Mode.ANSIX12_ENCODE;
          case 239:
            return Mode.TEXT_ENCODE;
          case 240:
            return Mode.EDIFACT_ENCODE;
          case 241:
            break;
          default:
            if (oneByte !== 254 || bits.available() !== 0) {
              throw new FormatException_default();
            }
            break;
        }
      }
    } while (bits.available() > 0);
    return Mode.ASCII_ENCODE;
  };
  DecodedBitStreamParser4.decodeC40Segment = function(bits, result) {
    var upperShift = false;
    var cValues = [];
    var shift = 0;
    do {
      if (bits.available() === 8) {
        return;
      }
      var firstByte = bits.readBits(8);
      if (firstByte === 254) {
        return;
      }
      this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
      for (var i = 0; i < 3; i++) {
        var cValue = cValues[i];
        switch (shift) {
          case 0:
            if (cValue < 3) {
              shift = cValue + 1;
            } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
              var c40char = this.C40_BASIC_SET_CHARS[cValue];
              if (upperShift) {
                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                upperShift = false;
              } else {
                result.append(c40char);
              }
            } else {
              throw new FormatException_default();
            }
            break;
          case 1:
            if (upperShift) {
              result.append(String.fromCharCode(cValue + 128));
              upperShift = false;
            } else {
              result.append(String.fromCharCode(cValue));
            }
            shift = 0;
            break;
          case 2:
            if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
              var c40char = this.C40_SHIFT2_SET_CHARS[cValue];
              if (upperShift) {
                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                upperShift = false;
              } else {
                result.append(c40char);
              }
            } else {
              switch (cValue) {
                case 27:
                  result.append(String.fromCharCode(29));
                  break;
                case 30:
                  upperShift = true;
                  break;
                default:
                  throw new FormatException_default();
              }
            }
            shift = 0;
            break;
          case 3:
            if (upperShift) {
              result.append(String.fromCharCode(cValue + 224));
              upperShift = false;
            } else {
              result.append(String.fromCharCode(cValue + 96));
            }
            shift = 0;
            break;
          default:
            throw new FormatException_default();
        }
      }
    } while (bits.available() > 0);
  };
  DecodedBitStreamParser4.decodeTextSegment = function(bits, result) {
    var upperShift = false;
    var cValues = [];
    var shift = 0;
    do {
      if (bits.available() === 8) {
        return;
      }
      var firstByte = bits.readBits(8);
      if (firstByte === 254) {
        return;
      }
      this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
      for (var i = 0; i < 3; i++) {
        var cValue = cValues[i];
        switch (shift) {
          case 0:
            if (cValue < 3) {
              shift = cValue + 1;
            } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
              var textChar = this.TEXT_BASIC_SET_CHARS[cValue];
              if (upperShift) {
                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                upperShift = false;
              } else {
                result.append(textChar);
              }
            } else {
              throw new FormatException_default();
            }
            break;
          case 1:
            if (upperShift) {
              result.append(String.fromCharCode(cValue + 128));
              upperShift = false;
            } else {
              result.append(String.fromCharCode(cValue));
            }
            shift = 0;
            break;
          case 2:
            if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
              var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
              if (upperShift) {
                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                upperShift = false;
              } else {
                result.append(textChar);
              }
            } else {
              switch (cValue) {
                case 27:
                  result.append(String.fromCharCode(29));
                  break;
                case 30:
                  upperShift = true;
                  break;
                default:
                  throw new FormatException_default();
              }
            }
            shift = 0;
            break;
          case 3:
            if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
              var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
              if (upperShift) {
                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                upperShift = false;
              } else {
                result.append(textChar);
              }
              shift = 0;
            } else {
              throw new FormatException_default();
            }
            break;
          default:
            throw new FormatException_default();
        }
      }
    } while (bits.available() > 0);
  };
  DecodedBitStreamParser4.decodeAnsiX12Segment = function(bits, result) {
    var cValues = [];
    do {
      if (bits.available() === 8) {
        return;
      }
      var firstByte = bits.readBits(8);
      if (firstByte === 254) {
        return;
      }
      this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
      for (var i = 0; i < 3; i++) {
        var cValue = cValues[i];
        switch (cValue) {
          case 0:
            result.append("\r");
            break;
          case 1:
            result.append("*");
            break;
          case 2:
            result.append(">");
            break;
          case 3:
            result.append(" ");
            break;
          default:
            if (cValue < 14) {
              result.append(String.fromCharCode(cValue + 44));
            } else if (cValue < 40) {
              result.append(String.fromCharCode(cValue + 51));
            } else {
              throw new FormatException_default();
            }
            break;
        }
      }
    } while (bits.available() > 0);
  };
  DecodedBitStreamParser4.parseTwoBytes = function(firstByte, secondByte, result) {
    var fullBitValue = (firstByte << 8) + secondByte - 1;
    var temp = Math.floor(fullBitValue / 1600);
    result[0] = temp;
    fullBitValue -= temp * 1600;
    temp = Math.floor(fullBitValue / 40);
    result[1] = temp;
    result[2] = fullBitValue - temp * 40;
  };
  DecodedBitStreamParser4.decodeEdifactSegment = function(bits, result) {
    do {
      if (bits.available() <= 16) {
        return;
      }
      for (var i = 0; i < 4; i++) {
        var edifactValue = bits.readBits(6);
        if (edifactValue === 31) {
          var bitsLeft = 8 - bits.getBitOffset();
          if (bitsLeft !== 8) {
            bits.readBits(bitsLeft);
          }
          return;
        }
        if ((edifactValue & 32) === 0) {
          edifactValue |= 64;
        }
        result.append(String.fromCharCode(edifactValue));
      }
    } while (bits.available() > 0);
  };
  DecodedBitStreamParser4.decodeBase256Segment = function(bits, result, byteSegments) {
    var codewordPosition = 1 + bits.getByteOffset();
    var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
    var count;
    if (d1 === 0) {
      count = bits.available() / 8 | 0;
    } else if (d1 < 250) {
      count = d1;
    } else {
      count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
    }
    if (count < 0) {
      throw new FormatException_default();
    }
    var bytes = new Uint8Array(count);
    for (var i = 0; i < count; i++) {
      if (bits.available() < 8) {
        throw new FormatException_default();
      }
      bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
    }
    byteSegments.push(bytes);
    try {
      result.append(StringEncoding_default.decode(bytes, StringUtils_default.ISO88591));
    } catch (uee) {
      throw new IllegalStateException_default("Platform does not support required encoding: " + uee.message);
    }
  };
  DecodedBitStreamParser4.unrandomize255State = function(randomizedBase256Codeword, base256CodewordPosition) {
    var pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
    var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
    return tempVariable >= 0 ? tempVariable : tempVariable + 256;
  };
  DecodedBitStreamParser4.C40_BASIC_SET_CHARS = [
    "*",
    "*",
    "*",
    " ",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ];
  DecodedBitStreamParser4.C40_SHIFT2_SET_CHARS = [
    "!",
    '"',
    "#",
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "?",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_"
  ];
  DecodedBitStreamParser4.TEXT_BASIC_SET_CHARS = [
    "*",
    "*",
    "*",
    " ",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z"
  ];
  DecodedBitStreamParser4.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser4.C40_SHIFT2_SET_CHARS;
  DecodedBitStreamParser4.TEXT_SHIFT3_SET_CHARS = [
    "`",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "{",
    "|",
    "}",
    "~",
    String.fromCharCode(127)
  ];
  return DecodedBitStreamParser4;
}();
var DecodedBitStreamParser_default = DecodedBitStreamParser;

// node_modules/@zxing/library/esm/core/datamatrix/decoder/Decoder.js
var __values19 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Decoder2 = function() {
  function Decoder4() {
    this.rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.DATA_MATRIX_FIELD_256);
  }
  Decoder4.prototype.decode = function(bits) {
    var e_1, _a;
    var parser = new BitMatrixParser_default(bits);
    var version = parser.getVersion();
    var codewords = parser.readCodewords();
    var dataBlocks = DataBlock_default.getDataBlocks(codewords, version);
    var totalBytes = 0;
    try {
      for (var dataBlocks_1 = __values19(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
        var db = dataBlocks_1_1.value;
        totalBytes += db.getNumDataCodewords();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return))
          _a.call(dataBlocks_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var resultBytes = new Uint8Array(totalBytes);
    var dataBlocksCount = dataBlocks.length;
    for (var j = 0; j < dataBlocksCount; j++) {
      var dataBlock = dataBlocks[j];
      var codewordBytes = dataBlock.getCodewords();
      var numDataCodewords = dataBlock.getNumDataCodewords();
      this.correctErrors(codewordBytes, numDataCodewords);
      for (var i = 0; i < numDataCodewords; i++) {
        resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
      }
    }
    return DecodedBitStreamParser_default.decode(resultBytes);
  };
  Decoder4.prototype.correctErrors = function(codewordBytes, numDataCodewords) {
    var codewordsInts = new Int32Array(codewordBytes);
    try {
      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
    } catch (ignored) {
      throw new ChecksumException_default();
    }
    for (var i = 0; i < numDataCodewords; i++) {
      codewordBytes[i] = codewordsInts[i];
    }
  };
  return Decoder4;
}();
var Decoder_default2 = Decoder2;

// node_modules/@zxing/library/esm/core/datamatrix/detector/Detector.js
var Detector2 = function() {
  function Detector5(image) {
    this.image = image;
    this.rectangleDetector = new WhiteRectangleDetector_default(this.image);
  }
  Detector5.prototype.detect = function() {
    var cornerPoints = this.rectangleDetector.detect();
    var points = this.detectSolid1(cornerPoints);
    points = this.detectSolid2(points);
    points[3] = this.correctTopRight(points);
    if (!points[3]) {
      throw new NotFoundException_default();
    }
    points = this.shiftToModuleCenter(points);
    var topLeft = points[0];
    var bottomLeft = points[1];
    var bottomRight = points[2];
    var topRight = points[3];
    var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
    var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
    if ((dimensionTop & 1) === 1) {
      dimensionTop += 1;
    }
    if ((dimensionRight & 1) === 1) {
      dimensionRight += 1;
    }
    if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
      dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
    }
    var bits = Detector5.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
    return new DetectorResult_default(bits, [topLeft, bottomLeft, bottomRight, topRight]);
  };
  Detector5.shiftPoint = function(point, to, div) {
    var x2 = (to.getX() - point.getX()) / (div + 1);
    var y = (to.getY() - point.getY()) / (div + 1);
    return new ResultPoint_default(point.getX() + x2, point.getY() + y);
  };
  Detector5.moveAway = function(point, fromX, fromY) {
    var x2 = point.getX();
    var y = point.getY();
    if (x2 < fromX) {
      x2 -= 1;
    } else {
      x2 += 1;
    }
    if (y < fromY) {
      y -= 1;
    } else {
      y += 1;
    }
    return new ResultPoint_default(x2, y);
  };
  Detector5.prototype.detectSolid1 = function(cornerPoints) {
    var pointA = cornerPoints[0];
    var pointB = cornerPoints[1];
    var pointC = cornerPoints[3];
    var pointD = cornerPoints[2];
    var trAB = this.transitionsBetween(pointA, pointB);
    var trBC = this.transitionsBetween(pointB, pointC);
    var trCD = this.transitionsBetween(pointC, pointD);
    var trDA = this.transitionsBetween(pointD, pointA);
    var min = trAB;
    var points = [pointD, pointA, pointB, pointC];
    if (min > trBC) {
      min = trBC;
      points[0] = pointA;
      points[1] = pointB;
      points[2] = pointC;
      points[3] = pointD;
    }
    if (min > trCD) {
      min = trCD;
      points[0] = pointB;
      points[1] = pointC;
      points[2] = pointD;
      points[3] = pointA;
    }
    if (min > trDA) {
      points[0] = pointC;
      points[1] = pointD;
      points[2] = pointA;
      points[3] = pointB;
    }
    return points;
  };
  Detector5.prototype.detectSolid2 = function(points) {
    var pointA = points[0];
    var pointB = points[1];
    var pointC = points[2];
    var pointD = points[3];
    var tr = this.transitionsBetween(pointA, pointD);
    var pointBs = Detector5.shiftPoint(pointB, pointC, (tr + 1) * 4);
    var pointCs = Detector5.shiftPoint(pointC, pointB, (tr + 1) * 4);
    var trBA = this.transitionsBetween(pointBs, pointA);
    var trCD = this.transitionsBetween(pointCs, pointD);
    if (trBA < trCD) {
      points[0] = pointA;
      points[1] = pointB;
      points[2] = pointC;
      points[3] = pointD;
    } else {
      points[0] = pointB;
      points[1] = pointC;
      points[2] = pointD;
      points[3] = pointA;
    }
    return points;
  };
  Detector5.prototype.correctTopRight = function(points) {
    var pointA = points[0];
    var pointB = points[1];
    var pointC = points[2];
    var pointD = points[3];
    var trTop = this.transitionsBetween(pointA, pointD);
    var trRight = this.transitionsBetween(pointB, pointD);
    var pointAs = Detector5.shiftPoint(pointA, pointB, (trRight + 1) * 4);
    var pointCs = Detector5.shiftPoint(pointC, pointB, (trTop + 1) * 4);
    trTop = this.transitionsBetween(pointAs, pointD);
    trRight = this.transitionsBetween(pointCs, pointD);
    var candidate1 = new ResultPoint_default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
    var candidate2 = new ResultPoint_default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
    if (!this.isValid(candidate1)) {
      if (this.isValid(candidate2)) {
        return candidate2;
      }
      return null;
    }
    if (!this.isValid(candidate2)) {
      return candidate1;
    }
    var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
    var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
    if (sumc1 > sumc2) {
      return candidate1;
    } else {
      return candidate2;
    }
  };
  Detector5.prototype.shiftToModuleCenter = function(points) {
    var pointA = points[0];
    var pointB = points[1];
    var pointC = points[2];
    var pointD = points[3];
    var dimH = this.transitionsBetween(pointA, pointD) + 1;
    var dimV = this.transitionsBetween(pointC, pointD) + 1;
    var pointAs = Detector5.shiftPoint(pointA, pointB, dimV * 4);
    var pointCs = Detector5.shiftPoint(pointC, pointB, dimH * 4);
    dimH = this.transitionsBetween(pointAs, pointD) + 1;
    dimV = this.transitionsBetween(pointCs, pointD) + 1;
    if ((dimH & 1) === 1) {
      dimH += 1;
    }
    if ((dimV & 1) === 1) {
      dimV += 1;
    }
    var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
    var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
    pointA = Detector5.moveAway(pointA, centerX, centerY);
    pointB = Detector5.moveAway(pointB, centerX, centerY);
    pointC = Detector5.moveAway(pointC, centerX, centerY);
    pointD = Detector5.moveAway(pointD, centerX, centerY);
    var pointBs;
    var pointDs;
    pointAs = Detector5.shiftPoint(pointA, pointB, dimV * 4);
    pointAs = Detector5.shiftPoint(pointAs, pointD, dimH * 4);
    pointBs = Detector5.shiftPoint(pointB, pointA, dimV * 4);
    pointBs = Detector5.shiftPoint(pointBs, pointC, dimH * 4);
    pointCs = Detector5.shiftPoint(pointC, pointD, dimV * 4);
    pointCs = Detector5.shiftPoint(pointCs, pointB, dimH * 4);
    pointDs = Detector5.shiftPoint(pointD, pointC, dimV * 4);
    pointDs = Detector5.shiftPoint(pointDs, pointA, dimH * 4);
    return [pointAs, pointBs, pointCs, pointDs];
  };
  Detector5.prototype.isValid = function(p) {
    return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
  };
  Detector5.sampleGrid = function(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
    var sampler = GridSamplerInstance_default.getInstance();
    return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
  };
  Detector5.prototype.transitionsBetween = function(from, to) {
    var fromX = Math.trunc(from.getX());
    var fromY = Math.trunc(from.getY());
    var toX = Math.trunc(to.getX());
    var toY = Math.trunc(to.getY());
    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
    if (steep) {
      var temp = fromX;
      fromX = fromY;
      fromY = temp;
      temp = toX;
      toX = toY;
      toY = temp;
    }
    var dx = Math.abs(toX - fromX);
    var dy = Math.abs(toY - fromY);
    var error = -dx / 2;
    var ystep = fromY < toY ? 1 : -1;
    var xstep = fromX < toX ? 1 : -1;
    var transitions = 0;
    var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
    for (var x2 = fromX, y = fromY; x2 !== toX; x2 += xstep) {
      var isBlack = this.image.get(steep ? y : x2, steep ? x2 : y);
      if (isBlack !== inBlack) {
        transitions++;
        inBlack = isBlack;
      }
      error += dy;
      if (error > 0) {
        if (y === toY) {
          break;
        }
        y += ystep;
        error -= dx;
      }
    }
    return transitions;
  };
  return Detector5;
}();
var Detector_default2 = Detector2;

// node_modules/@zxing/library/esm/core/datamatrix/DataMatrixReader.js
var DataMatrixReader = function() {
  function DataMatrixReader2() {
    this.decoder = new Decoder_default2();
  }
  DataMatrixReader2.prototype.decode = function(image, hints) {
    if (hints === void 0) {
      hints = null;
    }
    var decoderResult;
    var points;
    if (hints != null && hints.has(DecodeHintType_default.PURE_BARCODE)) {
      var bits = DataMatrixReader2.extractPureBits(image.getBlackMatrix());
      decoderResult = this.decoder.decode(bits);
      points = DataMatrixReader2.NO_POINTS;
    } else {
      var detectorResult = new Detector_default2(image.getBlackMatrix()).detect();
      decoderResult = this.decoder.decode(detectorResult.getBits());
      points = detectorResult.getPoints();
    }
    var rawBytes = decoderResult.getRawBytes();
    var result = new Result_default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_default.DATA_MATRIX, System_default.currentTimeMillis());
    var byteSegments = decoderResult.getByteSegments();
    if (byteSegments != null) {
      result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
    }
    var ecLevel = decoderResult.getECLevel();
    if (ecLevel != null) {
      result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
    }
    return result;
  };
  DataMatrixReader2.prototype.reset = function() {
  };
  DataMatrixReader2.extractPureBits = function(image) {
    var leftTopBlack = image.getTopLeftOnBit();
    var rightBottomBlack = image.getBottomRightOnBit();
    if (leftTopBlack == null || rightBottomBlack == null) {
      throw new NotFoundException_default();
    }
    var moduleSize = this.moduleSize(leftTopBlack, image);
    var top = leftTopBlack[1];
    var bottom = rightBottomBlack[1];
    var left = leftTopBlack[0];
    var right = rightBottomBlack[0];
    var matrixWidth = (right - left + 1) / moduleSize;
    var matrixHeight = (bottom - top + 1) / moduleSize;
    if (matrixWidth <= 0 || matrixHeight <= 0) {
      throw new NotFoundException_default();
    }
    var nudge = moduleSize / 2;
    top += nudge;
    left += nudge;
    var bits = new BitMatrix_default(matrixWidth, matrixHeight);
    for (var y = 0; y < matrixHeight; y++) {
      var iOffset = top + y * moduleSize;
      for (var x2 = 0; x2 < matrixWidth; x2++) {
        if (image.get(left + x2 * moduleSize, iOffset)) {
          bits.set(x2, y);
        }
      }
    }
    return bits;
  };
  DataMatrixReader2.moduleSize = function(leftTopBlack, image) {
    var width = image.getWidth();
    var x2 = leftTopBlack[0];
    var y = leftTopBlack[1];
    while (x2 < width && image.get(x2, y)) {
      x2++;
    }
    if (x2 === width) {
      throw new NotFoundException_default();
    }
    var moduleSize = x2 - leftTopBlack[0];
    if (moduleSize === 0) {
      throw new NotFoundException_default();
    }
    return moduleSize;
  };
  DataMatrixReader2.NO_POINTS = [];
  return DataMatrixReader2;
}();
var DataMatrixReader_default = DataMatrixReader;

// node_modules/@zxing/library/esm/browser/BrowserDatamatrixCodeReader.js
var __extends51 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserDatamatrixCodeReader = function(_super) {
  __extends51(BrowserDatamatrixCodeReader2, _super);
  function BrowserDatamatrixCodeReader2(timeBetweenScansMillis) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    return _super.call(this, new DataMatrixReader_default(), timeBetweenScansMillis) || this;
  }
  return BrowserDatamatrixCodeReader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/core/qrcode/decoder/ErrorCorrectionLevel.js
var ErrorCorrectionLevelValues;
(function(ErrorCorrectionLevelValues2) {
  ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
  ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
  ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
  ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
})(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
var ErrorCorrectionLevel = function() {
  function ErrorCorrectionLevel2(value, stringValue, bits) {
    this.value = value;
    this.stringValue = stringValue;
    this.bits = bits;
    ErrorCorrectionLevel2.FOR_BITS.set(bits, this);
    ErrorCorrectionLevel2.FOR_VALUE.set(value, this);
  }
  ErrorCorrectionLevel2.prototype.getValue = function() {
    return this.value;
  };
  ErrorCorrectionLevel2.prototype.getBits = function() {
    return this.bits;
  };
  ErrorCorrectionLevel2.fromString = function(s) {
    switch (s) {
      case "L":
        return ErrorCorrectionLevel2.L;
      case "M":
        return ErrorCorrectionLevel2.M;
      case "Q":
        return ErrorCorrectionLevel2.Q;
      case "H":
        return ErrorCorrectionLevel2.H;
      default:
        throw new ArgumentException_default(s + "not available");
    }
  };
  ErrorCorrectionLevel2.prototype.toString = function() {
    return this.stringValue;
  };
  ErrorCorrectionLevel2.prototype.equals = function(o) {
    if (!(o instanceof ErrorCorrectionLevel2)) {
      return false;
    }
    var other = o;
    return this.value === other.value;
  };
  ErrorCorrectionLevel2.forBits = function(bits) {
    if (bits < 0 || bits >= ErrorCorrectionLevel2.FOR_BITS.size) {
      throw new IllegalArgumentException_default();
    }
    return ErrorCorrectionLevel2.FOR_BITS.get(bits);
  };
  ErrorCorrectionLevel2.FOR_BITS = new Map();
  ErrorCorrectionLevel2.FOR_VALUE = new Map();
  ErrorCorrectionLevel2.L = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.L, "L", 1);
  ErrorCorrectionLevel2.M = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.M, "M", 0);
  ErrorCorrectionLevel2.Q = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.Q, "Q", 3);
  ErrorCorrectionLevel2.H = new ErrorCorrectionLevel2(ErrorCorrectionLevelValues.H, "H", 2);
  return ErrorCorrectionLevel2;
}();
var ErrorCorrectionLevel_default = ErrorCorrectionLevel;

// node_modules/@zxing/library/esm/core/qrcode/decoder/FormatInformation.js
var __values20 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var FormatInformation = function() {
  function FormatInformation2(formatInfo) {
    this.errorCorrectionLevel = ErrorCorrectionLevel_default.forBits(formatInfo >> 3 & 3);
    this.dataMask = formatInfo & 7;
  }
  FormatInformation2.numBitsDiffering = function(a, b) {
    return Integer_default.bitCount(a ^ b);
  };
  FormatInformation2.decodeFormatInformation = function(maskedFormatInfo1, maskedFormatInfo2) {
    var formatInfo = FormatInformation2.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
    if (formatInfo !== null) {
      return formatInfo;
    }
    return FormatInformation2.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation2.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation2.FORMAT_INFO_MASK_QR);
  };
  FormatInformation2.doDecodeFormatInformation = function(maskedFormatInfo1, maskedFormatInfo2) {
    var e_1, _a;
    var bestDifference = Number.MAX_SAFE_INTEGER;
    var bestFormatInfo = 0;
    try {
      for (var _b = __values20(FormatInformation2.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {
        var decodeInfo = _c.value;
        var targetInfo = decodeInfo[0];
        if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
          return new FormatInformation2(decodeInfo[1]);
        }
        var bitsDifference = FormatInformation2.numBitsDiffering(maskedFormatInfo1, targetInfo);
        if (bitsDifference < bestDifference) {
          bestFormatInfo = decodeInfo[1];
          bestDifference = bitsDifference;
        }
        if (maskedFormatInfo1 !== maskedFormatInfo2) {
          bitsDifference = FormatInformation2.numBitsDiffering(maskedFormatInfo2, targetInfo);
          if (bitsDifference < bestDifference) {
            bestFormatInfo = decodeInfo[1];
            bestDifference = bitsDifference;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (bestDifference <= 3) {
      return new FormatInformation2(bestFormatInfo);
    }
    return null;
  };
  FormatInformation2.prototype.getErrorCorrectionLevel = function() {
    return this.errorCorrectionLevel;
  };
  FormatInformation2.prototype.getDataMask = function() {
    return this.dataMask;
  };
  FormatInformation2.prototype.hashCode = function() {
    return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
  };
  FormatInformation2.prototype.equals = function(o) {
    if (!(o instanceof FormatInformation2)) {
      return false;
    }
    var other = o;
    return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
  };
  FormatInformation2.FORMAT_INFO_MASK_QR = 21522;
  FormatInformation2.FORMAT_INFO_DECODE_LOOKUP = [
    Int32Array.from([21522, 0]),
    Int32Array.from([20773, 1]),
    Int32Array.from([24188, 2]),
    Int32Array.from([23371, 3]),
    Int32Array.from([17913, 4]),
    Int32Array.from([16590, 5]),
    Int32Array.from([20375, 6]),
    Int32Array.from([19104, 7]),
    Int32Array.from([30660, 8]),
    Int32Array.from([29427, 9]),
    Int32Array.from([32170, 10]),
    Int32Array.from([30877, 11]),
    Int32Array.from([26159, 12]),
    Int32Array.from([25368, 13]),
    Int32Array.from([27713, 14]),
    Int32Array.from([26998, 15]),
    Int32Array.from([5769, 16]),
    Int32Array.from([5054, 17]),
    Int32Array.from([7399, 18]),
    Int32Array.from([6608, 19]),
    Int32Array.from([1890, 20]),
    Int32Array.from([597, 21]),
    Int32Array.from([3340, 22]),
    Int32Array.from([2107, 23]),
    Int32Array.from([13663, 24]),
    Int32Array.from([12392, 25]),
    Int32Array.from([16177, 26]),
    Int32Array.from([14854, 27]),
    Int32Array.from([9396, 28]),
    Int32Array.from([8579, 29]),
    Int32Array.from([11994, 30]),
    Int32Array.from([11245, 31])
  ];
  return FormatInformation2;
}();
var FormatInformation_default = FormatInformation;

// node_modules/@zxing/library/esm/core/qrcode/decoder/ECBlocks.js
var __values21 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ECBlocks2 = function() {
  function ECBlocks3(ecCodewordsPerBlock) {
    var ecBlocks = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      ecBlocks[_i - 1] = arguments[_i];
    }
    this.ecCodewordsPerBlock = ecCodewordsPerBlock;
    this.ecBlocks = ecBlocks;
  }
  ECBlocks3.prototype.getECCodewordsPerBlock = function() {
    return this.ecCodewordsPerBlock;
  };
  ECBlocks3.prototype.getNumBlocks = function() {
    var e_1, _a;
    var total = 0;
    var ecBlocks = this.ecBlocks;
    try {
      for (var ecBlocks_1 = __values21(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {
        var ecBlock = ecBlocks_1_1.value;
        total += ecBlock.getCount();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return))
          _a.call(ecBlocks_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return total;
  };
  ECBlocks3.prototype.getTotalECCodewords = function() {
    return this.ecCodewordsPerBlock * this.getNumBlocks();
  };
  ECBlocks3.prototype.getECBlocks = function() {
    return this.ecBlocks;
  };
  return ECBlocks3;
}();
var ECBlocks_default = ECBlocks2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/ECB.js
var ECB2 = function() {
  function ECB3(count, dataCodewords) {
    this.count = count;
    this.dataCodewords = dataCodewords;
  }
  ECB3.prototype.getCount = function() {
    return this.count;
  };
  ECB3.prototype.getDataCodewords = function() {
    return this.dataCodewords;
  };
  return ECB3;
}();
var ECB_default = ECB2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/Version.js
var __values22 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Version2 = function() {
  function Version3(versionNumber, alignmentPatternCenters) {
    var e_1, _a;
    var ecBlocks = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      ecBlocks[_i - 2] = arguments[_i];
    }
    this.versionNumber = versionNumber;
    this.alignmentPatternCenters = alignmentPatternCenters;
    this.ecBlocks = ecBlocks;
    var total = 0;
    var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
    var ecbArray = ecBlocks[0].getECBlocks();
    try {
      for (var ecbArray_1 = __values22(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
        var ecBlock = ecbArray_1_1.value;
        total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return))
          _a.call(ecbArray_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.totalCodewords = total;
  }
  Version3.prototype.getVersionNumber = function() {
    return this.versionNumber;
  };
  Version3.prototype.getAlignmentPatternCenters = function() {
    return this.alignmentPatternCenters;
  };
  Version3.prototype.getTotalCodewords = function() {
    return this.totalCodewords;
  };
  Version3.prototype.getDimensionForVersion = function() {
    return 17 + 4 * this.versionNumber;
  };
  Version3.prototype.getECBlocksForLevel = function(ecLevel) {
    return this.ecBlocks[ecLevel.getValue()];
  };
  Version3.getProvisionalVersionForDimension = function(dimension) {
    if (dimension % 4 !== 1) {
      throw new FormatException_default();
    }
    try {
      return this.getVersionForNumber((dimension - 17) / 4);
    } catch (ignored) {
      throw new FormatException_default();
    }
  };
  Version3.getVersionForNumber = function(versionNumber) {
    if (versionNumber < 1 || versionNumber > 40) {
      throw new IllegalArgumentException_default();
    }
    return Version3.VERSIONS[versionNumber - 1];
  };
  Version3.decodeVersionInformation = function(versionBits) {
    var bestDifference = Number.MAX_SAFE_INTEGER;
    var bestVersion = 0;
    for (var i = 0; i < Version3.VERSION_DECODE_INFO.length; i++) {
      var targetVersion = Version3.VERSION_DECODE_INFO[i];
      if (targetVersion === versionBits) {
        return Version3.getVersionForNumber(i + 7);
      }
      var bitsDifference = FormatInformation_default.numBitsDiffering(versionBits, targetVersion);
      if (bitsDifference < bestDifference) {
        bestVersion = i + 7;
        bestDifference = bitsDifference;
      }
    }
    if (bestDifference <= 3) {
      return Version3.getVersionForNumber(bestVersion);
    }
    return null;
  };
  Version3.prototype.buildFunctionPattern = function() {
    var dimension = this.getDimensionForVersion();
    var bitMatrix = new BitMatrix_default(dimension);
    bitMatrix.setRegion(0, 0, 9, 9);
    bitMatrix.setRegion(dimension - 8, 0, 8, 9);
    bitMatrix.setRegion(0, dimension - 8, 9, 8);
    var max = this.alignmentPatternCenters.length;
    for (var x2 = 0; x2 < max; x2++) {
      var i = this.alignmentPatternCenters[x2] - 2;
      for (var y = 0; y < max; y++) {
        if (x2 === 0 && (y === 0 || y === max - 1) || x2 === max - 1 && y === 0) {
          continue;
        }
        bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
      }
    }
    bitMatrix.setRegion(6, 9, 1, dimension - 17);
    bitMatrix.setRegion(9, 6, dimension - 17, 1);
    if (this.versionNumber > 6) {
      bitMatrix.setRegion(dimension - 11, 0, 3, 6);
      bitMatrix.setRegion(0, dimension - 11, 6, 3);
    }
    return bitMatrix;
  };
  Version3.prototype.toString = function() {
    return "" + this.versionNumber;
  };
  Version3.VERSION_DECODE_INFO = Int32Array.from([
    31892,
    34236,
    39577,
    42195,
    48118,
    51042,
    55367,
    58893,
    63784,
    68472,
    70749,
    76311,
    79154,
    84390,
    87683,
    92361,
    96236,
    102084,
    102881,
    110507,
    110734,
    117786,
    119615,
    126325,
    127568,
    133589,
    136944,
    141498,
    145311,
    150283,
    152622,
    158308,
    161089,
    167017
  ]);
  Version3.VERSIONS = [
    new Version3(1, new Int32Array(0), new ECBlocks_default(7, new ECB_default(1, 19)), new ECBlocks_default(10, new ECB_default(1, 16)), new ECBlocks_default(13, new ECB_default(1, 13)), new ECBlocks_default(17, new ECB_default(1, 9))),
    new Version3(2, Int32Array.from([6, 18]), new ECBlocks_default(10, new ECB_default(1, 34)), new ECBlocks_default(16, new ECB_default(1, 28)), new ECBlocks_default(22, new ECB_default(1, 22)), new ECBlocks_default(28, new ECB_default(1, 16))),
    new Version3(3, Int32Array.from([6, 22]), new ECBlocks_default(15, new ECB_default(1, 55)), new ECBlocks_default(26, new ECB_default(1, 44)), new ECBlocks_default(18, new ECB_default(2, 17)), new ECBlocks_default(22, new ECB_default(2, 13))),
    new Version3(4, Int32Array.from([6, 26]), new ECBlocks_default(20, new ECB_default(1, 80)), new ECBlocks_default(18, new ECB_default(2, 32)), new ECBlocks_default(26, new ECB_default(2, 24)), new ECBlocks_default(16, new ECB_default(4, 9))),
    new Version3(5, Int32Array.from([6, 30]), new ECBlocks_default(26, new ECB_default(1, 108)), new ECBlocks_default(24, new ECB_default(2, 43)), new ECBlocks_default(18, new ECB_default(2, 15), new ECB_default(2, 16)), new ECBlocks_default(22, new ECB_default(2, 11), new ECB_default(2, 12))),
    new Version3(6, Int32Array.from([6, 34]), new ECBlocks_default(18, new ECB_default(2, 68)), new ECBlocks_default(16, new ECB_default(4, 27)), new ECBlocks_default(24, new ECB_default(4, 19)), new ECBlocks_default(28, new ECB_default(4, 15))),
    new Version3(7, Int32Array.from([6, 22, 38]), new ECBlocks_default(20, new ECB_default(2, 78)), new ECBlocks_default(18, new ECB_default(4, 31)), new ECBlocks_default(18, new ECB_default(2, 14), new ECB_default(4, 15)), new ECBlocks_default(26, new ECB_default(4, 13), new ECB_default(1, 14))),
    new Version3(8, Int32Array.from([6, 24, 42]), new ECBlocks_default(24, new ECB_default(2, 97)), new ECBlocks_default(22, new ECB_default(2, 38), new ECB_default(2, 39)), new ECBlocks_default(22, new ECB_default(4, 18), new ECB_default(2, 19)), new ECBlocks_default(26, new ECB_default(4, 14), new ECB_default(2, 15))),
    new Version3(9, Int32Array.from([6, 26, 46]), new ECBlocks_default(30, new ECB_default(2, 116)), new ECBlocks_default(22, new ECB_default(3, 36), new ECB_default(2, 37)), new ECBlocks_default(20, new ECB_default(4, 16), new ECB_default(4, 17)), new ECBlocks_default(24, new ECB_default(4, 12), new ECB_default(4, 13))),
    new Version3(10, Int32Array.from([6, 28, 50]), new ECBlocks_default(18, new ECB_default(2, 68), new ECB_default(2, 69)), new ECBlocks_default(26, new ECB_default(4, 43), new ECB_default(1, 44)), new ECBlocks_default(24, new ECB_default(6, 19), new ECB_default(2, 20)), new ECBlocks_default(28, new ECB_default(6, 15), new ECB_default(2, 16))),
    new Version3(11, Int32Array.from([6, 30, 54]), new ECBlocks_default(20, new ECB_default(4, 81)), new ECBlocks_default(30, new ECB_default(1, 50), new ECB_default(4, 51)), new ECBlocks_default(28, new ECB_default(4, 22), new ECB_default(4, 23)), new ECBlocks_default(24, new ECB_default(3, 12), new ECB_default(8, 13))),
    new Version3(12, Int32Array.from([6, 32, 58]), new ECBlocks_default(24, new ECB_default(2, 92), new ECB_default(2, 93)), new ECBlocks_default(22, new ECB_default(6, 36), new ECB_default(2, 37)), new ECBlocks_default(26, new ECB_default(4, 20), new ECB_default(6, 21)), new ECBlocks_default(28, new ECB_default(7, 14), new ECB_default(4, 15))),
    new Version3(13, Int32Array.from([6, 34, 62]), new ECBlocks_default(26, new ECB_default(4, 107)), new ECBlocks_default(22, new ECB_default(8, 37), new ECB_default(1, 38)), new ECBlocks_default(24, new ECB_default(8, 20), new ECB_default(4, 21)), new ECBlocks_default(22, new ECB_default(12, 11), new ECB_default(4, 12))),
    new Version3(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_default(30, new ECB_default(3, 115), new ECB_default(1, 116)), new ECBlocks_default(24, new ECB_default(4, 40), new ECB_default(5, 41)), new ECBlocks_default(20, new ECB_default(11, 16), new ECB_default(5, 17)), new ECBlocks_default(24, new ECB_default(11, 12), new ECB_default(5, 13))),
    new Version3(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_default(22, new ECB_default(5, 87), new ECB_default(1, 88)), new ECBlocks_default(24, new ECB_default(5, 41), new ECB_default(5, 42)), new ECBlocks_default(30, new ECB_default(5, 24), new ECB_default(7, 25)), new ECBlocks_default(24, new ECB_default(11, 12), new ECB_default(7, 13))),
    new Version3(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_default(24, new ECB_default(5, 98), new ECB_default(1, 99)), new ECBlocks_default(28, new ECB_default(7, 45), new ECB_default(3, 46)), new ECBlocks_default(24, new ECB_default(15, 19), new ECB_default(2, 20)), new ECBlocks_default(30, new ECB_default(3, 15), new ECB_default(13, 16))),
    new Version3(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_default(28, new ECB_default(1, 107), new ECB_default(5, 108)), new ECBlocks_default(28, new ECB_default(10, 46), new ECB_default(1, 47)), new ECBlocks_default(28, new ECB_default(1, 22), new ECB_default(15, 23)), new ECBlocks_default(28, new ECB_default(2, 14), new ECB_default(17, 15))),
    new Version3(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_default(30, new ECB_default(5, 120), new ECB_default(1, 121)), new ECBlocks_default(26, new ECB_default(9, 43), new ECB_default(4, 44)), new ECBlocks_default(28, new ECB_default(17, 22), new ECB_default(1, 23)), new ECBlocks_default(28, new ECB_default(2, 14), new ECB_default(19, 15))),
    new Version3(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_default(28, new ECB_default(3, 113), new ECB_default(4, 114)), new ECBlocks_default(26, new ECB_default(3, 44), new ECB_default(11, 45)), new ECBlocks_default(26, new ECB_default(17, 21), new ECB_default(4, 22)), new ECBlocks_default(26, new ECB_default(9, 13), new ECB_default(16, 14))),
    new Version3(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_default(28, new ECB_default(3, 107), new ECB_default(5, 108)), new ECBlocks_default(26, new ECB_default(3, 41), new ECB_default(13, 42)), new ECBlocks_default(30, new ECB_default(15, 24), new ECB_default(5, 25)), new ECBlocks_default(28, new ECB_default(15, 15), new ECB_default(10, 16))),
    new Version3(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_default(28, new ECB_default(4, 116), new ECB_default(4, 117)), new ECBlocks_default(26, new ECB_default(17, 42)), new ECBlocks_default(28, new ECB_default(17, 22), new ECB_default(6, 23)), new ECBlocks_default(30, new ECB_default(19, 16), new ECB_default(6, 17))),
    new Version3(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_default(28, new ECB_default(2, 111), new ECB_default(7, 112)), new ECBlocks_default(28, new ECB_default(17, 46)), new ECBlocks_default(30, new ECB_default(7, 24), new ECB_default(16, 25)), new ECBlocks_default(24, new ECB_default(34, 13))),
    new Version3(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_default(30, new ECB_default(4, 121), new ECB_default(5, 122)), new ECBlocks_default(28, new ECB_default(4, 47), new ECB_default(14, 48)), new ECBlocks_default(30, new ECB_default(11, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(16, 15), new ECB_default(14, 16))),
    new Version3(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_default(30, new ECB_default(6, 117), new ECB_default(4, 118)), new ECBlocks_default(28, new ECB_default(6, 45), new ECB_default(14, 46)), new ECBlocks_default(30, new ECB_default(11, 24), new ECB_default(16, 25)), new ECBlocks_default(30, new ECB_default(30, 16), new ECB_default(2, 17))),
    new Version3(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_default(26, new ECB_default(8, 106), new ECB_default(4, 107)), new ECBlocks_default(28, new ECB_default(8, 47), new ECB_default(13, 48)), new ECBlocks_default(30, new ECB_default(7, 24), new ECB_default(22, 25)), new ECBlocks_default(30, new ECB_default(22, 15), new ECB_default(13, 16))),
    new Version3(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_default(28, new ECB_default(10, 114), new ECB_default(2, 115)), new ECBlocks_default(28, new ECB_default(19, 46), new ECB_default(4, 47)), new ECBlocks_default(28, new ECB_default(28, 22), new ECB_default(6, 23)), new ECBlocks_default(30, new ECB_default(33, 16), new ECB_default(4, 17))),
    new Version3(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_default(30, new ECB_default(8, 122), new ECB_default(4, 123)), new ECBlocks_default(28, new ECB_default(22, 45), new ECB_default(3, 46)), new ECBlocks_default(30, new ECB_default(8, 23), new ECB_default(26, 24)), new ECBlocks_default(30, new ECB_default(12, 15), new ECB_default(28, 16))),
    new Version3(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_default(30, new ECB_default(3, 117), new ECB_default(10, 118)), new ECBlocks_default(28, new ECB_default(3, 45), new ECB_default(23, 46)), new ECBlocks_default(30, new ECB_default(4, 24), new ECB_default(31, 25)), new ECBlocks_default(30, new ECB_default(11, 15), new ECB_default(31, 16))),
    new Version3(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_default(30, new ECB_default(7, 116), new ECB_default(7, 117)), new ECBlocks_default(28, new ECB_default(21, 45), new ECB_default(7, 46)), new ECBlocks_default(30, new ECB_default(1, 23), new ECB_default(37, 24)), new ECBlocks_default(30, new ECB_default(19, 15), new ECB_default(26, 16))),
    new Version3(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_default(30, new ECB_default(5, 115), new ECB_default(10, 116)), new ECBlocks_default(28, new ECB_default(19, 47), new ECB_default(10, 48)), new ECBlocks_default(30, new ECB_default(15, 24), new ECB_default(25, 25)), new ECBlocks_default(30, new ECB_default(23, 15), new ECB_default(25, 16))),
    new Version3(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_default(30, new ECB_default(13, 115), new ECB_default(3, 116)), new ECBlocks_default(28, new ECB_default(2, 46), new ECB_default(29, 47)), new ECBlocks_default(30, new ECB_default(42, 24), new ECB_default(1, 25)), new ECBlocks_default(30, new ECB_default(23, 15), new ECB_default(28, 16))),
    new Version3(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_default(30, new ECB_default(17, 115)), new ECBlocks_default(28, new ECB_default(10, 46), new ECB_default(23, 47)), new ECBlocks_default(30, new ECB_default(10, 24), new ECB_default(35, 25)), new ECBlocks_default(30, new ECB_default(19, 15), new ECB_default(35, 16))),
    new Version3(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_default(30, new ECB_default(17, 115), new ECB_default(1, 116)), new ECBlocks_default(28, new ECB_default(14, 46), new ECB_default(21, 47)), new ECBlocks_default(30, new ECB_default(29, 24), new ECB_default(19, 25)), new ECBlocks_default(30, new ECB_default(11, 15), new ECB_default(46, 16))),
    new Version3(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_default(30, new ECB_default(13, 115), new ECB_default(6, 116)), new ECBlocks_default(28, new ECB_default(14, 46), new ECB_default(23, 47)), new ECBlocks_default(30, new ECB_default(44, 24), new ECB_default(7, 25)), new ECBlocks_default(30, new ECB_default(59, 16), new ECB_default(1, 17))),
    new Version3(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_default(30, new ECB_default(12, 121), new ECB_default(7, 122)), new ECBlocks_default(28, new ECB_default(12, 47), new ECB_default(26, 48)), new ECBlocks_default(30, new ECB_default(39, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(22, 15), new ECB_default(41, 16))),
    new Version3(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_default(30, new ECB_default(6, 121), new ECB_default(14, 122)), new ECBlocks_default(28, new ECB_default(6, 47), new ECB_default(34, 48)), new ECBlocks_default(30, new ECB_default(46, 24), new ECB_default(10, 25)), new ECBlocks_default(30, new ECB_default(2, 15), new ECB_default(64, 16))),
    new Version3(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_default(30, new ECB_default(17, 122), new ECB_default(4, 123)), new ECBlocks_default(28, new ECB_default(29, 46), new ECB_default(14, 47)), new ECBlocks_default(30, new ECB_default(49, 24), new ECB_default(10, 25)), new ECBlocks_default(30, new ECB_default(24, 15), new ECB_default(46, 16))),
    new Version3(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_default(30, new ECB_default(4, 122), new ECB_default(18, 123)), new ECBlocks_default(28, new ECB_default(13, 46), new ECB_default(32, 47)), new ECBlocks_default(30, new ECB_default(48, 24), new ECB_default(14, 25)), new ECBlocks_default(30, new ECB_default(42, 15), new ECB_default(32, 16))),
    new Version3(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_default(30, new ECB_default(20, 117), new ECB_default(4, 118)), new ECBlocks_default(28, new ECB_default(40, 47), new ECB_default(7, 48)), new ECBlocks_default(30, new ECB_default(43, 24), new ECB_default(22, 25)), new ECBlocks_default(30, new ECB_default(10, 15), new ECB_default(67, 16))),
    new Version3(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_default(30, new ECB_default(19, 118), new ECB_default(6, 119)), new ECBlocks_default(28, new ECB_default(18, 47), new ECB_default(31, 48)), new ECBlocks_default(30, new ECB_default(34, 24), new ECB_default(34, 25)), new ECBlocks_default(30, new ECB_default(20, 15), new ECB_default(61, 16)))
  ];
  return Version3;
}();
var Version_default2 = Version2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/DataMask.js
var DataMaskValues;
(function(DataMaskValues2) {
  DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
  DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
  DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
  DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
  DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
  DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
  DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
  DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
})(DataMaskValues || (DataMaskValues = {}));
var DataMask = function() {
  function DataMask2(value, isMasked) {
    this.value = value;
    this.isMasked = isMasked;
  }
  DataMask2.prototype.unmaskBitMatrix = function(bits, dimension) {
    for (var i = 0; i < dimension; i++) {
      for (var j = 0; j < dimension; j++) {
        if (this.isMasked(i, j)) {
          bits.flip(j, i);
        }
      }
    }
  };
  DataMask2.values = new Map([
    [DataMaskValues.DATA_MASK_000, new DataMask2(DataMaskValues.DATA_MASK_000, function(i, j) {
      return (i + j & 1) === 0;
    })],
    [DataMaskValues.DATA_MASK_001, new DataMask2(DataMaskValues.DATA_MASK_001, function(i, j) {
      return (i & 1) === 0;
    })],
    [DataMaskValues.DATA_MASK_010, new DataMask2(DataMaskValues.DATA_MASK_010, function(i, j) {
      return j % 3 === 0;
    })],
    [DataMaskValues.DATA_MASK_011, new DataMask2(DataMaskValues.DATA_MASK_011, function(i, j) {
      return (i + j) % 3 === 0;
    })],
    [DataMaskValues.DATA_MASK_100, new DataMask2(DataMaskValues.DATA_MASK_100, function(i, j) {
      return (Math.floor(i / 2) + Math.floor(j / 3) & 1) === 0;
    })],
    [DataMaskValues.DATA_MASK_101, new DataMask2(DataMaskValues.DATA_MASK_101, function(i, j) {
      return i * j % 6 === 0;
    })],
    [DataMaskValues.DATA_MASK_110, new DataMask2(DataMaskValues.DATA_MASK_110, function(i, j) {
      return i * j % 6 < 3;
    })],
    [DataMaskValues.DATA_MASK_111, new DataMask2(DataMaskValues.DATA_MASK_111, function(i, j) {
      return (i + j + i * j % 3 & 1) === 0;
    })]
  ]);
  return DataMask2;
}();
var DataMask_default = DataMask;

// node_modules/@zxing/library/esm/core/qrcode/decoder/BitMatrixParser.js
var BitMatrixParser2 = function() {
  function BitMatrixParser3(bitMatrix) {
    var dimension = bitMatrix.getHeight();
    if (dimension < 21 || (dimension & 3) !== 1) {
      throw new FormatException_default();
    }
    this.bitMatrix = bitMatrix;
  }
  BitMatrixParser3.prototype.readFormatInformation = function() {
    if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
      return this.parsedFormatInfo;
    }
    var formatInfoBits1 = 0;
    for (var i = 0; i < 6; i++) {
      formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
    }
    formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
    formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
    formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
    for (var j = 5; j >= 0; j--) {
      formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
    }
    var dimension = this.bitMatrix.getHeight();
    var formatInfoBits2 = 0;
    var jMin = dimension - 7;
    for (var j = dimension - 1; j >= jMin; j--) {
      formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
    }
    for (var i = dimension - 8; i < dimension; i++) {
      formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
    }
    this.parsedFormatInfo = FormatInformation_default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
    if (this.parsedFormatInfo !== null) {
      return this.parsedFormatInfo;
    }
    throw new FormatException_default();
  };
  BitMatrixParser3.prototype.readVersion = function() {
    if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
      return this.parsedVersion;
    }
    var dimension = this.bitMatrix.getHeight();
    var provisionalVersion = Math.floor((dimension - 17) / 4);
    if (provisionalVersion <= 6) {
      return Version_default2.getVersionForNumber(provisionalVersion);
    }
    var versionBits = 0;
    var ijMin = dimension - 11;
    for (var j = 5; j >= 0; j--) {
      for (var i = dimension - 9; i >= ijMin; i--) {
        versionBits = this.copyBit(i, j, versionBits);
      }
    }
    var theParsedVersion = Version_default2.decodeVersionInformation(versionBits);
    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
      this.parsedVersion = theParsedVersion;
      return theParsedVersion;
    }
    versionBits = 0;
    for (var i = 5; i >= 0; i--) {
      for (var j = dimension - 9; j >= ijMin; j--) {
        versionBits = this.copyBit(i, j, versionBits);
      }
    }
    theParsedVersion = Version_default2.decodeVersionInformation(versionBits);
    if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
      this.parsedVersion = theParsedVersion;
      return theParsedVersion;
    }
    throw new FormatException_default();
  };
  BitMatrixParser3.prototype.copyBit = function(i, j, versionBits) {
    var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
    return bit ? versionBits << 1 | 1 : versionBits << 1;
  };
  BitMatrixParser3.prototype.readCodewords = function() {
    var formatInfo = this.readFormatInformation();
    var version = this.readVersion();
    var dataMask = DataMask_default.values.get(formatInfo.getDataMask());
    var dimension = this.bitMatrix.getHeight();
    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
    var functionPattern = version.buildFunctionPattern();
    var readingUp = true;
    var result = new Uint8Array(version.getTotalCodewords());
    var resultOffset = 0;
    var currentByte = 0;
    var bitsRead = 0;
    for (var j = dimension - 1; j > 0; j -= 2) {
      if (j === 6) {
        j--;
      }
      for (var count = 0; count < dimension; count++) {
        var i = readingUp ? dimension - 1 - count : count;
        for (var col = 0; col < 2; col++) {
          if (!functionPattern.get(j - col, i)) {
            bitsRead++;
            currentByte <<= 1;
            if (this.bitMatrix.get(j - col, i)) {
              currentByte |= 1;
            }
            if (bitsRead === 8) {
              result[resultOffset++] = currentByte;
              bitsRead = 0;
              currentByte = 0;
            }
          }
        }
      }
      readingUp = !readingUp;
    }
    if (resultOffset !== version.getTotalCodewords()) {
      throw new FormatException_default();
    }
    return result;
  };
  BitMatrixParser3.prototype.remask = function() {
    if (this.parsedFormatInfo === null) {
      return;
    }
    var dataMask = DataMask_default.values[this.parsedFormatInfo.getDataMask()];
    var dimension = this.bitMatrix.getHeight();
    dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
  };
  BitMatrixParser3.prototype.setMirror = function(isMirror) {
    this.parsedVersion = null;
    this.parsedFormatInfo = null;
    this.isMirror = isMirror;
  };
  BitMatrixParser3.prototype.mirror = function() {
    var bitMatrix = this.bitMatrix;
    for (var x2 = 0, width = bitMatrix.getWidth(); x2 < width; x2++) {
      for (var y = x2 + 1, height = bitMatrix.getHeight(); y < height; y++) {
        if (bitMatrix.get(x2, y) !== bitMatrix.get(y, x2)) {
          bitMatrix.flip(y, x2);
          bitMatrix.flip(x2, y);
        }
      }
    }
  };
  return BitMatrixParser3;
}();
var BitMatrixParser_default2 = BitMatrixParser2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/DataBlock.js
var __values23 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DataBlock2 = function() {
  function DataBlock3(numDataCodewords, codewords) {
    this.numDataCodewords = numDataCodewords;
    this.codewords = codewords;
  }
  DataBlock3.getDataBlocks = function(rawCodewords, version, ecLevel) {
    var e_1, _a, e_2, _b;
    if (rawCodewords.length !== version.getTotalCodewords()) {
      throw new IllegalArgumentException_default();
    }
    var ecBlocks = version.getECBlocksForLevel(ecLevel);
    var totalBlocks = 0;
    var ecBlockArray = ecBlocks.getECBlocks();
    try {
      for (var ecBlockArray_1 = __values23(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
        var ecBlock = ecBlockArray_1_1.value;
        totalBlocks += ecBlock.getCount();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return))
          _a.call(ecBlockArray_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var result = new Array(totalBlocks);
    var numResultBlocks = 0;
    try {
      for (var ecBlockArray_2 = __values23(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
        var ecBlock = ecBlockArray_2_1.value;
        for (var i = 0; i < ecBlock.getCount(); i++) {
          var numDataCodewords = ecBlock.getDataCodewords();
          var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
          result[numResultBlocks++] = new DataBlock3(numDataCodewords, new Uint8Array(numBlockCodewords));
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return))
          _b.call(ecBlockArray_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    var shorterBlocksTotalCodewords = result[0].codewords.length;
    var longerBlocksStartAt = result.length - 1;
    while (longerBlocksStartAt >= 0) {
      var numCodewords = result[longerBlocksStartAt].codewords.length;
      if (numCodewords === shorterBlocksTotalCodewords) {
        break;
      }
      longerBlocksStartAt--;
    }
    longerBlocksStartAt++;
    var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
    var rawCodewordsOffset = 0;
    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
      }
    }
    for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
      result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
    }
    var max = result[0].codewords.length;
    for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
      for (var j = 0; j < numResultBlocks; j++) {
        var iOffset = j < longerBlocksStartAt ? i : i + 1;
        result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
      }
    }
    return result;
  };
  DataBlock3.prototype.getNumDataCodewords = function() {
    return this.numDataCodewords;
  };
  DataBlock3.prototype.getCodewords = function() {
    return this.codewords;
  };
  return DataBlock3;
}();
var DataBlock_default2 = DataBlock2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/Mode.js
var ModeValues;
(function(ModeValues2) {
  ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
  ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
  ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
  ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
  ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
  ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
  ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
  ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
  ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
  ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
})(ModeValues || (ModeValues = {}));
var Mode2 = function() {
  function Mode4(value, stringValue, characterCountBitsForVersions, bits) {
    this.value = value;
    this.stringValue = stringValue;
    this.characterCountBitsForVersions = characterCountBitsForVersions;
    this.bits = bits;
    Mode4.FOR_BITS.set(bits, this);
    Mode4.FOR_VALUE.set(value, this);
  }
  Mode4.forBits = function(bits) {
    var mode = Mode4.FOR_BITS.get(bits);
    if (mode === void 0) {
      throw new IllegalArgumentException_default();
    }
    return mode;
  };
  Mode4.prototype.getCharacterCountBits = function(version) {
    var versionNumber = version.getVersionNumber();
    var offset;
    if (versionNumber <= 9) {
      offset = 0;
    } else if (versionNumber <= 26) {
      offset = 1;
    } else {
      offset = 2;
    }
    return this.characterCountBitsForVersions[offset];
  };
  Mode4.prototype.getValue = function() {
    return this.value;
  };
  Mode4.prototype.getBits = function() {
    return this.bits;
  };
  Mode4.prototype.equals = function(o) {
    if (!(o instanceof Mode4)) {
      return false;
    }
    var other = o;
    return this.value === other.value;
  };
  Mode4.prototype.toString = function() {
    return this.stringValue;
  };
  Mode4.FOR_BITS = new Map();
  Mode4.FOR_VALUE = new Map();
  Mode4.TERMINATOR = new Mode4(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
  Mode4.NUMERIC = new Mode4(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
  Mode4.ALPHANUMERIC = new Mode4(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
  Mode4.STRUCTURED_APPEND = new Mode4(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
  Mode4.BYTE = new Mode4(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
  Mode4.ECI = new Mode4(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
  Mode4.KANJI = new Mode4(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
  Mode4.FNC1_FIRST_POSITION = new Mode4(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
  Mode4.FNC1_SECOND_POSITION = new Mode4(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
  Mode4.HANZI = new Mode4(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
  return Mode4;
}();
var Mode_default = Mode2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/DecodedBitStreamParser.js
var DecodedBitStreamParser2 = function() {
  function DecodedBitStreamParser4() {
  }
  DecodedBitStreamParser4.decode = function(bytes, version, ecLevel, hints) {
    var bits = new BitSource_default(bytes);
    var result = new StringBuilder_default();
    var byteSegments = new Array();
    var symbolSequence = -1;
    var parityData = -1;
    try {
      var currentCharacterSetECI = null;
      var fc1InEffect = false;
      var mode = void 0;
      do {
        if (bits.available() < 4) {
          mode = Mode_default.TERMINATOR;
        } else {
          var modeBits = bits.readBits(4);
          mode = Mode_default.forBits(modeBits);
        }
        switch (mode) {
          case Mode_default.TERMINATOR:
            break;
          case Mode_default.FNC1_FIRST_POSITION:
          case Mode_default.FNC1_SECOND_POSITION:
            fc1InEffect = true;
            break;
          case Mode_default.STRUCTURED_APPEND:
            if (bits.available() < 16) {
              throw new FormatException_default();
            }
            symbolSequence = bits.readBits(8);
            parityData = bits.readBits(8);
            break;
          case Mode_default.ECI:
            var value = DecodedBitStreamParser4.parseECIValue(bits);
            currentCharacterSetECI = CharacterSetECI_default.getCharacterSetECIByValue(value);
            if (currentCharacterSetECI === null) {
              throw new FormatException_default();
            }
            break;
          case Mode_default.HANZI:
            var subset = bits.readBits(4);
            var countHanzi = bits.readBits(mode.getCharacterCountBits(version));
            if (subset === DecodedBitStreamParser4.GB2312_SUBSET) {
              DecodedBitStreamParser4.decodeHanziSegment(bits, result, countHanzi);
            }
            break;
          default:
            var count = bits.readBits(mode.getCharacterCountBits(version));
            switch (mode) {
              case Mode_default.NUMERIC:
                DecodedBitStreamParser4.decodeNumericSegment(bits, result, count);
                break;
              case Mode_default.ALPHANUMERIC:
                DecodedBitStreamParser4.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                break;
              case Mode_default.BYTE:
                DecodedBitStreamParser4.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                break;
              case Mode_default.KANJI:
                DecodedBitStreamParser4.decodeKanjiSegment(bits, result, count);
                break;
              default:
                throw new FormatException_default();
            }
            break;
        }
      } while (mode !== Mode_default.TERMINATOR);
    } catch (iae) {
      throw new FormatException_default();
    }
    return new DecoderResult_default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
  };
  DecodedBitStreamParser4.decodeHanziSegment = function(bits, result, count) {
    if (count * 13 > bits.available()) {
      throw new FormatException_default();
    }
    var buffer = new Uint8Array(2 * count);
    var offset = 0;
    while (count > 0) {
      var twoBytes = bits.readBits(13);
      var assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
      if (assembledTwoBytes < 959) {
        assembledTwoBytes += 41377;
      } else {
        assembledTwoBytes += 42657;
      }
      buffer[offset] = assembledTwoBytes >> 8 & 255;
      buffer[offset + 1] = assembledTwoBytes & 255;
      offset += 2;
      count--;
    }
    try {
      result.append(StringEncoding_default.decode(buffer, StringUtils_default.GB2312));
    } catch (ignored) {
      throw new FormatException_default(ignored);
    }
  };
  DecodedBitStreamParser4.decodeKanjiSegment = function(bits, result, count) {
    if (count * 13 > bits.available()) {
      throw new FormatException_default();
    }
    var buffer = new Uint8Array(2 * count);
    var offset = 0;
    while (count > 0) {
      var twoBytes = bits.readBits(13);
      var assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
      if (assembledTwoBytes < 7936) {
        assembledTwoBytes += 33088;
      } else {
        assembledTwoBytes += 49472;
      }
      buffer[offset] = assembledTwoBytes >> 8;
      buffer[offset + 1] = assembledTwoBytes;
      offset += 2;
      count--;
    }
    try {
      result.append(StringEncoding_default.decode(buffer, StringUtils_default.SHIFT_JIS));
    } catch (ignored) {
      throw new FormatException_default(ignored);
    }
  };
  DecodedBitStreamParser4.decodeByteSegment = function(bits, result, count, currentCharacterSetECI, byteSegments, hints) {
    if (8 * count > bits.available()) {
      throw new FormatException_default();
    }
    var readBytes = new Uint8Array(count);
    for (var i = 0; i < count; i++) {
      readBytes[i] = bits.readBits(8);
    }
    var encoding2;
    if (currentCharacterSetECI === null) {
      encoding2 = StringUtils_default.guessEncoding(readBytes, hints);
    } else {
      encoding2 = currentCharacterSetECI.getName();
    }
    try {
      result.append(StringEncoding_default.decode(readBytes, encoding2));
    } catch (ignored) {
      throw new FormatException_default(ignored);
    }
    byteSegments.push(readBytes);
  };
  DecodedBitStreamParser4.toAlphaNumericChar = function(value) {
    if (value >= DecodedBitStreamParser4.ALPHANUMERIC_CHARS.length) {
      throw new FormatException_default();
    }
    return DecodedBitStreamParser4.ALPHANUMERIC_CHARS[value];
  };
  DecodedBitStreamParser4.decodeAlphanumericSegment = function(bits, result, count, fc1InEffect) {
    var start = result.length();
    while (count > 1) {
      if (bits.available() < 11) {
        throw new FormatException_default();
      }
      var nextTwoCharsBits = bits.readBits(11);
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(nextTwoCharsBits % 45));
      count -= 2;
    }
    if (count === 1) {
      if (bits.available() < 6) {
        throw new FormatException_default();
      }
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(bits.readBits(6)));
    }
    if (fc1InEffect) {
      for (var i = start; i < result.length(); i++) {
        if (result.charAt(i) === "%") {
          if (i < result.length() - 1 && result.charAt(i + 1) === "%") {
            result.deleteCharAt(i + 1);
          } else {
            result.setCharAt(i, String.fromCharCode(29));
          }
        }
      }
    }
  };
  DecodedBitStreamParser4.decodeNumericSegment = function(bits, result, count) {
    while (count >= 3) {
      if (bits.available() < 10) {
        throw new FormatException_default();
      }
      var threeDigitsBits = bits.readBits(10);
      if (threeDigitsBits >= 1e3) {
        throw new FormatException_default();
      }
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(threeDigitsBits % 10));
      count -= 3;
    }
    if (count === 2) {
      if (bits.available() < 7) {
        throw new FormatException_default();
      }
      var twoDigitsBits = bits.readBits(7);
      if (twoDigitsBits >= 100) {
        throw new FormatException_default();
      }
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(twoDigitsBits % 10));
    } else if (count === 1) {
      if (bits.available() < 4) {
        throw new FormatException_default();
      }
      var digitBits = bits.readBits(4);
      if (digitBits >= 10) {
        throw new FormatException_default();
      }
      result.append(DecodedBitStreamParser4.toAlphaNumericChar(digitBits));
    }
  };
  DecodedBitStreamParser4.parseECIValue = function(bits) {
    var firstByte = bits.readBits(8);
    if ((firstByte & 128) === 0) {
      return firstByte & 127;
    }
    if ((firstByte & 192) === 128) {
      var secondByte = bits.readBits(8);
      return (firstByte & 63) << 8 & 4294967295 | secondByte;
    }
    if ((firstByte & 224) === 192) {
      var secondThirdBytes = bits.readBits(16);
      return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
    }
    throw new FormatException_default();
  };
  DecodedBitStreamParser4.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  DecodedBitStreamParser4.GB2312_SUBSET = 1;
  return DecodedBitStreamParser4;
}();
var DecodedBitStreamParser_default2 = DecodedBitStreamParser2;

// node_modules/@zxing/library/esm/core/qrcode/decoder/QRCodeDecoderMetaData.js
var QRCodeDecoderMetaData = function() {
  function QRCodeDecoderMetaData2(mirrored) {
    this.mirrored = mirrored;
  }
  QRCodeDecoderMetaData2.prototype.isMirrored = function() {
    return this.mirrored;
  };
  QRCodeDecoderMetaData2.prototype.applyMirroredCorrection = function(points) {
    if (!this.mirrored || points === null || points.length < 3) {
      return;
    }
    var bottomLeft = points[0];
    points[0] = points[2];
    points[2] = bottomLeft;
  };
  return QRCodeDecoderMetaData2;
}();
var QRCodeDecoderMetaData_default = QRCodeDecoderMetaData;

// node_modules/@zxing/library/esm/core/qrcode/decoder/Decoder.js
var __values24 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Decoder3 = function() {
  function Decoder4() {
    this.rsDecoder = new ReedSolomonDecoder_default(GenericGF_default.QR_CODE_FIELD_256);
  }
  Decoder4.prototype.decodeBooleanArray = function(image, hints) {
    return this.decodeBitMatrix(BitMatrix_default.parseFromBooleanArray(image), hints);
  };
  Decoder4.prototype.decodeBitMatrix = function(bits, hints) {
    var parser = new BitMatrixParser_default2(bits);
    var ex = null;
    try {
      return this.decodeBitMatrixParser(parser, hints);
    } catch (e) {
      ex = e;
    }
    try {
      parser.remask();
      parser.setMirror(true);
      parser.readVersion();
      parser.readFormatInformation();
      parser.mirror();
      var result = this.decodeBitMatrixParser(parser, hints);
      result.setOther(new QRCodeDecoderMetaData_default(true));
      return result;
    } catch (e) {
      if (ex !== null) {
        throw ex;
      }
      throw e;
    }
  };
  Decoder4.prototype.decodeBitMatrixParser = function(parser, hints) {
    var e_1, _a, e_2, _b;
    var version = parser.readVersion();
    var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
    var codewords = parser.readCodewords();
    var dataBlocks = DataBlock_default2.getDataBlocks(codewords, version, ecLevel);
    var totalBytes = 0;
    try {
      for (var dataBlocks_1 = __values24(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
        var dataBlock = dataBlocks_1_1.value;
        totalBytes += dataBlock.getNumDataCodewords();
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return))
          _a.call(dataBlocks_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var resultBytes = new Uint8Array(totalBytes);
    var resultOffset = 0;
    try {
      for (var dataBlocks_2 = __values24(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {
        var dataBlock = dataBlocks_2_1.value;
        var codewordBytes = dataBlock.getCodewords();
        var numDataCodewords = dataBlock.getNumDataCodewords();
        this.correctErrors(codewordBytes, numDataCodewords);
        for (var i = 0; i < numDataCodewords; i++) {
          resultBytes[resultOffset++] = codewordBytes[i];
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return))
          _b.call(dataBlocks_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return DecodedBitStreamParser_default2.decode(resultBytes, version, ecLevel, hints);
  };
  Decoder4.prototype.correctErrors = function(codewordBytes, numDataCodewords) {
    var codewordsInts = new Int32Array(codewordBytes);
    try {
      this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
    } catch (ignored) {
      throw new ChecksumException_default();
    }
    for (var i = 0; i < numDataCodewords; i++) {
      codewordBytes[i] = codewordsInts[i];
    }
  };
  return Decoder4;
}();
var Decoder_default3 = Decoder3;

// node_modules/@zxing/library/esm/core/qrcode/detector/AlignmentPattern.js
var __extends52 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AlignmentPattern = function(_super) {
  __extends52(AlignmentPattern2, _super);
  function AlignmentPattern2(posX, posY, estimatedModuleSize) {
    var _this = _super.call(this, posX, posY) || this;
    _this.estimatedModuleSize = estimatedModuleSize;
    return _this;
  }
  AlignmentPattern2.prototype.aboutEquals = function(moduleSize, i, j) {
    if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
      return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
    }
    return false;
  };
  AlignmentPattern2.prototype.combineEstimate = function(i, j, newModuleSize) {
    var combinedX = (this.getX() + j) / 2;
    var combinedY = (this.getY() + i) / 2;
    var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
    return new AlignmentPattern2(combinedX, combinedY, combinedModuleSize);
  };
  return AlignmentPattern2;
}(ResultPoint_default);
var AlignmentPattern_default = AlignmentPattern;

// node_modules/@zxing/library/esm/core/qrcode/detector/AlignmentPatternFinder.js
var __values25 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var AlignmentPatternFinder = function() {
  function AlignmentPatternFinder2(image, startX, startY, width, height, moduleSize, resultPointCallback) {
    this.image = image;
    this.startX = startX;
    this.startY = startY;
    this.width = width;
    this.height = height;
    this.moduleSize = moduleSize;
    this.resultPointCallback = resultPointCallback;
    this.possibleCenters = [];
    this.crossCheckStateCount = new Int32Array(3);
  }
  AlignmentPatternFinder2.prototype.find = function() {
    var startX = this.startX;
    var height = this.height;
    var width = this.width;
    var maxJ = startX + width;
    var middleI = this.startY + height / 2;
    var stateCount = new Int32Array(3);
    var image = this.image;
    for (var iGen = 0; iGen < height; iGen++) {
      var i = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;
      var j = startX;
      while (j < maxJ && !image.get(j, i)) {
        j++;
      }
      var currentState = 0;
      while (j < maxJ) {
        if (image.get(j, i)) {
          if (currentState === 1) {
            stateCount[1]++;
          } else {
            if (currentState === 2) {
              if (this.foundPatternCross(stateCount)) {
                var confirmed = this.handlePossibleCenter(stateCount, i, j);
                if (confirmed !== null) {
                  return confirmed;
                }
              }
              stateCount[0] = stateCount[2];
              stateCount[1] = 1;
              stateCount[2] = 0;
              currentState = 1;
            } else {
              stateCount[++currentState]++;
            }
          }
        } else {
          if (currentState === 1) {
            currentState++;
          }
          stateCount[currentState]++;
        }
        j++;
      }
      if (this.foundPatternCross(stateCount)) {
        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
        if (confirmed !== null) {
          return confirmed;
        }
      }
    }
    if (this.possibleCenters.length !== 0) {
      return this.possibleCenters[0];
    }
    throw new NotFoundException_default();
  };
  AlignmentPatternFinder2.centerFromEnd = function(stateCount, end) {
    return end - stateCount[2] - stateCount[1] / 2;
  };
  AlignmentPatternFinder2.prototype.foundPatternCross = function(stateCount) {
    var moduleSize = this.moduleSize;
    var maxVariance = moduleSize / 2;
    for (var i = 0; i < 3; i++) {
      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
        return false;
      }
    }
    return true;
  };
  AlignmentPatternFinder2.prototype.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
    var image = this.image;
    var maxI = image.getHeight();
    var stateCount = this.crossCheckStateCount;
    stateCount[0] = 0;
    stateCount[1] = 0;
    stateCount[2] = 0;
    var i = startI;
    while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
      stateCount[1]++;
      i--;
    }
    if (i < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
      stateCount[0]++;
      i--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }
    i = startI + 1;
    while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
      stateCount[1]++;
      i++;
    }
    if (i === maxI || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
      stateCount[2]++;
      i++;
    }
    if (stateCount[2] > maxCount) {
      return NaN;
    }
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
      return NaN;
    }
    return this.foundPatternCross(stateCount) ? AlignmentPatternFinder2.centerFromEnd(stateCount, i) : NaN;
  };
  AlignmentPatternFinder2.prototype.handlePossibleCenter = function(stateCount, i, j) {
    var e_1, _a;
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
    var centerJ = AlignmentPatternFinder2.centerFromEnd(stateCount, j);
    var centerI = this.crossCheckVertical(i, centerJ, 2 * stateCount[1], stateCountTotal);
    if (!isNaN(centerI)) {
      var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
      try {
        for (var _b = __values25(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
          var center = _c.value;
          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
            return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
          }
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var point = new AlignmentPattern_default(centerJ, centerI, estimatedModuleSize);
      this.possibleCenters.push(point);
      if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
        this.resultPointCallback.foundPossibleResultPoint(point);
      }
    }
    return null;
  };
  return AlignmentPatternFinder2;
}();
var AlignmentPatternFinder_default = AlignmentPatternFinder;

// node_modules/@zxing/library/esm/core/qrcode/detector/FinderPattern.js
var __extends53 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var FinderPattern2 = function(_super) {
  __extends53(FinderPattern3, _super);
  function FinderPattern3(posX, posY, estimatedModuleSize, count) {
    var _this = _super.call(this, posX, posY) || this;
    _this.estimatedModuleSize = estimatedModuleSize;
    _this.count = count;
    if (count === void 0) {
      _this.count = 1;
    }
    return _this;
  }
  FinderPattern3.prototype.getEstimatedModuleSize = function() {
    return this.estimatedModuleSize;
  };
  FinderPattern3.prototype.getCount = function() {
    return this.count;
  };
  FinderPattern3.prototype.aboutEquals = function(moduleSize, i, j) {
    if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
      var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
      return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
    }
    return false;
  };
  FinderPattern3.prototype.combineEstimate = function(i, j, newModuleSize) {
    var combinedCount = this.count + 1;
    var combinedX = (this.count * this.getX() + j) / combinedCount;
    var combinedY = (this.count * this.getY() + i) / combinedCount;
    var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
    return new FinderPattern3(combinedX, combinedY, combinedModuleSize, combinedCount);
  };
  return FinderPattern3;
}(ResultPoint_default);
var FinderPattern_default2 = FinderPattern2;

// node_modules/@zxing/library/esm/core/qrcode/detector/FinderPatternInfo.js
var FinderPatternInfo = function() {
  function FinderPatternInfo2(patternCenters) {
    this.bottomLeft = patternCenters[0];
    this.topLeft = patternCenters[1];
    this.topRight = patternCenters[2];
  }
  FinderPatternInfo2.prototype.getBottomLeft = function() {
    return this.bottomLeft;
  };
  FinderPatternInfo2.prototype.getTopLeft = function() {
    return this.topLeft;
  };
  FinderPatternInfo2.prototype.getTopRight = function() {
    return this.topRight;
  };
  return FinderPatternInfo2;
}();
var FinderPatternInfo_default = FinderPatternInfo;

// node_modules/@zxing/library/esm/core/qrcode/detector/FinderPatternFinder.js
var __values26 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var FinderPatternFinder = function() {
  function FinderPatternFinder2(image, resultPointCallback) {
    this.image = image;
    this.resultPointCallback = resultPointCallback;
    this.possibleCenters = [];
    this.crossCheckStateCount = new Int32Array(5);
    this.resultPointCallback = resultPointCallback;
  }
  FinderPatternFinder2.prototype.getImage = function() {
    return this.image;
  };
  FinderPatternFinder2.prototype.getPossibleCenters = function() {
    return this.possibleCenters;
  };
  FinderPatternFinder2.prototype.find = function(hints) {
    var tryHarder = hints !== null && hints !== void 0 && hints.get(DecodeHintType_default.TRY_HARDER) !== void 0;
    var pureBarcode = hints !== null && hints !== void 0 && hints.get(DecodeHintType_default.PURE_BARCODE) !== void 0;
    var image = this.image;
    var maxI = image.getHeight();
    var maxJ = image.getWidth();
    var iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder2.MAX_MODULES));
    if (iSkip < FinderPatternFinder2.MIN_SKIP || tryHarder) {
      iSkip = FinderPatternFinder2.MIN_SKIP;
    }
    var done = false;
    var stateCount = new Int32Array(5);
    for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;
      stateCount[3] = 0;
      stateCount[4] = 0;
      var currentState = 0;
      for (var j = 0; j < maxJ; j++) {
        if (image.get(j, i)) {
          if ((currentState & 1) === 1) {
            currentState++;
          }
          stateCount[currentState]++;
        } else {
          if ((currentState & 1) === 0) {
            if (currentState === 4) {
              if (FinderPatternFinder2.foundPatternCross(stateCount)) {
                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                if (confirmed === true) {
                  iSkip = 2;
                  if (this.hasSkipped === true) {
                    done = this.haveMultiplyConfirmedCenters();
                  } else {
                    var rowSkip = this.findRowSkip();
                    if (rowSkip > stateCount[2]) {
                      i += rowSkip - stateCount[2] - iSkip;
                      j = maxJ - 1;
                    }
                  }
                } else {
                  stateCount[0] = stateCount[2];
                  stateCount[1] = stateCount[3];
                  stateCount[2] = stateCount[4];
                  stateCount[3] = 1;
                  stateCount[4] = 0;
                  currentState = 3;
                  continue;
                }
                currentState = 0;
                stateCount[0] = 0;
                stateCount[1] = 0;
                stateCount[2] = 0;
                stateCount[3] = 0;
                stateCount[4] = 0;
              } else {
                stateCount[0] = stateCount[2];
                stateCount[1] = stateCount[3];
                stateCount[2] = stateCount[4];
                stateCount[3] = 1;
                stateCount[4] = 0;
                currentState = 3;
              }
            } else {
              stateCount[++currentState]++;
            }
          } else {
            stateCount[currentState]++;
          }
        }
      }
      if (FinderPatternFinder2.foundPatternCross(stateCount)) {
        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
        if (confirmed === true) {
          iSkip = stateCount[0];
          if (this.hasSkipped) {
            done = this.haveMultiplyConfirmedCenters();
          }
        }
      }
    }
    var patternInfo = this.selectBestPatterns();
    ResultPoint_default.orderBestPatterns(patternInfo);
    return new FinderPatternInfo_default(patternInfo);
  };
  FinderPatternFinder2.centerFromEnd = function(stateCount, end) {
    return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
  };
  FinderPatternFinder2.foundPatternCross = function(stateCount) {
    var totalModuleSize = 0;
    for (var i = 0; i < 5; i++) {
      var count = stateCount[i];
      if (count === 0) {
        return false;
      }
      totalModuleSize += count;
    }
    if (totalModuleSize < 7) {
      return false;
    }
    var moduleSize = totalModuleSize / 7;
    var maxVariance = moduleSize / 2;
    return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
  };
  FinderPatternFinder2.prototype.getCrossCheckStateCount = function() {
    var crossCheckStateCount = this.crossCheckStateCount;
    crossCheckStateCount[0] = 0;
    crossCheckStateCount[1] = 0;
    crossCheckStateCount[2] = 0;
    crossCheckStateCount[3] = 0;
    crossCheckStateCount[4] = 0;
    return crossCheckStateCount;
  };
  FinderPatternFinder2.prototype.crossCheckDiagonal = function(startI, centerJ, maxCount, originalStateCountTotal) {
    var stateCount = this.getCrossCheckStateCount();
    var i = 0;
    var image = this.image;
    while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
      stateCount[2]++;
      i++;
    }
    if (startI < i || centerJ < i) {
      return false;
    }
    while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) && stateCount[1] <= maxCount) {
      stateCount[1]++;
      i++;
    }
    if (startI < i || centerJ < i || stateCount[1] > maxCount) {
      return false;
    }
    while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) && stateCount[0] <= maxCount) {
      stateCount[0]++;
      i++;
    }
    if (stateCount[0] > maxCount) {
      return false;
    }
    var maxI = image.getHeight();
    var maxJ = image.getWidth();
    i = 1;
    while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
      stateCount[2]++;
      i++;
    }
    if (startI + i >= maxI || centerJ + i >= maxJ) {
      return false;
    }
    while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) && stateCount[3] < maxCount) {
      stateCount[3]++;
      i++;
    }
    if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
      return false;
    }
    while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) && stateCount[4] < maxCount) {
      stateCount[4]++;
      i++;
    }
    if (stateCount[4] >= maxCount) {
      return false;
    }
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
    return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder2.foundPatternCross(stateCount);
  };
  FinderPatternFinder2.prototype.crossCheckVertical = function(startI, centerJ, maxCount, originalStateCountTotal) {
    var image = this.image;
    var maxI = image.getHeight();
    var stateCount = this.getCrossCheckStateCount();
    var i = startI;
    while (i >= 0 && image.get(centerJ, i)) {
      stateCount[2]++;
      i--;
    }
    if (i < 0) {
      return NaN;
    }
    while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
      stateCount[1]++;
      i--;
    }
    if (i < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
      stateCount[0]++;
      i--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }
    i = startI + 1;
    while (i < maxI && image.get(centerJ, i)) {
      stateCount[2]++;
      i++;
    }
    if (i === maxI) {
      return NaN;
    }
    while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
      stateCount[3]++;
      i++;
    }
    if (i === maxI || stateCount[3] >= maxCount) {
      return NaN;
    }
    while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
      stateCount[4]++;
      i++;
    }
    if (stateCount[4] >= maxCount) {
      return NaN;
    }
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
      return NaN;
    }
    return FinderPatternFinder2.foundPatternCross(stateCount) ? FinderPatternFinder2.centerFromEnd(stateCount, i) : NaN;
  };
  FinderPatternFinder2.prototype.crossCheckHorizontal = function(startJ, centerI, maxCount, originalStateCountTotal) {
    var image = this.image;
    var maxJ = image.getWidth();
    var stateCount = this.getCrossCheckStateCount();
    var j = startJ;
    while (j >= 0 && image.get(j, centerI)) {
      stateCount[2]++;
      j--;
    }
    if (j < 0) {
      return NaN;
    }
    while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
      stateCount[1]++;
      j--;
    }
    if (j < 0 || stateCount[1] > maxCount) {
      return NaN;
    }
    while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
      stateCount[0]++;
      j--;
    }
    if (stateCount[0] > maxCount) {
      return NaN;
    }
    j = startJ + 1;
    while (j < maxJ && image.get(j, centerI)) {
      stateCount[2]++;
      j++;
    }
    if (j === maxJ) {
      return NaN;
    }
    while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
      stateCount[3]++;
      j++;
    }
    if (j === maxJ || stateCount[3] >= maxCount) {
      return NaN;
    }
    while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
      stateCount[4]++;
      j++;
    }
    if (stateCount[4] >= maxCount) {
      return NaN;
    }
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
      return NaN;
    }
    return FinderPatternFinder2.foundPatternCross(stateCount) ? FinderPatternFinder2.centerFromEnd(stateCount, j) : NaN;
  };
  FinderPatternFinder2.prototype.handlePossibleCenter = function(stateCount, i, j, pureBarcode) {
    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
    var centerJ = FinderPatternFinder2.centerFromEnd(stateCount, j);
    var centerI = this.crossCheckVertical(i, Math.floor(centerJ), stateCount[2], stateCountTotal);
    if (!isNaN(centerI)) {
      centerJ = this.crossCheckHorizontal(Math.floor(centerJ), Math.floor(centerI), stateCount[2], stateCountTotal);
      if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(Math.floor(centerI), Math.floor(centerJ), stateCount[2], stateCountTotal))) {
        var estimatedModuleSize = stateCountTotal / 7;
        var found = false;
        var possibleCenters = this.possibleCenters;
        for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {
          var center = possibleCenters[index];
          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
            possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
            found = true;
            break;
          }
        }
        if (!found) {
          var point = new FinderPattern_default2(centerJ, centerI, estimatedModuleSize);
          possibleCenters.push(point);
          if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
            this.resultPointCallback.foundPossibleResultPoint(point);
          }
        }
        return true;
      }
    }
    return false;
  };
  FinderPatternFinder2.prototype.findRowSkip = function() {
    var e_1, _a;
    var max = this.possibleCenters.length;
    if (max <= 1) {
      return 0;
    }
    var firstConfirmedCenter = null;
    try {
      for (var _b = __values26(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
        var center = _c.value;
        if (center.getCount() >= FinderPatternFinder2.CENTER_QUORUM) {
          if (firstConfirmedCenter == null) {
            firstConfirmedCenter = center;
          } else {
            this.hasSkipped = true;
            return Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
          }
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return 0;
  };
  FinderPatternFinder2.prototype.haveMultiplyConfirmedCenters = function() {
    var e_2, _a, e_3, _b;
    var confirmedCount = 0;
    var totalModuleSize = 0;
    var max = this.possibleCenters.length;
    try {
      for (var _c = __values26(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
        var pattern = _d.value;
        if (pattern.getCount() >= FinderPatternFinder2.CENTER_QUORUM) {
          confirmedCount++;
          totalModuleSize += pattern.getEstimatedModuleSize();
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    if (confirmedCount < 3) {
      return false;
    }
    var average = totalModuleSize / max;
    var totalDeviation = 0;
    try {
      for (var _e = __values26(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {
        var pattern = _f.value;
        totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (_f && !_f.done && (_b = _e.return))
          _b.call(_e);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return totalDeviation <= 0.05 * totalModuleSize;
  };
  FinderPatternFinder2.prototype.selectBestPatterns = function() {
    var e_4, _a, e_5, _b;
    var startSize = this.possibleCenters.length;
    if (startSize < 3) {
      throw new NotFoundException_default();
    }
    var possibleCenters = this.possibleCenters;
    var average;
    if (startSize > 3) {
      var totalModuleSize = 0;
      var square = 0;
      try {
        for (var _c = __values26(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
          var center = _d.value;
          var size = center.getEstimatedModuleSize();
          totalModuleSize += size;
          square += size * size;
        }
      } catch (e_4_1) {
        e_4 = {error: e_4_1};
      } finally {
        try {
          if (_d && !_d.done && (_a = _c.return))
            _a.call(_c);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      average = totalModuleSize / startSize;
      var stdDev = Math.sqrt(square / startSize - average * average);
      possibleCenters.sort(function(center1, center2) {
        var dA = Math.abs(center2.getEstimatedModuleSize() - average);
        var dB = Math.abs(center1.getEstimatedModuleSize() - average);
        return dA < dB ? -1 : dA > dB ? 1 : 0;
      });
      var limit = Math.max(0.2 * average, stdDev);
      for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
        var pattern = possibleCenters[i];
        if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
          possibleCenters.splice(i, 1);
          i--;
        }
      }
    }
    if (possibleCenters.length > 3) {
      var totalModuleSize = 0;
      try {
        for (var possibleCenters_1 = __values26(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {
          var possibleCenter = possibleCenters_1_1.value;
          totalModuleSize += possibleCenter.getEstimatedModuleSize();
        }
      } catch (e_5_1) {
        e_5 = {error: e_5_1};
      } finally {
        try {
          if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return))
            _b.call(possibleCenters_1);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      average = totalModuleSize / possibleCenters.length;
      possibleCenters.sort(function(center1, center2) {
        if (center2.getCount() === center1.getCount()) {
          var dA = Math.abs(center2.getEstimatedModuleSize() - average);
          var dB = Math.abs(center1.getEstimatedModuleSize() - average);
          return dA < dB ? 1 : dA > dB ? -1 : 0;
        } else {
          return center2.getCount() - center1.getCount();
        }
      });
      possibleCenters.splice(3);
    }
    return [
      possibleCenters[0],
      possibleCenters[1],
      possibleCenters[2]
    ];
  };
  FinderPatternFinder2.CENTER_QUORUM = 2;
  FinderPatternFinder2.MIN_SKIP = 3;
  FinderPatternFinder2.MAX_MODULES = 57;
  return FinderPatternFinder2;
}();
var FinderPatternFinder_default = FinderPatternFinder;

// node_modules/@zxing/library/esm/core/qrcode/detector/Detector.js
var Detector3 = function() {
  function Detector5(image) {
    this.image = image;
  }
  Detector5.prototype.getImage = function() {
    return this.image;
  };
  Detector5.prototype.getResultPointCallback = function() {
    return this.resultPointCallback;
  };
  Detector5.prototype.detect = function(hints) {
    this.resultPointCallback = hints === null || hints === void 0 ? null : hints.get(DecodeHintType_default.NEED_RESULT_POINT_CALLBACK);
    var finder = new FinderPatternFinder_default(this.image, this.resultPointCallback);
    var info = finder.find(hints);
    return this.processFinderPatternInfo(info);
  };
  Detector5.prototype.processFinderPatternInfo = function(info) {
    var topLeft = info.getTopLeft();
    var topRight = info.getTopRight();
    var bottomLeft = info.getBottomLeft();
    var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
    if (moduleSize < 1) {
      throw new NotFoundException_default("No pattern found in proccess finder.");
    }
    var dimension = Detector5.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
    var provisionalVersion = Version_default2.getProvisionalVersionForDimension(dimension);
    var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
    var alignmentPattern = null;
    if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
      var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
      var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
      var correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
      var estAlignmentX = Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
      var estAlignmentY = Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
      for (var i = 4; i <= 16; i <<= 1) {
        try {
          alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
          break;
        } catch (re) {
          if (!(re instanceof NotFoundException_default)) {
            throw re;
          }
        }
      }
    }
    var transform = Detector5.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
    var bits = Detector5.sampleGrid(this.image, transform, dimension);
    var points;
    if (alignmentPattern === null) {
      points = [bottomLeft, topLeft, topRight];
    } else {
      points = [bottomLeft, topLeft, topRight, alignmentPattern];
    }
    return new DetectorResult_default(bits, points);
  };
  Detector5.createTransform = function(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
    var dimMinusThree = dimension - 3.5;
    var bottomRightX;
    var bottomRightY;
    var sourceBottomRightX;
    var sourceBottomRightY;
    if (alignmentPattern !== null) {
      bottomRightX = alignmentPattern.getX();
      bottomRightY = alignmentPattern.getY();
      sourceBottomRightX = dimMinusThree - 3;
      sourceBottomRightY = sourceBottomRightX;
    } else {
      bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
      bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
      sourceBottomRightX = dimMinusThree;
      sourceBottomRightY = dimMinusThree;
    }
    return PerspectiveTransform_default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
  };
  Detector5.sampleGrid = function(image, transform, dimension) {
    var sampler = GridSamplerInstance_default.getInstance();
    return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
  };
  Detector5.computeDimension = function(topLeft, topRight, bottomLeft, moduleSize) {
    var tltrCentersDimension = MathUtils_default.round(ResultPoint_default.distance(topLeft, topRight) / moduleSize);
    var tlblCentersDimension = MathUtils_default.round(ResultPoint_default.distance(topLeft, bottomLeft) / moduleSize);
    var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
    switch (dimension & 3) {
      case 0:
        dimension++;
        break;
      case 2:
        dimension--;
        break;
      case 3:
        throw new NotFoundException_default("Dimensions could be not found.");
    }
    return dimension;
  };
  Detector5.prototype.calculateModuleSize = function(topLeft, topRight, bottomLeft) {
    return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
  };
  Detector5.prototype.calculateModuleSizeOneWay = function(pattern, otherPattern) {
    var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(pattern.getX()), Math.floor(pattern.getY()), Math.floor(otherPattern.getX()), Math.floor(otherPattern.getY()));
    var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(Math.floor(otherPattern.getX()), Math.floor(otherPattern.getY()), Math.floor(pattern.getX()), Math.floor(pattern.getY()));
    if (isNaN(moduleSizeEst1)) {
      return moduleSizeEst2 / 7;
    }
    if (isNaN(moduleSizeEst2)) {
      return moduleSizeEst1 / 7;
    }
    return (moduleSizeEst1 + moduleSizeEst2) / 14;
  };
  Detector5.prototype.sizeOfBlackWhiteBlackRunBothWays = function(fromX, fromY, toX, toY) {
    var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
    var scale = 1;
    var otherToX = fromX - (toX - fromX);
    if (otherToX < 0) {
      scale = fromX / (fromX - otherToX);
      otherToX = 0;
    } else if (otherToX >= this.image.getWidth()) {
      scale = (this.image.getWidth() - 1 - fromX) / (otherToX - fromX);
      otherToX = this.image.getWidth() - 1;
    }
    var otherToY = Math.floor(fromY - (toY - fromY) * scale);
    scale = 1;
    if (otherToY < 0) {
      scale = fromY / (fromY - otherToY);
      otherToY = 0;
    } else if (otherToY >= this.image.getHeight()) {
      scale = (this.image.getHeight() - 1 - fromY) / (otherToY - fromY);
      otherToY = this.image.getHeight() - 1;
    }
    otherToX = Math.floor(fromX + (otherToX - fromX) * scale);
    result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
    return result - 1;
  };
  Detector5.prototype.sizeOfBlackWhiteBlackRun = function(fromX, fromY, toX, toY) {
    var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
    if (steep) {
      var temp = fromX;
      fromX = fromY;
      fromY = temp;
      temp = toX;
      toX = toY;
      toY = temp;
    }
    var dx = Math.abs(toX - fromX);
    var dy = Math.abs(toY - fromY);
    var error = -dx / 2;
    var xstep = fromX < toX ? 1 : -1;
    var ystep = fromY < toY ? 1 : -1;
    var state = 0;
    var xLimit = toX + xstep;
    for (var x2 = fromX, y = fromY; x2 !== xLimit; x2 += xstep) {
      var realX = steep ? y : x2;
      var realY = steep ? x2 : y;
      if (state === 1 === this.image.get(realX, realY)) {
        if (state === 2) {
          return MathUtils_default.distance(x2, y, fromX, fromY);
        }
        state++;
      }
      error += dy;
      if (error > 0) {
        if (y === toY) {
          break;
        }
        y += ystep;
        error -= dx;
      }
    }
    if (state === 2) {
      return MathUtils_default.distance(toX + xstep, toY, fromX, fromY);
    }
    return NaN;
  };
  Detector5.prototype.findAlignmentInRegion = function(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
    var allowance = Math.floor(allowanceFactor * overallEstModuleSize);
    var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
    var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
    if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
      throw new NotFoundException_default("Alignment top exceeds estimated module size.");
    }
    var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
    var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
    if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
      throw new NotFoundException_default("Alignment bottom exceeds estimated module size.");
    }
    var alignmentFinder = new AlignmentPatternFinder_default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
    return alignmentFinder.find();
  };
  return Detector5;
}();
var Detector_default3 = Detector3;

// node_modules/@zxing/library/esm/core/qrcode/QRCodeReader.js
var QRCodeReader = function() {
  function QRCodeReader2() {
    this.decoder = new Decoder_default3();
  }
  QRCodeReader2.prototype.getDecoder = function() {
    return this.decoder;
  };
  QRCodeReader2.prototype.decode = function(image, hints) {
    var decoderResult;
    var points;
    if (hints !== void 0 && hints !== null && hints.get(DecodeHintType_default.PURE_BARCODE) !== void 0) {
      var bits = QRCodeReader2.extractPureBits(image.getBlackMatrix());
      decoderResult = this.decoder.decodeBitMatrix(bits, hints);
      points = QRCodeReader2.NO_POINTS;
    } else {
      var detectorResult = new Detector_default3(image.getBlackMatrix()).detect(hints);
      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
      points = detectorResult.getPoints();
    }
    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_default) {
      decoderResult.getOther().applyMirroredCorrection(points);
    }
    var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat_default.QR_CODE, void 0);
    var byteSegments = decoderResult.getByteSegments();
    if (byteSegments !== null) {
      result.putMetadata(ResultMetadataType_default.BYTE_SEGMENTS, byteSegments);
    }
    var ecLevel = decoderResult.getECLevel();
    if (ecLevel !== null) {
      result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, ecLevel);
    }
    if (decoderResult.hasStructuredAppend()) {
      result.putMetadata(ResultMetadataType_default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
      result.putMetadata(ResultMetadataType_default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
    }
    return result;
  };
  QRCodeReader2.prototype.reset = function() {
  };
  QRCodeReader2.extractPureBits = function(image) {
    var leftTopBlack = image.getTopLeftOnBit();
    var rightBottomBlack = image.getBottomRightOnBit();
    if (leftTopBlack === null || rightBottomBlack === null) {
      throw new NotFoundException_default();
    }
    var moduleSize = this.moduleSize(leftTopBlack, image);
    var top = leftTopBlack[1];
    var bottom = rightBottomBlack[1];
    var left = leftTopBlack[0];
    var right = rightBottomBlack[0];
    if (left >= right || top >= bottom) {
      throw new NotFoundException_default();
    }
    if (bottom - top !== right - left) {
      right = left + (bottom - top);
      if (right >= image.getWidth()) {
        throw new NotFoundException_default();
      }
    }
    var matrixWidth = Math.round((right - left + 1) / moduleSize);
    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);
    if (matrixWidth <= 0 || matrixHeight <= 0) {
      throw new NotFoundException_default();
    }
    if (matrixHeight !== matrixWidth) {
      throw new NotFoundException_default();
    }
    var nudge = Math.floor(moduleSize / 2);
    top += nudge;
    left += nudge;
    var nudgedTooFarRight = left + Math.floor((matrixWidth - 1) * moduleSize) - right;
    if (nudgedTooFarRight > 0) {
      if (nudgedTooFarRight > nudge) {
        throw new NotFoundException_default();
      }
      left -= nudgedTooFarRight;
    }
    var nudgedTooFarDown = top + Math.floor((matrixHeight - 1) * moduleSize) - bottom;
    if (nudgedTooFarDown > 0) {
      if (nudgedTooFarDown > nudge) {
        throw new NotFoundException_default();
      }
      top -= nudgedTooFarDown;
    }
    var bits = new BitMatrix_default(matrixWidth, matrixHeight);
    for (var y = 0; y < matrixHeight; y++) {
      var iOffset = top + Math.floor(y * moduleSize);
      for (var x2 = 0; x2 < matrixWidth; x2++) {
        if (image.get(left + Math.floor(x2 * moduleSize), iOffset)) {
          bits.set(x2, y);
        }
      }
    }
    return bits;
  };
  QRCodeReader2.moduleSize = function(leftTopBlack, image) {
    var height = image.getHeight();
    var width = image.getWidth();
    var x2 = leftTopBlack[0];
    var y = leftTopBlack[1];
    var inBlack = true;
    var transitions = 0;
    while (x2 < width && y < height) {
      if (inBlack !== image.get(x2, y)) {
        if (++transitions === 5) {
          break;
        }
        inBlack = !inBlack;
      }
      x2++;
      y++;
    }
    if (x2 === width || y === height) {
      throw new NotFoundException_default();
    }
    return (x2 - leftTopBlack[0]) / 7;
  };
  QRCodeReader2.NO_POINTS = new Array();
  return QRCodeReader2;
}();
var QRCodeReader_default = QRCodeReader;

// node_modules/@zxing/library/esm/core/pdf417/PDF417Common.js
var __values27 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var PDF417Common = function() {
  function PDF417Common2() {
  }
  PDF417Common2.prototype.PDF417Common = function() {
  };
  PDF417Common2.getBitCountSum = function(moduleBitCount) {
    return MathUtils_default.sum(moduleBitCount);
  };
  PDF417Common2.toIntArray = function(list) {
    var e_1, _a;
    if (list == null || !list.length) {
      return PDF417Common2.EMPTY_INT_ARRAY;
    }
    var result = new Int32Array(list.length);
    var i = 0;
    try {
      for (var list_1 = __values27(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
        var integer = list_1_1.value;
        result[i++] = integer;
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (list_1_1 && !list_1_1.done && (_a = list_1.return))
          _a.call(list_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return result;
  };
  PDF417Common2.getCodeword = function(symbol) {
    var i = Arrays_default.binarySearch(PDF417Common2.SYMBOL_TABLE, symbol & 262143);
    if (i < 0) {
      return -1;
    }
    return (PDF417Common2.CODEWORD_TABLE[i] - 1) % PDF417Common2.NUMBER_OF_CODEWORDS;
  };
  PDF417Common2.NUMBER_OF_CODEWORDS = 929;
  PDF417Common2.MAX_CODEWORDS_IN_BARCODE = PDF417Common2.NUMBER_OF_CODEWORDS - 1;
  PDF417Common2.MIN_ROWS_IN_BARCODE = 3;
  PDF417Common2.MAX_ROWS_IN_BARCODE = 90;
  PDF417Common2.MODULES_IN_CODEWORD = 17;
  PDF417Common2.MODULES_IN_STOP_PATTERN = 18;
  PDF417Common2.BARS_IN_MODULE = 8;
  PDF417Common2.EMPTY_INT_ARRAY = new Int32Array([]);
  PDF417Common2.SYMBOL_TABLE = Int32Array.from([
    66142,
    66170,
    66206,
    66236,
    66290,
    66292,
    66350,
    66382,
    66396,
    66454,
    66470,
    66476,
    66594,
    66600,
    66614,
    66626,
    66628,
    66632,
    66640,
    66654,
    66662,
    66668,
    66682,
    66690,
    66718,
    66720,
    66748,
    66758,
    66776,
    66798,
    66802,
    66804,
    66820,
    66824,
    66832,
    66846,
    66848,
    66876,
    66880,
    66936,
    66950,
    66956,
    66968,
    66992,
    67006,
    67022,
    67036,
    67042,
    67044,
    67048,
    67062,
    67118,
    67150,
    67164,
    67214,
    67228,
    67256,
    67294,
    67322,
    67350,
    67366,
    67372,
    67398,
    67404,
    67416,
    67438,
    67474,
    67476,
    67490,
    67492,
    67496,
    67510,
    67618,
    67624,
    67650,
    67656,
    67664,
    67678,
    67686,
    67692,
    67706,
    67714,
    67716,
    67728,
    67742,
    67744,
    67772,
    67782,
    67788,
    67800,
    67822,
    67826,
    67828,
    67842,
    67848,
    67870,
    67872,
    67900,
    67904,
    67960,
    67974,
    67992,
    68016,
    68030,
    68046,
    68060,
    68066,
    68068,
    68072,
    68086,
    68104,
    68112,
    68126,
    68128,
    68156,
    68160,
    68216,
    68336,
    68358,
    68364,
    68376,
    68400,
    68414,
    68448,
    68476,
    68494,
    68508,
    68536,
    68546,
    68548,
    68552,
    68560,
    68574,
    68582,
    68588,
    68654,
    68686,
    68700,
    68706,
    68708,
    68712,
    68726,
    68750,
    68764,
    68792,
    68802,
    68804,
    68808,
    68816,
    68830,
    68838,
    68844,
    68858,
    68878,
    68892,
    68920,
    68976,
    68990,
    68994,
    68996,
    69e3,
    69008,
    69022,
    69024,
    69052,
    69062,
    69068,
    69080,
    69102,
    69106,
    69108,
    69142,
    69158,
    69164,
    69190,
    69208,
    69230,
    69254,
    69260,
    69272,
    69296,
    69310,
    69326,
    69340,
    69386,
    69394,
    69396,
    69410,
    69416,
    69430,
    69442,
    69444,
    69448,
    69456,
    69470,
    69478,
    69484,
    69554,
    69556,
    69666,
    69672,
    69698,
    69704,
    69712,
    69726,
    69754,
    69762,
    69764,
    69776,
    69790,
    69792,
    69820,
    69830,
    69836,
    69848,
    69870,
    69874,
    69876,
    69890,
    69918,
    69920,
    69948,
    69952,
    70008,
    70022,
    70040,
    70064,
    70078,
    70094,
    70108,
    70114,
    70116,
    70120,
    70134,
    70152,
    70174,
    70176,
    70264,
    70384,
    70412,
    70448,
    70462,
    70496,
    70524,
    70542,
    70556,
    70584,
    70594,
    70600,
    70608,
    70622,
    70630,
    70636,
    70664,
    70672,
    70686,
    70688,
    70716,
    70720,
    70776,
    70896,
    71136,
    71180,
    71192,
    71216,
    71230,
    71264,
    71292,
    71360,
    71416,
    71452,
    71480,
    71536,
    71550,
    71554,
    71556,
    71560,
    71568,
    71582,
    71584,
    71612,
    71622,
    71628,
    71640,
    71662,
    71726,
    71732,
    71758,
    71772,
    71778,
    71780,
    71784,
    71798,
    71822,
    71836,
    71864,
    71874,
    71880,
    71888,
    71902,
    71910,
    71916,
    71930,
    71950,
    71964,
    71992,
    72048,
    72062,
    72066,
    72068,
    72080,
    72094,
    72096,
    72124,
    72134,
    72140,
    72152,
    72174,
    72178,
    72180,
    72206,
    72220,
    72248,
    72304,
    72318,
    72416,
    72444,
    72456,
    72464,
    72478,
    72480,
    72508,
    72512,
    72568,
    72588,
    72600,
    72624,
    72638,
    72654,
    72668,
    72674,
    72676,
    72680,
    72694,
    72726,
    72742,
    72748,
    72774,
    72780,
    72792,
    72814,
    72838,
    72856,
    72880,
    72894,
    72910,
    72924,
    72930,
    72932,
    72936,
    72950,
    72966,
    72972,
    72984,
    73008,
    73022,
    73056,
    73084,
    73102,
    73116,
    73144,
    73156,
    73160,
    73168,
    73182,
    73190,
    73196,
    73210,
    73226,
    73234,
    73236,
    73250,
    73252,
    73256,
    73270,
    73282,
    73284,
    73296,
    73310,
    73318,
    73324,
    73346,
    73348,
    73352,
    73360,
    73374,
    73376,
    73404,
    73414,
    73420,
    73432,
    73454,
    73498,
    73518,
    73522,
    73524,
    73550,
    73564,
    73570,
    73572,
    73576,
    73590,
    73800,
    73822,
    73858,
    73860,
    73872,
    73886,
    73888,
    73916,
    73944,
    73970,
    73972,
    73992,
    74014,
    74016,
    74044,
    74048,
    74104,
    74118,
    74136,
    74160,
    74174,
    74210,
    74212,
    74216,
    74230,
    74244,
    74256,
    74270,
    74272,
    74360,
    74480,
    74502,
    74508,
    74544,
    74558,
    74592,
    74620,
    74638,
    74652,
    74680,
    74690,
    74696,
    74704,
    74726,
    74732,
    74782,
    74784,
    74812,
    74992,
    75232,
    75288,
    75326,
    75360,
    75388,
    75456,
    75512,
    75576,
    75632,
    75646,
    75650,
    75652,
    75664,
    75678,
    75680,
    75708,
    75718,
    75724,
    75736,
    75758,
    75808,
    75836,
    75840,
    75896,
    76016,
    76256,
    76736,
    76824,
    76848,
    76862,
    76896,
    76924,
    76992,
    77048,
    77296,
    77340,
    77368,
    77424,
    77438,
    77536,
    77564,
    77572,
    77576,
    77584,
    77600,
    77628,
    77632,
    77688,
    77702,
    77708,
    77720,
    77744,
    77758,
    77774,
    77788,
    77870,
    77902,
    77916,
    77922,
    77928,
    77966,
    77980,
    78008,
    78018,
    78024,
    78032,
    78046,
    78060,
    78074,
    78094,
    78136,
    78192,
    78206,
    78210,
    78212,
    78224,
    78238,
    78240,
    78268,
    78278,
    78284,
    78296,
    78322,
    78324,
    78350,
    78364,
    78448,
    78462,
    78560,
    78588,
    78600,
    78622,
    78624,
    78652,
    78656,
    78712,
    78726,
    78744,
    78768,
    78782,
    78798,
    78812,
    78818,
    78820,
    78824,
    78838,
    78862,
    78876,
    78904,
    78960,
    78974,
    79072,
    79100,
    79296,
    79352,
    79368,
    79376,
    79390,
    79392,
    79420,
    79424,
    79480,
    79600,
    79628,
    79640,
    79664,
    79678,
    79712,
    79740,
    79772,
    79800,
    79810,
    79812,
    79816,
    79824,
    79838,
    79846,
    79852,
    79894,
    79910,
    79916,
    79942,
    79948,
    79960,
    79982,
    79988,
    80006,
    80024,
    80048,
    80062,
    80078,
    80092,
    80098,
    80100,
    80104,
    80134,
    80140,
    80176,
    80190,
    80224,
    80252,
    80270,
    80284,
    80312,
    80328,
    80336,
    80350,
    80358,
    80364,
    80378,
    80390,
    80396,
    80408,
    80432,
    80446,
    80480,
    80508,
    80576,
    80632,
    80654,
    80668,
    80696,
    80752,
    80766,
    80776,
    80784,
    80798,
    80800,
    80828,
    80844,
    80856,
    80878,
    80882,
    80884,
    80914,
    80916,
    80930,
    80932,
    80936,
    80950,
    80962,
    80968,
    80976,
    80990,
    80998,
    81004,
    81026,
    81028,
    81040,
    81054,
    81056,
    81084,
    81094,
    81100,
    81112,
    81134,
    81154,
    81156,
    81160,
    81168,
    81182,
    81184,
    81212,
    81216,
    81272,
    81286,
    81292,
    81304,
    81328,
    81342,
    81358,
    81372,
    81380,
    81384,
    81398,
    81434,
    81454,
    81458,
    81460,
    81486,
    81500,
    81506,
    81508,
    81512,
    81526,
    81550,
    81564,
    81592,
    81602,
    81604,
    81608,
    81616,
    81630,
    81638,
    81644,
    81702,
    81708,
    81722,
    81734,
    81740,
    81752,
    81774,
    81778,
    81780,
    82050,
    82078,
    82080,
    82108,
    82180,
    82184,
    82192,
    82206,
    82208,
    82236,
    82240,
    82296,
    82316,
    82328,
    82352,
    82366,
    82402,
    82404,
    82408,
    82440,
    82448,
    82462,
    82464,
    82492,
    82496,
    82552,
    82672,
    82694,
    82700,
    82712,
    82736,
    82750,
    82784,
    82812,
    82830,
    82882,
    82884,
    82888,
    82896,
    82918,
    82924,
    82952,
    82960,
    82974,
    82976,
    83004,
    83008,
    83064,
    83184,
    83424,
    83468,
    83480,
    83504,
    83518,
    83552,
    83580,
    83648,
    83704,
    83740,
    83768,
    83824,
    83838,
    83842,
    83844,
    83848,
    83856,
    83872,
    83900,
    83910,
    83916,
    83928,
    83950,
    83984,
    84e3,
    84028,
    84032,
    84088,
    84208,
    84448,
    84928,
    85040,
    85054,
    85088,
    85116,
    85184,
    85240,
    85488,
    85560,
    85616,
    85630,
    85728,
    85756,
    85764,
    85768,
    85776,
    85790,
    85792,
    85820,
    85824,
    85880,
    85894,
    85900,
    85912,
    85936,
    85966,
    85980,
    86048,
    86080,
    86136,
    86256,
    86496,
    86976,
    88160,
    88188,
    88256,
    88312,
    88560,
    89056,
    89200,
    89214,
    89312,
    89340,
    89536,
    89592,
    89608,
    89616,
    89632,
    89664,
    89720,
    89840,
    89868,
    89880,
    89904,
    89952,
    89980,
    89998,
    90012,
    90040,
    90190,
    90204,
    90254,
    90268,
    90296,
    90306,
    90308,
    90312,
    90334,
    90382,
    90396,
    90424,
    90480,
    90494,
    90500,
    90504,
    90512,
    90526,
    90528,
    90556,
    90566,
    90572,
    90584,
    90610,
    90612,
    90638,
    90652,
    90680,
    90736,
    90750,
    90848,
    90876,
    90884,
    90888,
    90896,
    90910,
    90912,
    90940,
    90944,
    91e3,
    91014,
    91020,
    91032,
    91056,
    91070,
    91086,
    91100,
    91106,
    91108,
    91112,
    91126,
    91150,
    91164,
    91192,
    91248,
    91262,
    91360,
    91388,
    91584,
    91640,
    91664,
    91678,
    91680,
    91708,
    91712,
    91768,
    91888,
    91928,
    91952,
    91966,
    92e3,
    92028,
    92046,
    92060,
    92088,
    92098,
    92100,
    92104,
    92112,
    92126,
    92134,
    92140,
    92188,
    92216,
    92272,
    92384,
    92412,
    92608,
    92664,
    93168,
    93200,
    93214,
    93216,
    93244,
    93248,
    93304,
    93424,
    93664,
    93720,
    93744,
    93758,
    93792,
    93820,
    93888,
    93944,
    93980,
    94008,
    94064,
    94078,
    94084,
    94088,
    94096,
    94110,
    94112,
    94140,
    94150,
    94156,
    94168,
    94246,
    94252,
    94278,
    94284,
    94296,
    94318,
    94342,
    94348,
    94360,
    94384,
    94398,
    94414,
    94428,
    94440,
    94470,
    94476,
    94488,
    94512,
    94526,
    94560,
    94588,
    94606,
    94620,
    94648,
    94658,
    94660,
    94664,
    94672,
    94686,
    94694,
    94700,
    94714,
    94726,
    94732,
    94744,
    94768,
    94782,
    94816,
    94844,
    94912,
    94968,
    94990,
    95004,
    95032,
    95088,
    95102,
    95112,
    95120,
    95134,
    95136,
    95164,
    95180,
    95192,
    95214,
    95218,
    95220,
    95244,
    95256,
    95280,
    95294,
    95328,
    95356,
    95424,
    95480,
    95728,
    95758,
    95772,
    95800,
    95856,
    95870,
    95968,
    95996,
    96008,
    96016,
    96030,
    96032,
    96060,
    96064,
    96120,
    96152,
    96176,
    96190,
    96220,
    96226,
    96228,
    96232,
    96290,
    96292,
    96296,
    96310,
    96322,
    96324,
    96328,
    96336,
    96350,
    96358,
    96364,
    96386,
    96388,
    96392,
    96400,
    96414,
    96416,
    96444,
    96454,
    96460,
    96472,
    96494,
    96498,
    96500,
    96514,
    96516,
    96520,
    96528,
    96542,
    96544,
    96572,
    96576,
    96632,
    96646,
    96652,
    96664,
    96688,
    96702,
    96718,
    96732,
    96738,
    96740,
    96744,
    96758,
    96772,
    96776,
    96784,
    96798,
    96800,
    96828,
    96832,
    96888,
    97008,
    97030,
    97036,
    97048,
    97072,
    97086,
    97120,
    97148,
    97166,
    97180,
    97208,
    97220,
    97224,
    97232,
    97246,
    97254,
    97260,
    97326,
    97330,
    97332,
    97358,
    97372,
    97378,
    97380,
    97384,
    97398,
    97422,
    97436,
    97464,
    97474,
    97476,
    97480,
    97488,
    97502,
    97510,
    97516,
    97550,
    97564,
    97592,
    97648,
    97666,
    97668,
    97672,
    97680,
    97694,
    97696,
    97724,
    97734,
    97740,
    97752,
    97774,
    97830,
    97836,
    97850,
    97862,
    97868,
    97880,
    97902,
    97906,
    97908,
    97926,
    97932,
    97944,
    97968,
    97998,
    98012,
    98018,
    98020,
    98024,
    98038,
    98618,
    98674,
    98676,
    98838,
    98854,
    98874,
    98892,
    98904,
    98926,
    98930,
    98932,
    98968,
    99006,
    99042,
    99044,
    99048,
    99062,
    99166,
    99194,
    99246,
    99286,
    99350,
    99366,
    99372,
    99386,
    99398,
    99416,
    99438,
    99442,
    99444,
    99462,
    99504,
    99518,
    99534,
    99548,
    99554,
    99556,
    99560,
    99574,
    99590,
    99596,
    99608,
    99632,
    99646,
    99680,
    99708,
    99726,
    99740,
    99768,
    99778,
    99780,
    99784,
    99792,
    99806,
    99814,
    99820,
    99834,
    99858,
    99860,
    99874,
    99880,
    99894,
    99906,
    99920,
    99934,
    99962,
    99970,
    99972,
    99976,
    99984,
    99998,
    1e5,
    100028,
    100038,
    100044,
    100056,
    100078,
    100082,
    100084,
    100142,
    100174,
    100188,
    100246,
    100262,
    100268,
    100306,
    100308,
    100390,
    100396,
    100410,
    100422,
    100428,
    100440,
    100462,
    100466,
    100468,
    100486,
    100504,
    100528,
    100542,
    100558,
    100572,
    100578,
    100580,
    100584,
    100598,
    100620,
    100656,
    100670,
    100704,
    100732,
    100750,
    100792,
    100802,
    100808,
    100816,
    100830,
    100838,
    100844,
    100858,
    100888,
    100912,
    100926,
    100960,
    100988,
    101056,
    101112,
    101148,
    101176,
    101232,
    101246,
    101250,
    101252,
    101256,
    101264,
    101278,
    101280,
    101308,
    101318,
    101324,
    101336,
    101358,
    101362,
    101364,
    101410,
    101412,
    101416,
    101430,
    101442,
    101448,
    101456,
    101470,
    101478,
    101498,
    101506,
    101508,
    101520,
    101534,
    101536,
    101564,
    101580,
    101618,
    101620,
    101636,
    101640,
    101648,
    101662,
    101664,
    101692,
    101696,
    101752,
    101766,
    101784,
    101838,
    101858,
    101860,
    101864,
    101934,
    101938,
    101940,
    101966,
    101980,
    101986,
    101988,
    101992,
    102030,
    102044,
    102072,
    102082,
    102084,
    102088,
    102096,
    102138,
    102166,
    102182,
    102188,
    102214,
    102220,
    102232,
    102254,
    102282,
    102290,
    102292,
    102306,
    102308,
    102312,
    102326,
    102444,
    102458,
    102470,
    102476,
    102488,
    102514,
    102516,
    102534,
    102552,
    102576,
    102590,
    102606,
    102620,
    102626,
    102632,
    102646,
    102662,
    102668,
    102704,
    102718,
    102752,
    102780,
    102798,
    102812,
    102840,
    102850,
    102856,
    102864,
    102878,
    102886,
    102892,
    102906,
    102936,
    102974,
    103008,
    103036,
    103104,
    103160,
    103224,
    103280,
    103294,
    103298,
    103300,
    103312,
    103326,
    103328,
    103356,
    103366,
    103372,
    103384,
    103406,
    103410,
    103412,
    103472,
    103486,
    103520,
    103548,
    103616,
    103672,
    103920,
    103992,
    104048,
    104062,
    104160,
    104188,
    104194,
    104196,
    104200,
    104208,
    104224,
    104252,
    104256,
    104312,
    104326,
    104332,
    104344,
    104368,
    104382,
    104398,
    104412,
    104418,
    104420,
    104424,
    104482,
    104484,
    104514,
    104520,
    104528,
    104542,
    104550,
    104570,
    104578,
    104580,
    104592,
    104606,
    104608,
    104636,
    104652,
    104690,
    104692,
    104706,
    104712,
    104734,
    104736,
    104764,
    104768,
    104824,
    104838,
    104856,
    104910,
    104930,
    104932,
    104936,
    104968,
    104976,
    104990,
    104992,
    105020,
    105024,
    105080,
    105200,
    105240,
    105278,
    105312,
    105372,
    105410,
    105412,
    105416,
    105424,
    105446,
    105518,
    105524,
    105550,
    105564,
    105570,
    105572,
    105576,
    105614,
    105628,
    105656,
    105666,
    105672,
    105680,
    105702,
    105722,
    105742,
    105756,
    105784,
    105840,
    105854,
    105858,
    105860,
    105864,
    105872,
    105888,
    105932,
    105970,
    105972,
    106006,
    106022,
    106028,
    106054,
    106060,
    106072,
    106100,
    106118,
    106124,
    106136,
    106160,
    106174,
    106190,
    106210,
    106212,
    106216,
    106250,
    106258,
    106260,
    106274,
    106276,
    106280,
    106306,
    106308,
    106312,
    106320,
    106334,
    106348,
    106394,
    106414,
    106418,
    106420,
    106566,
    106572,
    106610,
    106612,
    106630,
    106636,
    106648,
    106672,
    106686,
    106722,
    106724,
    106728,
    106742,
    106758,
    106764,
    106776,
    106800,
    106814,
    106848,
    106876,
    106894,
    106908,
    106936,
    106946,
    106948,
    106952,
    106960,
    106974,
    106982,
    106988,
    107032,
    107056,
    107070,
    107104,
    107132,
    107200,
    107256,
    107292,
    107320,
    107376,
    107390,
    107394,
    107396,
    107400,
    107408,
    107422,
    107424,
    107452,
    107462,
    107468,
    107480,
    107502,
    107506,
    107508,
    107544,
    107568,
    107582,
    107616,
    107644,
    107712,
    107768,
    108016,
    108060,
    108088,
    108144,
    108158,
    108256,
    108284,
    108290,
    108292,
    108296,
    108304,
    108318,
    108320,
    108348,
    108352,
    108408,
    108422,
    108428,
    108440,
    108464,
    108478,
    108494,
    108508,
    108514,
    108516,
    108520,
    108592,
    108640,
    108668,
    108736,
    108792,
    109040,
    109536,
    109680,
    109694,
    109792,
    109820,
    110016,
    110072,
    110084,
    110088,
    110096,
    110112,
    110140,
    110144,
    110200,
    110320,
    110342,
    110348,
    110360,
    110384,
    110398,
    110432,
    110460,
    110478,
    110492,
    110520,
    110532,
    110536,
    110544,
    110558,
    110658,
    110686,
    110714,
    110722,
    110724,
    110728,
    110736,
    110750,
    110752,
    110780,
    110796,
    110834,
    110836,
    110850,
    110852,
    110856,
    110864,
    110878,
    110880,
    110908,
    110912,
    110968,
    110982,
    111e3,
    111054,
    111074,
    111076,
    111080,
    111108,
    111112,
    111120,
    111134,
    111136,
    111164,
    111168,
    111224,
    111344,
    111372,
    111422,
    111456,
    111516,
    111554,
    111556,
    111560,
    111568,
    111590,
    111632,
    111646,
    111648,
    111676,
    111680,
    111736,
    111856,
    112096,
    112152,
    112224,
    112252,
    112320,
    112440,
    112514,
    112516,
    112520,
    112528,
    112542,
    112544,
    112588,
    112686,
    112718,
    112732,
    112782,
    112796,
    112824,
    112834,
    112836,
    112840,
    112848,
    112870,
    112890,
    112910,
    112924,
    112952,
    113008,
    113022,
    113026,
    113028,
    113032,
    113040,
    113054,
    113056,
    113100,
    113138,
    113140,
    113166,
    113180,
    113208,
    113264,
    113278,
    113376,
    113404,
    113416,
    113424,
    113440,
    113468,
    113472,
    113560,
    113614,
    113634,
    113636,
    113640,
    113686,
    113702,
    113708,
    113734,
    113740,
    113752,
    113778,
    113780,
    113798,
    113804,
    113816,
    113840,
    113854,
    113870,
    113890,
    113892,
    113896,
    113926,
    113932,
    113944,
    113968,
    113982,
    114016,
    114044,
    114076,
    114114,
    114116,
    114120,
    114128,
    114150,
    114170,
    114194,
    114196,
    114210,
    114212,
    114216,
    114242,
    114244,
    114248,
    114256,
    114270,
    114278,
    114306,
    114308,
    114312,
    114320,
    114334,
    114336,
    114364,
    114380,
    114420,
    114458,
    114478,
    114482,
    114484,
    114510,
    114524,
    114530,
    114532,
    114536,
    114842,
    114866,
    114868,
    114970,
    114994,
    114996,
    115042,
    115044,
    115048,
    115062,
    115130,
    115226,
    115250,
    115252,
    115278,
    115292,
    115298,
    115300,
    115304,
    115318,
    115342,
    115394,
    115396,
    115400,
    115408,
    115422,
    115430,
    115436,
    115450,
    115478,
    115494,
    115514,
    115526,
    115532,
    115570,
    115572,
    115738,
    115758,
    115762,
    115764,
    115790,
    115804,
    115810,
    115812,
    115816,
    115830,
    115854,
    115868,
    115896,
    115906,
    115912,
    115920,
    115934,
    115942,
    115948,
    115962,
    115996,
    116024,
    116080,
    116094,
    116098,
    116100,
    116104,
    116112,
    116126,
    116128,
    116156,
    116166,
    116172,
    116184,
    116206,
    116210,
    116212,
    116246,
    116262,
    116268,
    116282,
    116294,
    116300,
    116312,
    116334,
    116338,
    116340,
    116358,
    116364,
    116376,
    116400,
    116414,
    116430,
    116444,
    116450,
    116452,
    116456,
    116498,
    116500,
    116514,
    116520,
    116534,
    116546,
    116548,
    116552,
    116560,
    116574,
    116582,
    116588,
    116602,
    116654,
    116694,
    116714,
    116762,
    116782,
    116786,
    116788,
    116814,
    116828,
    116834,
    116836,
    116840,
    116854,
    116878,
    116892,
    116920,
    116930,
    116936,
    116944,
    116958,
    116966,
    116972,
    116986,
    117006,
    117048,
    117104,
    117118,
    117122,
    117124,
    117136,
    117150,
    117152,
    117180,
    117190,
    117196,
    117208,
    117230,
    117234,
    117236,
    117304,
    117360,
    117374,
    117472,
    117500,
    117506,
    117508,
    117512,
    117520,
    117536,
    117564,
    117568,
    117624,
    117638,
    117644,
    117656,
    117680,
    117694,
    117710,
    117724,
    117730,
    117732,
    117736,
    117750,
    117782,
    117798,
    117804,
    117818,
    117830,
    117848,
    117874,
    117876,
    117894,
    117936,
    117950,
    117966,
    117986,
    117988,
    117992,
    118022,
    118028,
    118040,
    118064,
    118078,
    118112,
    118140,
    118172,
    118210,
    118212,
    118216,
    118224,
    118238,
    118246,
    118266,
    118306,
    118312,
    118338,
    118352,
    118366,
    118374,
    118394,
    118402,
    118404,
    118408,
    118416,
    118430,
    118432,
    118460,
    118476,
    118514,
    118516,
    118574,
    118578,
    118580,
    118606,
    118620,
    118626,
    118628,
    118632,
    118678,
    118694,
    118700,
    118730,
    118738,
    118740,
    118830,
    118834,
    118836,
    118862,
    118876,
    118882,
    118884,
    118888,
    118902,
    118926,
    118940,
    118968,
    118978,
    118980,
    118984,
    118992,
    119006,
    119014,
    119020,
    119034,
    119068,
    119096,
    119152,
    119166,
    119170,
    119172,
    119176,
    119184,
    119198,
    119200,
    119228,
    119238,
    119244,
    119256,
    119278,
    119282,
    119284,
    119324,
    119352,
    119408,
    119422,
    119520,
    119548,
    119554,
    119556,
    119560,
    119568,
    119582,
    119584,
    119612,
    119616,
    119672,
    119686,
    119692,
    119704,
    119728,
    119742,
    119758,
    119772,
    119778,
    119780,
    119784,
    119798,
    119920,
    119934,
    120032,
    120060,
    120256,
    120312,
    120324,
    120328,
    120336,
    120352,
    120384,
    120440,
    120560,
    120582,
    120588,
    120600,
    120624,
    120638,
    120672,
    120700,
    120718,
    120732,
    120760,
    120770,
    120772,
    120776,
    120784,
    120798,
    120806,
    120812,
    120870,
    120876,
    120890,
    120902,
    120908,
    120920,
    120946,
    120948,
    120966,
    120972,
    120984,
    121008,
    121022,
    121038,
    121058,
    121060,
    121064,
    121078,
    121100,
    121112,
    121136,
    121150,
    121184,
    121212,
    121244,
    121282,
    121284,
    121288,
    121296,
    121318,
    121338,
    121356,
    121368,
    121392,
    121406,
    121440,
    121468,
    121536,
    121592,
    121656,
    121730,
    121732,
    121736,
    121744,
    121758,
    121760,
    121804,
    121842,
    121844,
    121890,
    121922,
    121924,
    121928,
    121936,
    121950,
    121958,
    121978,
    121986,
    121988,
    121992,
    122e3,
    122014,
    122016,
    122044,
    122060,
    122098,
    122100,
    122116,
    122120,
    122128,
    122142,
    122144,
    122172,
    122176,
    122232,
    122246,
    122264,
    122318,
    122338,
    122340,
    122344,
    122414,
    122418,
    122420,
    122446,
    122460,
    122466,
    122468,
    122472,
    122510,
    122524,
    122552,
    122562,
    122564,
    122568,
    122576,
    122598,
    122618,
    122646,
    122662,
    122668,
    122694,
    122700,
    122712,
    122738,
    122740,
    122762,
    122770,
    122772,
    122786,
    122788,
    122792,
    123018,
    123026,
    123028,
    123042,
    123044,
    123048,
    123062,
    123098,
    123146,
    123154,
    123156,
    123170,
    123172,
    123176,
    123190,
    123202,
    123204,
    123208,
    123216,
    123238,
    123244,
    123258,
    123290,
    123314,
    123316,
    123402,
    123410,
    123412,
    123426,
    123428,
    123432,
    123446,
    123458,
    123464,
    123472,
    123486,
    123494,
    123500,
    123514,
    123522,
    123524,
    123528,
    123536,
    123552,
    123580,
    123590,
    123596,
    123608,
    123630,
    123634,
    123636,
    123674,
    123698,
    123700,
    123740,
    123746,
    123748,
    123752,
    123834,
    123914,
    123922,
    123924,
    123938,
    123944,
    123958,
    123970,
    123976,
    123984,
    123998,
    124006,
    124012,
    124026,
    124034,
    124036,
    124048,
    124062,
    124064,
    124092,
    124102,
    124108,
    124120,
    124142,
    124146,
    124148,
    124162,
    124164,
    124168,
    124176,
    124190,
    124192,
    124220,
    124224,
    124280,
    124294,
    124300,
    124312,
    124336,
    124350,
    124366,
    124380,
    124386,
    124388,
    124392,
    124406,
    124442,
    124462,
    124466,
    124468,
    124494,
    124508,
    124514,
    124520,
    124558,
    124572,
    124600,
    124610,
    124612,
    124616,
    124624,
    124646,
    124666,
    124694,
    124710,
    124716,
    124730,
    124742,
    124748,
    124760,
    124786,
    124788,
    124818,
    124820,
    124834,
    124836,
    124840,
    124854,
    124946,
    124948,
    124962,
    124964,
    124968,
    124982,
    124994,
    124996,
    125e3,
    125008,
    125022,
    125030,
    125036,
    125050,
    125058,
    125060,
    125064,
    125072,
    125086,
    125088,
    125116,
    125126,
    125132,
    125144,
    125166,
    125170,
    125172,
    125186,
    125188,
    125192,
    125200,
    125216,
    125244,
    125248,
    125304,
    125318,
    125324,
    125336,
    125360,
    125374,
    125390,
    125404,
    125410,
    125412,
    125416,
    125430,
    125444,
    125448,
    125456,
    125472,
    125504,
    125560,
    125680,
    125702,
    125708,
    125720,
    125744,
    125758,
    125792,
    125820,
    125838,
    125852,
    125880,
    125890,
    125892,
    125896,
    125904,
    125918,
    125926,
    125932,
    125978,
    125998,
    126002,
    126004,
    126030,
    126044,
    126050,
    126052,
    126056,
    126094,
    126108,
    126136,
    126146,
    126148,
    126152,
    126160,
    126182,
    126202,
    126222,
    126236,
    126264,
    126320,
    126334,
    126338,
    126340,
    126344,
    126352,
    126366,
    126368,
    126412,
    126450,
    126452,
    126486,
    126502,
    126508,
    126522,
    126534,
    126540,
    126552,
    126574,
    126578,
    126580,
    126598,
    126604,
    126616,
    126640,
    126654,
    126670,
    126684,
    126690,
    126692,
    126696,
    126738,
    126754,
    126756,
    126760,
    126774,
    126786,
    126788,
    126792,
    126800,
    126814,
    126822,
    126828,
    126842,
    126894,
    126898,
    126900,
    126934,
    127126,
    127142,
    127148,
    127162,
    127178,
    127186,
    127188,
    127254,
    127270,
    127276,
    127290,
    127302,
    127308,
    127320,
    127342,
    127346,
    127348,
    127370,
    127378,
    127380,
    127394,
    127396,
    127400,
    127450,
    127510,
    127526,
    127532,
    127546,
    127558,
    127576,
    127598,
    127602,
    127604,
    127622,
    127628,
    127640,
    127664,
    127678,
    127694,
    127708,
    127714,
    127716,
    127720,
    127734,
    127754,
    127762,
    127764,
    127778,
    127784,
    127810,
    127812,
    127816,
    127824,
    127838,
    127846,
    127866,
    127898,
    127918,
    127922,
    127924,
    128022,
    128038,
    128044,
    128058,
    128070,
    128076,
    128088,
    128110,
    128114,
    128116,
    128134,
    128140,
    128152,
    128176,
    128190,
    128206,
    128220,
    128226,
    128228,
    128232,
    128246,
    128262,
    128268,
    128280,
    128304,
    128318,
    128352,
    128380,
    128398,
    128412,
    128440,
    128450,
    128452,
    128456,
    128464,
    128478,
    128486,
    128492,
    128506,
    128522,
    128530,
    128532,
    128546,
    128548,
    128552,
    128566,
    128578,
    128580,
    128584,
    128592,
    128606,
    128614,
    128634,
    128642,
    128644,
    128648,
    128656,
    128670,
    128672,
    128700,
    128716,
    128754,
    128756,
    128794,
    128814,
    128818,
    128820,
    128846,
    128860,
    128866,
    128868,
    128872,
    128886,
    128918,
    128934,
    128940,
    128954,
    128978,
    128980,
    129178,
    129198,
    129202,
    129204,
    129238,
    129258,
    129306,
    129326,
    129330,
    129332,
    129358,
    129372,
    129378,
    129380,
    129384,
    129398,
    129430,
    129446,
    129452,
    129466,
    129482,
    129490,
    129492,
    129562,
    129582,
    129586,
    129588,
    129614,
    129628,
    129634,
    129636,
    129640,
    129654,
    129678,
    129692,
    129720,
    129730,
    129732,
    129736,
    129744,
    129758,
    129766,
    129772,
    129814,
    129830,
    129836,
    129850,
    129862,
    129868,
    129880,
    129902,
    129906,
    129908,
    129930,
    129938,
    129940,
    129954,
    129956,
    129960,
    129974,
    130010
  ]);
  PDF417Common2.CODEWORD_TABLE = Int32Array.from([
    2627,
    1819,
    2622,
    2621,
    1813,
    1812,
    2729,
    2724,
    2723,
    2779,
    2774,
    2773,
    902,
    896,
    908,
    868,
    865,
    861,
    859,
    2511,
    873,
    871,
    1780,
    835,
    2493,
    825,
    2491,
    842,
    837,
    844,
    1764,
    1762,
    811,
    810,
    809,
    2483,
    807,
    2482,
    806,
    2480,
    815,
    814,
    813,
    812,
    2484,
    817,
    816,
    1745,
    1744,
    1742,
    1746,
    2655,
    2637,
    2635,
    2626,
    2625,
    2623,
    2628,
    1820,
    2752,
    2739,
    2737,
    2728,
    2727,
    2725,
    2730,
    2785,
    2783,
    2778,
    2777,
    2775,
    2780,
    787,
    781,
    747,
    739,
    736,
    2413,
    754,
    752,
    1719,
    692,
    689,
    681,
    2371,
    678,
    2369,
    700,
    697,
    694,
    703,
    1688,
    1686,
    642,
    638,
    2343,
    631,
    2341,
    627,
    2338,
    651,
    646,
    643,
    2345,
    654,
    652,
    1652,
    1650,
    1647,
    1654,
    601,
    599,
    2322,
    596,
    2321,
    594,
    2319,
    2317,
    611,
    610,
    608,
    606,
    2324,
    603,
    2323,
    615,
    614,
    612,
    1617,
    1616,
    1614,
    1612,
    616,
    1619,
    1618,
    2575,
    2538,
    2536,
    905,
    901,
    898,
    909,
    2509,
    2507,
    2504,
    870,
    867,
    864,
    860,
    2512,
    875,
    872,
    1781,
    2490,
    2489,
    2487,
    2485,
    1748,
    836,
    834,
    832,
    830,
    2494,
    827,
    2492,
    843,
    841,
    839,
    845,
    1765,
    1763,
    2701,
    2676,
    2674,
    2653,
    2648,
    2656,
    2634,
    2633,
    2631,
    2629,
    1821,
    2638,
    2636,
    2770,
    2763,
    2761,
    2750,
    2745,
    2753,
    2736,
    2735,
    2733,
    2731,
    1848,
    2740,
    2738,
    2786,
    2784,
    591,
    588,
    576,
    569,
    566,
    2296,
    1590,
    537,
    534,
    526,
    2276,
    522,
    2274,
    545,
    542,
    539,
    548,
    1572,
    1570,
    481,
    2245,
    466,
    2242,
    462,
    2239,
    492,
    485,
    482,
    2249,
    496,
    494,
    1534,
    1531,
    1528,
    1538,
    413,
    2196,
    406,
    2191,
    2188,
    425,
    419,
    2202,
    415,
    2199,
    432,
    430,
    427,
    1472,
    1467,
    1464,
    433,
    1476,
    1474,
    368,
    367,
    2160,
    365,
    2159,
    362,
    2157,
    2155,
    2152,
    378,
    377,
    375,
    2166,
    372,
    2165,
    369,
    2162,
    383,
    381,
    379,
    2168,
    1419,
    1418,
    1416,
    1414,
    385,
    1411,
    384,
    1423,
    1422,
    1420,
    1424,
    2461,
    802,
    2441,
    2439,
    790,
    786,
    783,
    794,
    2409,
    2406,
    2403,
    750,
    742,
    738,
    2414,
    756,
    753,
    1720,
    2367,
    2365,
    2362,
    2359,
    1663,
    693,
    691,
    684,
    2373,
    680,
    2370,
    702,
    699,
    696,
    704,
    1690,
    1687,
    2337,
    2336,
    2334,
    2332,
    1624,
    2329,
    1622,
    640,
    637,
    2344,
    634,
    2342,
    630,
    2340,
    650,
    648,
    645,
    2346,
    655,
    653,
    1653,
    1651,
    1649,
    1655,
    2612,
    2597,
    2595,
    2571,
    2568,
    2565,
    2576,
    2534,
    2529,
    2526,
    1787,
    2540,
    2537,
    907,
    904,
    900,
    910,
    2503,
    2502,
    2500,
    2498,
    1768,
    2495,
    1767,
    2510,
    2508,
    2506,
    869,
    866,
    863,
    2513,
    876,
    874,
    1782,
    2720,
    2713,
    2711,
    2697,
    2694,
    2691,
    2702,
    2672,
    2670,
    2664,
    1828,
    2678,
    2675,
    2647,
    2646,
    2644,
    2642,
    1823,
    2639,
    1822,
    2654,
    2652,
    2650,
    2657,
    2771,
    1855,
    2765,
    2762,
    1850,
    1849,
    2751,
    2749,
    2747,
    2754,
    353,
    2148,
    344,
    342,
    336,
    2142,
    332,
    2140,
    345,
    1375,
    1373,
    306,
    2130,
    299,
    2128,
    295,
    2125,
    319,
    314,
    311,
    2132,
    1354,
    1352,
    1349,
    1356,
    262,
    257,
    2101,
    253,
    2096,
    2093,
    274,
    273,
    267,
    2107,
    263,
    2104,
    280,
    278,
    275,
    1316,
    1311,
    1308,
    1320,
    1318,
    2052,
    202,
    2050,
    2044,
    2040,
    219,
    2063,
    212,
    2060,
    208,
    2055,
    224,
    221,
    2066,
    1260,
    1258,
    1252,
    231,
    1248,
    229,
    1266,
    1264,
    1261,
    1268,
    155,
    1998,
    153,
    1996,
    1994,
    1991,
    1988,
    165,
    164,
    2007,
    162,
    2006,
    159,
    2003,
    2e3,
    172,
    171,
    169,
    2012,
    166,
    2010,
    1186,
    1184,
    1182,
    1179,
    175,
    1176,
    173,
    1192,
    1191,
    1189,
    1187,
    176,
    1194,
    1193,
    2313,
    2307,
    2305,
    592,
    589,
    2294,
    2292,
    2289,
    578,
    572,
    568,
    2297,
    580,
    1591,
    2272,
    2267,
    2264,
    1547,
    538,
    536,
    529,
    2278,
    525,
    2275,
    547,
    544,
    541,
    1574,
    1571,
    2237,
    2235,
    2229,
    1493,
    2225,
    1489,
    478,
    2247,
    470,
    2244,
    465,
    2241,
    493,
    488,
    484,
    2250,
    498,
    495,
    1536,
    1533,
    1530,
    1539,
    2187,
    2186,
    2184,
    2182,
    1432,
    2179,
    1430,
    2176,
    1427,
    414,
    412,
    2197,
    409,
    2195,
    405,
    2193,
    2190,
    426,
    424,
    421,
    2203,
    418,
    2201,
    431,
    429,
    1473,
    1471,
    1469,
    1466,
    434,
    1477,
    1475,
    2478,
    2472,
    2470,
    2459,
    2457,
    2454,
    2462,
    803,
    2437,
    2432,
    2429,
    1726,
    2443,
    2440,
    792,
    789,
    785,
    2401,
    2399,
    2393,
    1702,
    2389,
    1699,
    2411,
    2408,
    2405,
    745,
    741,
    2415,
    758,
    755,
    1721,
    2358,
    2357,
    2355,
    2353,
    1661,
    2350,
    1660,
    2347,
    1657,
    2368,
    2366,
    2364,
    2361,
    1666,
    690,
    687,
    2374,
    683,
    2372,
    701,
    698,
    705,
    1691,
    1689,
    2619,
    2617,
    2610,
    2608,
    2605,
    2613,
    2593,
    2588,
    2585,
    1803,
    2599,
    2596,
    2563,
    2561,
    2555,
    1797,
    2551,
    1795,
    2573,
    2570,
    2567,
    2577,
    2525,
    2524,
    2522,
    2520,
    1786,
    2517,
    1785,
    2514,
    1783,
    2535,
    2533,
    2531,
    2528,
    1788,
    2541,
    2539,
    906,
    903,
    911,
    2721,
    1844,
    2715,
    2712,
    1838,
    1836,
    2699,
    2696,
    2693,
    2703,
    1827,
    1826,
    1824,
    2673,
    2671,
    2669,
    2666,
    1829,
    2679,
    2677,
    1858,
    1857,
    2772,
    1854,
    1853,
    1851,
    1856,
    2766,
    2764,
    143,
    1987,
    139,
    1986,
    135,
    133,
    131,
    1984,
    128,
    1983,
    125,
    1981,
    138,
    137,
    136,
    1985,
    1133,
    1132,
    1130,
    112,
    110,
    1974,
    107,
    1973,
    104,
    1971,
    1969,
    122,
    121,
    119,
    117,
    1977,
    114,
    1976,
    124,
    1115,
    1114,
    1112,
    1110,
    1117,
    1116,
    84,
    83,
    1953,
    81,
    1952,
    78,
    1950,
    1948,
    1945,
    94,
    93,
    91,
    1959,
    88,
    1958,
    85,
    1955,
    99,
    97,
    95,
    1961,
    1086,
    1085,
    1083,
    1081,
    1078,
    100,
    1090,
    1089,
    1087,
    1091,
    49,
    47,
    1917,
    44,
    1915,
    1913,
    1910,
    1907,
    59,
    1926,
    56,
    1925,
    53,
    1922,
    1919,
    66,
    64,
    1931,
    61,
    1929,
    1042,
    1040,
    1038,
    71,
    1035,
    70,
    1032,
    68,
    1048,
    1047,
    1045,
    1043,
    1050,
    1049,
    12,
    10,
    1869,
    1867,
    1864,
    1861,
    21,
    1880,
    19,
    1877,
    1874,
    1871,
    28,
    1888,
    25,
    1886,
    22,
    1883,
    982,
    980,
    977,
    974,
    32,
    30,
    991,
    989,
    987,
    984,
    34,
    995,
    994,
    992,
    2151,
    2150,
    2147,
    2146,
    2144,
    356,
    355,
    354,
    2149,
    2139,
    2138,
    2136,
    2134,
    1359,
    343,
    341,
    338,
    2143,
    335,
    2141,
    348,
    347,
    346,
    1376,
    1374,
    2124,
    2123,
    2121,
    2119,
    1326,
    2116,
    1324,
    310,
    308,
    305,
    2131,
    302,
    2129,
    298,
    2127,
    320,
    318,
    316,
    313,
    2133,
    322,
    321,
    1355,
    1353,
    1351,
    1357,
    2092,
    2091,
    2089,
    2087,
    1276,
    2084,
    1274,
    2081,
    1271,
    259,
    2102,
    256,
    2100,
    252,
    2098,
    2095,
    272,
    269,
    2108,
    266,
    2106,
    281,
    279,
    277,
    1317,
    1315,
    1313,
    1310,
    282,
    1321,
    1319,
    2039,
    2037,
    2035,
    2032,
    1203,
    2029,
    1200,
    1197,
    207,
    2053,
    205,
    2051,
    201,
    2049,
    2046,
    2043,
    220,
    218,
    2064,
    215,
    2062,
    211,
    2059,
    228,
    226,
    223,
    2069,
    1259,
    1257,
    1254,
    232,
    1251,
    230,
    1267,
    1265,
    1263,
    2316,
    2315,
    2312,
    2311,
    2309,
    2314,
    2304,
    2303,
    2301,
    2299,
    1593,
    2308,
    2306,
    590,
    2288,
    2287,
    2285,
    2283,
    1578,
    2280,
    1577,
    2295,
    2293,
    2291,
    579,
    577,
    574,
    571,
    2298,
    582,
    581,
    1592,
    2263,
    2262,
    2260,
    2258,
    1545,
    2255,
    1544,
    2252,
    1541,
    2273,
    2271,
    2269,
    2266,
    1550,
    535,
    532,
    2279,
    528,
    2277,
    546,
    543,
    549,
    1575,
    1573,
    2224,
    2222,
    2220,
    1486,
    2217,
    1485,
    2214,
    1482,
    1479,
    2238,
    2236,
    2234,
    2231,
    1496,
    2228,
    1492,
    480,
    477,
    2248,
    473,
    2246,
    469,
    2243,
    490,
    487,
    2251,
    497,
    1537,
    1535,
    1532,
    2477,
    2476,
    2474,
    2479,
    2469,
    2468,
    2466,
    2464,
    1730,
    2473,
    2471,
    2453,
    2452,
    2450,
    2448,
    1729,
    2445,
    1728,
    2460,
    2458,
    2456,
    2463,
    805,
    804,
    2428,
    2427,
    2425,
    2423,
    1725,
    2420,
    1724,
    2417,
    1722,
    2438,
    2436,
    2434,
    2431,
    1727,
    2444,
    2442,
    793,
    791,
    788,
    795,
    2388,
    2386,
    2384,
    1697,
    2381,
    1696,
    2378,
    1694,
    1692,
    2402,
    2400,
    2398,
    2395,
    1703,
    2392,
    1701,
    2412,
    2410,
    2407,
    751,
    748,
    744,
    2416,
    759,
    757,
    1807,
    2620,
    2618,
    1806,
    1805,
    2611,
    2609,
    2607,
    2614,
    1802,
    1801,
    1799,
    2594,
    2592,
    2590,
    2587,
    1804,
    2600,
    2598,
    1794,
    1793,
    1791,
    1789,
    2564,
    2562,
    2560,
    2557,
    1798,
    2554,
    1796,
    2574,
    2572,
    2569,
    2578,
    1847,
    1846,
    2722,
    1843,
    1842,
    1840,
    1845,
    2716,
    2714,
    1835,
    1834,
    1832,
    1830,
    1839,
    1837,
    2700,
    2698,
    2695,
    2704,
    1817,
    1811,
    1810,
    897,
    862,
    1777,
    829,
    826,
    838,
    1760,
    1758,
    808,
    2481,
    1741,
    1740,
    1738,
    1743,
    2624,
    1818,
    2726,
    2776,
    782,
    740,
    737,
    1715,
    686,
    679,
    695,
    1682,
    1680,
    639,
    628,
    2339,
    647,
    644,
    1645,
    1643,
    1640,
    1648,
    602,
    600,
    597,
    595,
    2320,
    593,
    2318,
    609,
    607,
    604,
    1611,
    1610,
    1608,
    1606,
    613,
    1615,
    1613,
    2328,
    926,
    924,
    892,
    886,
    899,
    857,
    850,
    2505,
    1778,
    824,
    823,
    821,
    819,
    2488,
    818,
    2486,
    833,
    831,
    828,
    840,
    1761,
    1759,
    2649,
    2632,
    2630,
    2746,
    2734,
    2732,
    2782,
    2781,
    570,
    567,
    1587,
    531,
    527,
    523,
    540,
    1566,
    1564,
    476,
    467,
    463,
    2240,
    486,
    483,
    1524,
    1521,
    1518,
    1529,
    411,
    403,
    2192,
    399,
    2189,
    423,
    416,
    1462,
    1457,
    1454,
    428,
    1468,
    1465,
    2210,
    366,
    363,
    2158,
    360,
    2156,
    357,
    2153,
    376,
    373,
    370,
    2163,
    1410,
    1409,
    1407,
    1405,
    382,
    1402,
    380,
    1417,
    1415,
    1412,
    1421,
    2175,
    2174,
    777,
    774,
    771,
    784,
    732,
    725,
    722,
    2404,
    743,
    1716,
    676,
    674,
    668,
    2363,
    665,
    2360,
    685,
    1684,
    1681,
    626,
    624,
    622,
    2335,
    620,
    2333,
    617,
    2330,
    641,
    635,
    649,
    1646,
    1644,
    1642,
    2566,
    928,
    925,
    2530,
    2527,
    894,
    891,
    888,
    2501,
    2499,
    2496,
    858,
    856,
    854,
    851,
    1779,
    2692,
    2668,
    2665,
    2645,
    2643,
    2640,
    2651,
    2768,
    2759,
    2757,
    2744,
    2743,
    2741,
    2748,
    352,
    1382,
    340,
    337,
    333,
    1371,
    1369,
    307,
    300,
    296,
    2126,
    315,
    312,
    1347,
    1342,
    1350,
    261,
    258,
    250,
    2097,
    246,
    2094,
    271,
    268,
    264,
    1306,
    1301,
    1298,
    276,
    1312,
    1309,
    2115,
    203,
    2048,
    195,
    2045,
    191,
    2041,
    213,
    209,
    2056,
    1246,
    1244,
    1238,
    225,
    1234,
    222,
    1256,
    1253,
    1249,
    1262,
    2080,
    2079,
    154,
    1997,
    150,
    1995,
    147,
    1992,
    1989,
    163,
    160,
    2004,
    156,
    2001,
    1175,
    1174,
    1172,
    1170,
    1167,
    170,
    1164,
    167,
    1185,
    1183,
    1180,
    1177,
    174,
    1190,
    1188,
    2025,
    2024,
    2022,
    587,
    586,
    564,
    559,
    556,
    2290,
    573,
    1588,
    520,
    518,
    512,
    2268,
    508,
    2265,
    530,
    1568,
    1565,
    461,
    457,
    2233,
    450,
    2230,
    446,
    2226,
    479,
    471,
    489,
    1526,
    1523,
    1520,
    397,
    395,
    2185,
    392,
    2183,
    389,
    2180,
    2177,
    410,
    2194,
    402,
    422,
    1463,
    1461,
    1459,
    1456,
    1470,
    2455,
    799,
    2433,
    2430,
    779,
    776,
    773,
    2397,
    2394,
    2390,
    734,
    728,
    724,
    746,
    1717,
    2356,
    2354,
    2351,
    2348,
    1658,
    677,
    675,
    673,
    670,
    667,
    688,
    1685,
    1683,
    2606,
    2589,
    2586,
    2559,
    2556,
    2552,
    927,
    2523,
    2521,
    2518,
    2515,
    1784,
    2532,
    895,
    893,
    890,
    2718,
    2709,
    2707,
    2689,
    2687,
    2684,
    2663,
    2662,
    2660,
    2658,
    1825,
    2667,
    2769,
    1852,
    2760,
    2758,
    142,
    141,
    1139,
    1138,
    134,
    132,
    129,
    126,
    1982,
    1129,
    1128,
    1126,
    1131,
    113,
    111,
    108,
    105,
    1972,
    101,
    1970,
    120,
    118,
    115,
    1109,
    1108,
    1106,
    1104,
    123,
    1113,
    1111,
    82,
    79,
    1951,
    75,
    1949,
    72,
    1946,
    92,
    89,
    86,
    1956,
    1077,
    1076,
    1074,
    1072,
    98,
    1069,
    96,
    1084,
    1082,
    1079,
    1088,
    1968,
    1967,
    48,
    45,
    1916,
    42,
    1914,
    39,
    1911,
    1908,
    60,
    57,
    54,
    1923,
    50,
    1920,
    1031,
    1030,
    1028,
    1026,
    67,
    1023,
    65,
    1020,
    62,
    1041,
    1039,
    1036,
    1033,
    69,
    1046,
    1044,
    1944,
    1943,
    1941,
    11,
    9,
    1868,
    7,
    1865,
    1862,
    1859,
    20,
    1878,
    16,
    1875,
    13,
    1872,
    970,
    968,
    966,
    963,
    29,
    960,
    26,
    23,
    983,
    981,
    978,
    975,
    33,
    971,
    31,
    990,
    988,
    985,
    1906,
    1904,
    1902,
    993,
    351,
    2145,
    1383,
    331,
    330,
    328,
    326,
    2137,
    323,
    2135,
    339,
    1372,
    1370,
    294,
    293,
    291,
    289,
    2122,
    286,
    2120,
    283,
    2117,
    309,
    303,
    317,
    1348,
    1346,
    1344,
    245,
    244,
    242,
    2090,
    239,
    2088,
    236,
    2085,
    2082,
    260,
    2099,
    249,
    270,
    1307,
    1305,
    1303,
    1300,
    1314,
    189,
    2038,
    186,
    2036,
    183,
    2033,
    2030,
    2026,
    206,
    198,
    2047,
    194,
    216,
    1247,
    1245,
    1243,
    1240,
    227,
    1237,
    1255,
    2310,
    2302,
    2300,
    2286,
    2284,
    2281,
    565,
    563,
    561,
    558,
    575,
    1589,
    2261,
    2259,
    2256,
    2253,
    1542,
    521,
    519,
    517,
    514,
    2270,
    511,
    533,
    1569,
    1567,
    2223,
    2221,
    2218,
    2215,
    1483,
    2211,
    1480,
    459,
    456,
    453,
    2232,
    449,
    474,
    491,
    1527,
    1525,
    1522,
    2475,
    2467,
    2465,
    2451,
    2449,
    2446,
    801,
    800,
    2426,
    2424,
    2421,
    2418,
    1723,
    2435,
    780,
    778,
    775,
    2387,
    2385,
    2382,
    2379,
    1695,
    2375,
    1693,
    2396,
    735,
    733,
    730,
    727,
    749,
    1718,
    2616,
    2615,
    2604,
    2603,
    2601,
    2584,
    2583,
    2581,
    2579,
    1800,
    2591,
    2550,
    2549,
    2547,
    2545,
    1792,
    2542,
    1790,
    2558,
    929,
    2719,
    1841,
    2710,
    2708,
    1833,
    1831,
    2690,
    2688,
    2686,
    1815,
    1809,
    1808,
    1774,
    1756,
    1754,
    1737,
    1736,
    1734,
    1739,
    1816,
    1711,
    1676,
    1674,
    633,
    629,
    1638,
    1636,
    1633,
    1641,
    598,
    1605,
    1604,
    1602,
    1600,
    605,
    1609,
    1607,
    2327,
    887,
    853,
    1775,
    822,
    820,
    1757,
    1755,
    1584,
    524,
    1560,
    1558,
    468,
    464,
    1514,
    1511,
    1508,
    1519,
    408,
    404,
    400,
    1452,
    1447,
    1444,
    417,
    1458,
    1455,
    2208,
    364,
    361,
    358,
    2154,
    1401,
    1400,
    1398,
    1396,
    374,
    1393,
    371,
    1408,
    1406,
    1403,
    1413,
    2173,
    2172,
    772,
    726,
    723,
    1712,
    672,
    669,
    666,
    682,
    1678,
    1675,
    625,
    623,
    621,
    618,
    2331,
    636,
    632,
    1639,
    1637,
    1635,
    920,
    918,
    884,
    880,
    889,
    849,
    848,
    847,
    846,
    2497,
    855,
    852,
    1776,
    2641,
    2742,
    2787,
    1380,
    334,
    1367,
    1365,
    301,
    297,
    1340,
    1338,
    1335,
    1343,
    255,
    251,
    247,
    1296,
    1291,
    1288,
    265,
    1302,
    1299,
    2113,
    204,
    196,
    192,
    2042,
    1232,
    1230,
    1224,
    214,
    1220,
    210,
    1242,
    1239,
    1235,
    1250,
    2077,
    2075,
    151,
    148,
    1993,
    144,
    1990,
    1163,
    1162,
    1160,
    1158,
    1155,
    161,
    1152,
    157,
    1173,
    1171,
    1168,
    1165,
    168,
    1181,
    1178,
    2021,
    2020,
    2018,
    2023,
    585,
    560,
    557,
    1585,
    516,
    509,
    1562,
    1559,
    458,
    447,
    2227,
    472,
    1516,
    1513,
    1510,
    398,
    396,
    393,
    390,
    2181,
    386,
    2178,
    407,
    1453,
    1451,
    1449,
    1446,
    420,
    1460,
    2209,
    769,
    764,
    720,
    712,
    2391,
    729,
    1713,
    664,
    663,
    661,
    659,
    2352,
    656,
    2349,
    671,
    1679,
    1677,
    2553,
    922,
    919,
    2519,
    2516,
    885,
    883,
    881,
    2685,
    2661,
    2659,
    2767,
    2756,
    2755,
    140,
    1137,
    1136,
    130,
    127,
    1125,
    1124,
    1122,
    1127,
    109,
    106,
    102,
    1103,
    1102,
    1100,
    1098,
    116,
    1107,
    1105,
    1980,
    80,
    76,
    73,
    1947,
    1068,
    1067,
    1065,
    1063,
    90,
    1060,
    87,
    1075,
    1073,
    1070,
    1080,
    1966,
    1965,
    46,
    43,
    40,
    1912,
    36,
    1909,
    1019,
    1018,
    1016,
    1014,
    58,
    1011,
    55,
    1008,
    51,
    1029,
    1027,
    1024,
    1021,
    63,
    1037,
    1034,
    1940,
    1939,
    1937,
    1942,
    8,
    1866,
    4,
    1863,
    1,
    1860,
    956,
    954,
    952,
    949,
    946,
    17,
    14,
    969,
    967,
    964,
    961,
    27,
    957,
    24,
    979,
    976,
    972,
    1901,
    1900,
    1898,
    1896,
    986,
    1905,
    1903,
    350,
    349,
    1381,
    329,
    327,
    324,
    1368,
    1366,
    292,
    290,
    287,
    284,
    2118,
    304,
    1341,
    1339,
    1337,
    1345,
    243,
    240,
    237,
    2086,
    233,
    2083,
    254,
    1297,
    1295,
    1293,
    1290,
    1304,
    2114,
    190,
    187,
    184,
    2034,
    180,
    2031,
    177,
    2027,
    199,
    1233,
    1231,
    1229,
    1226,
    217,
    1223,
    1241,
    2078,
    2076,
    584,
    555,
    554,
    552,
    550,
    2282,
    562,
    1586,
    507,
    506,
    504,
    502,
    2257,
    499,
    2254,
    515,
    1563,
    1561,
    445,
    443,
    441,
    2219,
    438,
    2216,
    435,
    2212,
    460,
    454,
    475,
    1517,
    1515,
    1512,
    2447,
    798,
    797,
    2422,
    2419,
    770,
    768,
    766,
    2383,
    2380,
    2376,
    721,
    719,
    717,
    714,
    731,
    1714,
    2602,
    2582,
    2580,
    2548,
    2546,
    2543,
    923,
    921,
    2717,
    2706,
    2705,
    2683,
    2682,
    2680,
    1771,
    1752,
    1750,
    1733,
    1732,
    1731,
    1735,
    1814,
    1707,
    1670,
    1668,
    1631,
    1629,
    1626,
    1634,
    1599,
    1598,
    1596,
    1594,
    1603,
    1601,
    2326,
    1772,
    1753,
    1751,
    1581,
    1554,
    1552,
    1504,
    1501,
    1498,
    1509,
    1442,
    1437,
    1434,
    401,
    1448,
    1445,
    2206,
    1392,
    1391,
    1389,
    1387,
    1384,
    359,
    1399,
    1397,
    1394,
    1404,
    2171,
    2170,
    1708,
    1672,
    1669,
    619,
    1632,
    1630,
    1628,
    1773,
    1378,
    1363,
    1361,
    1333,
    1328,
    1336,
    1286,
    1281,
    1278,
    248,
    1292,
    1289,
    2111,
    1218,
    1216,
    1210,
    197,
    1206,
    193,
    1228,
    1225,
    1221,
    1236,
    2073,
    2071,
    1151,
    1150,
    1148,
    1146,
    152,
    1143,
    149,
    1140,
    145,
    1161,
    1159,
    1156,
    1153,
    158,
    1169,
    1166,
    2017,
    2016,
    2014,
    2019,
    1582,
    510,
    1556,
    1553,
    452,
    448,
    1506,
    1500,
    394,
    391,
    387,
    1443,
    1441,
    1439,
    1436,
    1450,
    2207,
    765,
    716,
    713,
    1709,
    662,
    660,
    657,
    1673,
    1671,
    916,
    914,
    879,
    878,
    877,
    882,
    1135,
    1134,
    1121,
    1120,
    1118,
    1123,
    1097,
    1096,
    1094,
    1092,
    103,
    1101,
    1099,
    1979,
    1059,
    1058,
    1056,
    1054,
    77,
    1051,
    74,
    1066,
    1064,
    1061,
    1071,
    1964,
    1963,
    1007,
    1006,
    1004,
    1002,
    999,
    41,
    996,
    37,
    1017,
    1015,
    1012,
    1009,
    52,
    1025,
    1022,
    1936,
    1935,
    1933,
    1938,
    942,
    940,
    938,
    935,
    932,
    5,
    2,
    955,
    953,
    950,
    947,
    18,
    943,
    15,
    965,
    962,
    958,
    1895,
    1894,
    1892,
    1890,
    973,
    1899,
    1897,
    1379,
    325,
    1364,
    1362,
    288,
    285,
    1334,
    1332,
    1330,
    241,
    238,
    234,
    1287,
    1285,
    1283,
    1280,
    1294,
    2112,
    188,
    185,
    181,
    178,
    2028,
    1219,
    1217,
    1215,
    1212,
    200,
    1209,
    1227,
    2074,
    2072,
    583,
    553,
    551,
    1583,
    505,
    503,
    500,
    513,
    1557,
    1555,
    444,
    442,
    439,
    436,
    2213,
    455,
    451,
    1507,
    1505,
    1502,
    796,
    763,
    762,
    760,
    767,
    711,
    710,
    708,
    706,
    2377,
    718,
    715,
    1710,
    2544,
    917,
    915,
    2681,
    1627,
    1597,
    1595,
    2325,
    1769,
    1749,
    1747,
    1499,
    1438,
    1435,
    2204,
    1390,
    1388,
    1385,
    1395,
    2169,
    2167,
    1704,
    1665,
    1662,
    1625,
    1623,
    1620,
    1770,
    1329,
    1282,
    1279,
    2109,
    1214,
    1207,
    1222,
    2068,
    2065,
    1149,
    1147,
    1144,
    1141,
    146,
    1157,
    1154,
    2013,
    2011,
    2008,
    2015,
    1579,
    1549,
    1546,
    1495,
    1487,
    1433,
    1431,
    1428,
    1425,
    388,
    1440,
    2205,
    1705,
    658,
    1667,
    1664,
    1119,
    1095,
    1093,
    1978,
    1057,
    1055,
    1052,
    1062,
    1962,
    1960,
    1005,
    1003,
    1e3,
    997,
    38,
    1013,
    1010,
    1932,
    1930,
    1927,
    1934,
    941,
    939,
    936,
    933,
    6,
    930,
    3,
    951,
    948,
    944,
    1889,
    1887,
    1884,
    1881,
    959,
    1893,
    1891,
    35,
    1377,
    1360,
    1358,
    1327,
    1325,
    1322,
    1331,
    1277,
    1275,
    1272,
    1269,
    235,
    1284,
    2110,
    1205,
    1204,
    1201,
    1198,
    182,
    1195,
    179,
    1213,
    2070,
    2067,
    1580,
    501,
    1551,
    1548,
    440,
    437,
    1497,
    1494,
    1490,
    1503,
    761,
    709,
    707,
    1706,
    913,
    912,
    2198,
    1386,
    2164,
    2161,
    1621,
    1766,
    2103,
    1208,
    2058,
    2054,
    1145,
    1142,
    2005,
    2002,
    1999,
    2009,
    1488,
    1429,
    1426,
    2200,
    1698,
    1659,
    1656,
    1975,
    1053,
    1957,
    1954,
    1001,
    998,
    1924,
    1921,
    1918,
    1928,
    937,
    934,
    931,
    1879,
    1876,
    1873,
    1870,
    945,
    1885,
    1882,
    1323,
    1273,
    1270,
    2105,
    1202,
    1199,
    1196,
    1211,
    2061,
    2057,
    1576,
    1543,
    1540,
    1484,
    1481,
    1478,
    1491,
    1700
  ]);
  return PDF417Common2;
}();
var PDF417Common_default = PDF417Common;

// node_modules/@zxing/library/esm/core/pdf417/detector/PDF417DetectorResult.js
var PDF417DetectorResult = function() {
  function PDF417DetectorResult2(bits, points) {
    this.bits = bits;
    this.points = points;
  }
  PDF417DetectorResult2.prototype.getBits = function() {
    return this.bits;
  };
  PDF417DetectorResult2.prototype.getPoints = function() {
    return this.points;
  };
  return PDF417DetectorResult2;
}();
var PDF417DetectorResult_default = PDF417DetectorResult;

// node_modules/@zxing/library/esm/core/pdf417/detector/Detector.js
var __values28 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Detector4 = function() {
  function Detector5() {
  }
  Detector5.detectMultiple = function(image, hints, multiple) {
    var bitMatrix = image.getBlackMatrix();
    var barcodeCoordinates = Detector5.detect(multiple, bitMatrix);
    if (!barcodeCoordinates.length) {
      bitMatrix = bitMatrix.clone();
      bitMatrix.rotate180();
      barcodeCoordinates = Detector5.detect(multiple, bitMatrix);
    }
    return new PDF417DetectorResult_default(bitMatrix, barcodeCoordinates);
  };
  Detector5.detect = function(multiple, bitMatrix) {
    var e_1, _a;
    var barcodeCoordinates = new Array();
    var row = 0;
    var column = 0;
    var foundBarcodeInRow = false;
    while (row < bitMatrix.getHeight()) {
      var vertices = Detector5.findVertices(bitMatrix, row, column);
      if (vertices[0] == null && vertices[3] == null) {
        if (!foundBarcodeInRow) {
          break;
        }
        foundBarcodeInRow = false;
        column = 0;
        try {
          for (var barcodeCoordinates_1 = (e_1 = void 0, __values28(barcodeCoordinates)), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {
            var barcodeCoordinate = barcodeCoordinates_1_1.value;
            if (barcodeCoordinate[1] != null) {
              row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
            }
            if (barcodeCoordinate[3] != null) {
              row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
            }
          }
        } catch (e_1_1) {
          e_1 = {error: e_1_1};
        } finally {
          try {
            if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return))
              _a.call(barcodeCoordinates_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        row += Detector5.ROW_STEP;
        continue;
      }
      foundBarcodeInRow = true;
      barcodeCoordinates.push(vertices);
      if (!multiple) {
        break;
      }
      if (vertices[2] != null) {
        column = Math.trunc(vertices[2].getX());
        row = Math.trunc(vertices[2].getY());
      } else {
        column = Math.trunc(vertices[4].getX());
        row = Math.trunc(vertices[4].getY());
      }
    }
    return barcodeCoordinates;
  };
  Detector5.findVertices = function(matrix, startRow, startColumn) {
    var height = matrix.getHeight();
    var width = matrix.getWidth();
    var result = new Array(8);
    Detector5.copyToResult(result, Detector5.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector5.START_PATTERN), Detector5.INDEXES_START_PATTERN);
    if (result[4] != null) {
      startColumn = Math.trunc(result[4].getX());
      startRow = Math.trunc(result[4].getY());
    }
    Detector5.copyToResult(result, Detector5.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector5.STOP_PATTERN), Detector5.INDEXES_STOP_PATTERN);
    return result;
  };
  Detector5.copyToResult = function(result, tmpResult, destinationIndexes) {
    for (var i = 0; i < destinationIndexes.length; i++) {
      result[destinationIndexes[i]] = tmpResult[i];
    }
  };
  Detector5.findRowsWithPattern = function(matrix, height, width, startRow, startColumn, pattern) {
    var result = new Array(4);
    var found = false;
    var counters = new Int32Array(pattern.length);
    for (; startRow < height; startRow += Detector5.ROW_STEP) {
      var loc = Detector5.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
      if (loc != null) {
        while (startRow > 0) {
          var previousRowLoc = Detector5.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
          if (previousRowLoc != null) {
            loc = previousRowLoc;
          } else {
            startRow++;
            break;
          }
        }
        result[0] = new ResultPoint_default(loc[0], startRow);
        result[1] = new ResultPoint_default(loc[1], startRow);
        found = true;
        break;
      }
    }
    var stopRow = startRow + 1;
    if (found) {
      var skippedRowCount = 0;
      var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
      for (; stopRow < height; stopRow++) {
        var loc = Detector5.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
        if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector5.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector5.MAX_PATTERN_DRIFT) {
          previousRowLoc = loc;
          skippedRowCount = 0;
        } else {
          if (skippedRowCount > Detector5.SKIPPED_ROW_COUNT_MAX) {
            break;
          } else {
            skippedRowCount++;
          }
        }
      }
      stopRow -= skippedRowCount + 1;
      result[2] = new ResultPoint_default(previousRowLoc[0], stopRow);
      result[3] = new ResultPoint_default(previousRowLoc[1], stopRow);
    }
    if (stopRow - startRow < Detector5.BARCODE_MIN_HEIGHT) {
      Arrays_default.fill(result, null);
    }
    return result;
  };
  Detector5.findGuardPattern = function(matrix, column, row, width, whiteFirst, pattern, counters) {
    Arrays_default.fillWithin(counters, 0, counters.length, 0);
    var patternStart = column;
    var pixelDrift = 0;
    while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector5.MAX_PIXEL_DRIFT) {
      patternStart--;
    }
    var x2 = patternStart;
    var counterPosition = 0;
    var patternLength = pattern.length;
    for (var isWhite = whiteFirst; x2 < width; x2++) {
      var pixel = matrix.get(x2, row);
      if (pixel !== isWhite) {
        counters[counterPosition]++;
      } else {
        if (counterPosition === patternLength - 1) {
          if (Detector5.patternMatchVariance(counters, pattern, Detector5.MAX_INDIVIDUAL_VARIANCE) < Detector5.MAX_AVG_VARIANCE) {
            return new Int32Array([patternStart, x2]);
          }
          patternStart += counters[0] + counters[1];
          System_default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
          counters[counterPosition - 1] = 0;
          counters[counterPosition] = 0;
          counterPosition--;
        } else {
          counterPosition++;
        }
        counters[counterPosition] = 1;
        isWhite = !isWhite;
      }
    }
    if (counterPosition === patternLength - 1 && Detector5.patternMatchVariance(counters, pattern, Detector5.MAX_INDIVIDUAL_VARIANCE) < Detector5.MAX_AVG_VARIANCE) {
      return new Int32Array([patternStart, x2 - 1]);
    }
    return null;
  };
  Detector5.patternMatchVariance = function(counters, pattern, maxIndividualVariance) {
    var numCounters = counters.length;
    var total = 0;
    var patternLength = 0;
    for (var i = 0; i < numCounters; i++) {
      total += counters[i];
      patternLength += pattern[i];
    }
    if (total < patternLength) {
      return Infinity;
    }
    var unitBarWidth = total / patternLength;
    maxIndividualVariance *= unitBarWidth;
    var totalVariance = 0;
    for (var x2 = 0; x2 < numCounters; x2++) {
      var counter = counters[x2];
      var scaledPattern = pattern[x2] * unitBarWidth;
      var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
      if (variance > maxIndividualVariance) {
        return Infinity;
      }
      totalVariance += variance;
    }
    return totalVariance / total;
  };
  Detector5.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
  Detector5.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
  Detector5.MAX_AVG_VARIANCE = 0.42;
  Detector5.MAX_INDIVIDUAL_VARIANCE = 0.8;
  Detector5.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
  Detector5.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
  Detector5.MAX_PIXEL_DRIFT = 3;
  Detector5.MAX_PATTERN_DRIFT = 5;
  Detector5.SKIPPED_ROW_COUNT_MAX = 25;
  Detector5.ROW_STEP = 5;
  Detector5.BARCODE_MIN_HEIGHT = 10;
  return Detector5;
}();
var Detector_default4 = Detector4;

// node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusPoly.js
var __values29 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ModulusPoly = function() {
  function ModulusPoly2(field, coefficients) {
    if (coefficients.length === 0) {
      throw new IllegalArgumentException_default();
    }
    this.field = field;
    var coefficientsLength = coefficients.length;
    if (coefficientsLength > 1 && coefficients[0] === 0) {
      var firstNonZero = 1;
      while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
        firstNonZero++;
      }
      if (firstNonZero === coefficientsLength) {
        this.coefficients = new Int32Array([0]);
      } else {
        this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
        System_default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
      }
    } else {
      this.coefficients = coefficients;
    }
  }
  ModulusPoly2.prototype.getCoefficients = function() {
    return this.coefficients;
  };
  ModulusPoly2.prototype.getDegree = function() {
    return this.coefficients.length - 1;
  };
  ModulusPoly2.prototype.isZero = function() {
    return this.coefficients[0] === 0;
  };
  ModulusPoly2.prototype.getCoefficient = function(degree) {
    return this.coefficients[this.coefficients.length - 1 - degree];
  };
  ModulusPoly2.prototype.evaluateAt = function(a) {
    var e_1, _a;
    if (a === 0) {
      return this.getCoefficient(0);
    }
    if (a === 1) {
      var sum = 0;
      try {
        for (var _b = __values29(this.coefficients), _c = _b.next(); !_c.done; _c = _b.next()) {
          var coefficient = _c.value;
          sum = this.field.add(sum, coefficient);
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return sum;
    }
    var result = this.coefficients[0];
    var size = this.coefficients.length;
    for (var i = 1; i < size; i++) {
      result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
    }
    return result;
  };
  ModulusPoly2.prototype.add = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
    }
    if (this.isZero()) {
      return other;
    }
    if (other.isZero()) {
      return this;
    }
    var smallerCoefficients = this.coefficients;
    var largerCoefficients = other.coefficients;
    if (smallerCoefficients.length > largerCoefficients.length) {
      var temp = smallerCoefficients;
      smallerCoefficients = largerCoefficients;
      largerCoefficients = temp;
    }
    var sumDiff = new Int32Array(largerCoefficients.length);
    var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
    System_default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
    for (var i = lengthDiff; i < largerCoefficients.length; i++) {
      sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
    }
    return new ModulusPoly2(this.field, sumDiff);
  };
  ModulusPoly2.prototype.subtract = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
    }
    if (other.isZero()) {
      return this;
    }
    return this.add(other.negative());
  };
  ModulusPoly2.prototype.multiply = function(other) {
    if (other instanceof ModulusPoly2) {
      return this.multiplyOther(other);
    }
    return this.multiplyScalar(other);
  };
  ModulusPoly2.prototype.multiplyOther = function(other) {
    if (!this.field.equals(other.field)) {
      throw new IllegalArgumentException_default("ModulusPolys do not have same ModulusGF field");
    }
    if (this.isZero() || other.isZero()) {
      return new ModulusPoly2(this.field, new Int32Array([0]));
    }
    var aCoefficients = this.coefficients;
    var aLength = aCoefficients.length;
    var bCoefficients = other.coefficients;
    var bLength = bCoefficients.length;
    var product = new Int32Array(aLength + bLength - 1);
    for (var i = 0; i < aLength; i++) {
      var aCoeff = aCoefficients[i];
      for (var j = 0; j < bLength; j++) {
        product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
      }
    }
    return new ModulusPoly2(this.field, product);
  };
  ModulusPoly2.prototype.negative = function() {
    var size = this.coefficients.length;
    var negativeCoefficients = new Int32Array(size);
    for (var i = 0; i < size; i++) {
      negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
    }
    return new ModulusPoly2(this.field, negativeCoefficients);
  };
  ModulusPoly2.prototype.multiplyScalar = function(scalar) {
    if (scalar === 0) {
      return new ModulusPoly2(this.field, new Int32Array([0]));
    }
    if (scalar === 1) {
      return this;
    }
    var size = this.coefficients.length;
    var product = new Int32Array(size);
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], scalar);
    }
    return new ModulusPoly2(this.field, product);
  };
  ModulusPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
    if (degree < 0) {
      throw new IllegalArgumentException_default();
    }
    if (coefficient === 0) {
      return new ModulusPoly2(this.field, new Int32Array([0]));
    }
    var size = this.coefficients.length;
    var product = new Int32Array(size + degree);
    for (var i = 0; i < size; i++) {
      product[i] = this.field.multiply(this.coefficients[i], coefficient);
    }
    return new ModulusPoly2(this.field, product);
  };
  ModulusPoly2.prototype.toString = function() {
    var result = new StringBuilder_default();
    for (var degree = this.getDegree(); degree >= 0; degree--) {
      var coefficient = this.getCoefficient(degree);
      if (coefficient !== 0) {
        if (coefficient < 0) {
          result.append(" - ");
          coefficient = -coefficient;
        } else {
          if (result.length() > 0) {
            result.append(" + ");
          }
        }
        if (degree === 0 || coefficient !== 1) {
          result.append(coefficient);
        }
        if (degree !== 0) {
          if (degree === 1) {
            result.append("x");
          } else {
            result.append("x^");
            result.append(degree);
          }
        }
      }
    }
    return result.toString();
  };
  return ModulusPoly2;
}();
var ModulusPoly_default = ModulusPoly;

// node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusBase.js
var ModulusBase = function() {
  function ModulusBase2() {
  }
  ModulusBase2.prototype.add = function(a, b) {
    return (a + b) % this.modulus;
  };
  ModulusBase2.prototype.subtract = function(a, b) {
    return (this.modulus + a - b) % this.modulus;
  };
  ModulusBase2.prototype.exp = function(a) {
    return this.expTable[a];
  };
  ModulusBase2.prototype.log = function(a) {
    if (a === 0) {
      throw new IllegalArgumentException_default();
    }
    return this.logTable[a];
  };
  ModulusBase2.prototype.inverse = function(a) {
    if (a === 0) {
      throw new ArithmeticException_default();
    }
    return this.expTable[this.modulus - this.logTable[a] - 1];
  };
  ModulusBase2.prototype.multiply = function(a, b) {
    if (a === 0 || b === 0) {
      return 0;
    }
    return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
  };
  ModulusBase2.prototype.getSize = function() {
    return this.modulus;
  };
  ModulusBase2.prototype.equals = function(o) {
    return o === this;
  };
  return ModulusBase2;
}();
var ModulusBase_default = ModulusBase;

// node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ModulusGF.js
var __extends54 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ModulusGF = function(_super) {
  __extends54(ModulusGF2, _super);
  function ModulusGF2(modulus, generator) {
    var _this = _super.call(this) || this;
    _this.modulus = modulus;
    _this.expTable = new Int32Array(modulus);
    _this.logTable = new Int32Array(modulus);
    var x2 = 1;
    for (var i = 0; i < modulus; i++) {
      _this.expTable[i] = x2;
      x2 = x2 * generator % modulus;
    }
    for (var i = 0; i < modulus - 1; i++) {
      _this.logTable[_this.expTable[i]] = i;
    }
    _this.zero = new ModulusPoly_default(_this, new Int32Array([0]));
    _this.one = new ModulusPoly_default(_this, new Int32Array([1]));
    return _this;
  }
  ModulusGF2.prototype.getZero = function() {
    return this.zero;
  };
  ModulusGF2.prototype.getOne = function() {
    return this.one;
  };
  ModulusGF2.prototype.buildMonomial = function(degree, coefficient) {
    if (degree < 0) {
      throw new IllegalArgumentException_default();
    }
    if (coefficient === 0) {
      return this.zero;
    }
    var coefficients = new Int32Array(degree + 1);
    coefficients[0] = coefficient;
    return new ModulusPoly_default(this, coefficients);
  };
  ModulusGF2.PDF417_GF = new ModulusGF2(PDF417Common_default.NUMBER_OF_CODEWORDS, 3);
  return ModulusGF2;
}(ModulusBase_default);
var ModulusGF_default = ModulusGF;

// node_modules/@zxing/library/esm/core/pdf417/decoder/ec/ErrorCorrection.js
var __values30 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ErrorCorrection = function() {
  function ErrorCorrection2() {
    this.field = ModulusGF_default.PDF417_GF;
  }
  ErrorCorrection2.prototype.decode = function(received, numECCodewords, erasures) {
    var e_1, _a;
    var poly = new ModulusPoly_default(this.field, received);
    var S = new Int32Array(numECCodewords);
    var error = false;
    for (var i = numECCodewords; i > 0; i--) {
      var evaluation = poly.evaluateAt(this.field.exp(i));
      S[numECCodewords - i] = evaluation;
      if (evaluation !== 0) {
        error = true;
      }
    }
    if (!error) {
      return 0;
    }
    var knownErrors = this.field.getOne();
    if (erasures != null) {
      try {
        for (var erasures_1 = __values30(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {
          var erasure = erasures_1_1.value;
          var b = this.field.exp(received.length - 1 - erasure);
          var term = new ModulusPoly_default(this.field, new Int32Array([this.field.subtract(0, b), 1]));
          knownErrors = knownErrors.multiply(term);
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return))
            _a.call(erasures_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    var syndrome = new ModulusPoly_default(this.field, S);
    var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
    var sigma = sigmaOmega[0];
    var omega = sigmaOmega[1];
    var errorLocations = this.findErrorLocations(sigma);
    var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
    for (var i = 0; i < errorLocations.length; i++) {
      var position = received.length - 1 - this.field.log(errorLocations[i]);
      if (position < 0) {
        throw ChecksumException_default.getChecksumInstance();
      }
      received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
    }
    return errorLocations.length;
  };
  ErrorCorrection2.prototype.runEuclideanAlgorithm = function(a, b, R) {
    if (a.getDegree() < b.getDegree()) {
      var temp = a;
      a = b;
      b = temp;
    }
    var rLast = a;
    var r = b;
    var tLast = this.field.getZero();
    var t = this.field.getOne();
    while (r.getDegree() >= Math.round(R / 2)) {
      var rLastLast = rLast;
      var tLastLast = tLast;
      rLast = r;
      tLast = t;
      if (rLast.isZero()) {
        throw ChecksumException_default.getChecksumInstance();
      }
      r = rLastLast;
      var q = this.field.getZero();
      var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
      var dltInverse = this.field.inverse(denominatorLeadingTerm);
      while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
        var degreeDiff = r.getDegree() - rLast.getDegree();
        var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
        q = q.add(this.field.buildMonomial(degreeDiff, scale));
        r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
      }
      t = q.multiply(tLast).subtract(tLastLast).negative();
    }
    var sigmaTildeAtZero = t.getCoefficient(0);
    if (sigmaTildeAtZero === 0) {
      throw ChecksumException_default.getChecksumInstance();
    }
    var inverse = this.field.inverse(sigmaTildeAtZero);
    var sigma = t.multiply(inverse);
    var omega = r.multiply(inverse);
    return [sigma, omega];
  };
  ErrorCorrection2.prototype.findErrorLocations = function(errorLocator) {
    var numErrors = errorLocator.getDegree();
    var result = new Int32Array(numErrors);
    var e = 0;
    for (var i = 1; i < this.field.getSize() && e < numErrors; i++) {
      if (errorLocator.evaluateAt(i) === 0) {
        result[e] = this.field.inverse(i);
        e++;
      }
    }
    if (e !== numErrors) {
      throw ChecksumException_default.getChecksumInstance();
    }
    return result;
  };
  ErrorCorrection2.prototype.findErrorMagnitudes = function(errorEvaluator, errorLocator, errorLocations) {
    var errorLocatorDegree = errorLocator.getDegree();
    var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
    for (var i = 1; i <= errorLocatorDegree; i++) {
      formalDerivativeCoefficients[errorLocatorDegree - i] = this.field.multiply(i, errorLocator.getCoefficient(i));
    }
    var formalDerivative = new ModulusPoly_default(this.field, formalDerivativeCoefficients);
    var s = errorLocations.length;
    var result = new Int32Array(s);
    for (var i = 0; i < s; i++) {
      var xiInverse = this.field.inverse(errorLocations[i]);
      var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
      var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
      result[i] = this.field.multiply(numerator, denominator);
    }
    return result;
  };
  return ErrorCorrection2;
}();
var ErrorCorrection_default = ErrorCorrection;

// node_modules/@zxing/library/esm/core/pdf417/decoder/BoundingBox.js
var BoundingBox = function() {
  function BoundingBox2(image, topLeft, bottomLeft, topRight, bottomRight) {
    if (image instanceof BoundingBox2) {
      this.constructor_2(image);
    } else {
      this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
    }
  }
  BoundingBox2.prototype.constructor_1 = function(image, topLeft, bottomLeft, topRight, bottomRight) {
    var leftUnspecified = topLeft == null || bottomLeft == null;
    var rightUnspecified = topRight == null || bottomRight == null;
    if (leftUnspecified && rightUnspecified) {
      throw new NotFoundException_default();
    }
    if (leftUnspecified) {
      topLeft = new ResultPoint_default(0, topRight.getY());
      bottomLeft = new ResultPoint_default(0, bottomRight.getY());
    } else if (rightUnspecified) {
      topRight = new ResultPoint_default(image.getWidth() - 1, topLeft.getY());
      bottomRight = new ResultPoint_default(image.getWidth() - 1, bottomLeft.getY());
    }
    this.image = image;
    this.topLeft = topLeft;
    this.bottomLeft = bottomLeft;
    this.topRight = topRight;
    this.bottomRight = bottomRight;
    this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
    this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
    this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
    this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
  };
  BoundingBox2.prototype.constructor_2 = function(boundingBox) {
    this.image = boundingBox.image;
    this.topLeft = boundingBox.getTopLeft();
    this.bottomLeft = boundingBox.getBottomLeft();
    this.topRight = boundingBox.getTopRight();
    this.bottomRight = boundingBox.getBottomRight();
    this.minX = boundingBox.getMinX();
    this.maxX = boundingBox.getMaxX();
    this.minY = boundingBox.getMinY();
    this.maxY = boundingBox.getMaxY();
  };
  BoundingBox2.merge = function(leftBox, rightBox) {
    if (leftBox == null) {
      return rightBox;
    }
    if (rightBox == null) {
      return leftBox;
    }
    return new BoundingBox2(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
  };
  BoundingBox2.prototype.addMissingRows = function(missingStartRows, missingEndRows, isLeft) {
    var newTopLeft = this.topLeft;
    var newBottomLeft = this.bottomLeft;
    var newTopRight = this.topRight;
    var newBottomRight = this.bottomRight;
    if (missingStartRows > 0) {
      var top_1 = isLeft ? this.topLeft : this.topRight;
      var newMinY = Math.trunc(top_1.getY() - missingStartRows);
      if (newMinY < 0) {
        newMinY = 0;
      }
      var newTop = new ResultPoint_default(top_1.getX(), newMinY);
      if (isLeft) {
        newTopLeft = newTop;
      } else {
        newTopRight = newTop;
      }
    }
    if (missingEndRows > 0) {
      var bottom = isLeft ? this.bottomLeft : this.bottomRight;
      var newMaxY = Math.trunc(bottom.getY() + missingEndRows);
      if (newMaxY >= this.image.getHeight()) {
        newMaxY = this.image.getHeight() - 1;
      }
      var newBottom = new ResultPoint_default(bottom.getX(), newMaxY);
      if (isLeft) {
        newBottomLeft = newBottom;
      } else {
        newBottomRight = newBottom;
      }
    }
    return new BoundingBox2(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
  };
  BoundingBox2.prototype.getMinX = function() {
    return this.minX;
  };
  BoundingBox2.prototype.getMaxX = function() {
    return this.maxX;
  };
  BoundingBox2.prototype.getMinY = function() {
    return this.minY;
  };
  BoundingBox2.prototype.getMaxY = function() {
    return this.maxY;
  };
  BoundingBox2.prototype.getTopLeft = function() {
    return this.topLeft;
  };
  BoundingBox2.prototype.getTopRight = function() {
    return this.topRight;
  };
  BoundingBox2.prototype.getBottomLeft = function() {
    return this.bottomLeft;
  };
  BoundingBox2.prototype.getBottomRight = function() {
    return this.bottomRight;
  };
  return BoundingBox2;
}();
var BoundingBox_default = BoundingBox;

// node_modules/@zxing/library/esm/core/pdf417/decoder/BarcodeMetadata.js
var BarcodeMetadata = function() {
  function BarcodeMetadata2(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
    this.columnCount = columnCount;
    this.errorCorrectionLevel = errorCorrectionLevel;
    this.rowCountUpperPart = rowCountUpperPart;
    this.rowCountLowerPart = rowCountLowerPart;
    this.rowCount = rowCountUpperPart + rowCountLowerPart;
  }
  BarcodeMetadata2.prototype.getColumnCount = function() {
    return this.columnCount;
  };
  BarcodeMetadata2.prototype.getErrorCorrectionLevel = function() {
    return this.errorCorrectionLevel;
  };
  BarcodeMetadata2.prototype.getRowCount = function() {
    return this.rowCount;
  };
  BarcodeMetadata2.prototype.getRowCountUpperPart = function() {
    return this.rowCountUpperPart;
  };
  BarcodeMetadata2.prototype.getRowCountLowerPart = function() {
    return this.rowCountLowerPart;
  };
  return BarcodeMetadata2;
}();
var BarcodeMetadata_default = BarcodeMetadata;

// node_modules/@zxing/library/esm/core/util/Formatter.js
var Formatter = function() {
  function Formatter2() {
    this.buffer = "";
  }
  Formatter2.form = function(str, arr) {
    var i = -1;
    function callback(exp, p0, p1, p2, p3, p4) {
      if (exp === "%%")
        return "%";
      if (arr[++i] === void 0)
        return void 0;
      exp = p2 ? parseInt(p2.substr(1)) : void 0;
      var base = p3 ? parseInt(p3.substr(1)) : void 0;
      var val;
      switch (p4) {
        case "s":
          val = arr[i];
          break;
        case "c":
          val = arr[i][0];
          break;
        case "f":
          val = parseFloat(arr[i]).toFixed(exp);
          break;
        case "p":
          val = parseFloat(arr[i]).toPrecision(exp);
          break;
        case "e":
          val = parseFloat(arr[i]).toExponential(exp);
          break;
        case "x":
          val = parseInt(arr[i]).toString(base ? base : 16);
          break;
        case "d":
          val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);
          break;
      }
      val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
      var size = parseInt(p1);
      var ch = p1 && p1[0] + "" === "0" ? "0" : " ";
      while (val.length < size)
        val = p0 !== void 0 ? val + ch : ch + val;
      return val;
    }
    var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
    return str.replace(regex, callback);
  };
  Formatter2.prototype.format = function(append) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    this.buffer += Formatter2.form(append, args);
  };
  Formatter2.prototype.toString = function() {
    return this.buffer;
  };
  return Formatter2;
}();
var Formatter_default = Formatter;

// node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResultColumn.js
var __values31 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DetectionResultColumn = function() {
  function DetectionResultColumn2(boundingBox) {
    this.boundingBox = new BoundingBox_default(boundingBox);
    this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
  }
  DetectionResultColumn2.prototype.getCodewordNearby = function(imageRow) {
    var codeword = this.getCodeword(imageRow);
    if (codeword != null) {
      return codeword;
    }
    for (var i = 1; i < DetectionResultColumn2.MAX_NEARBY_DISTANCE; i++) {
      var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
      if (nearImageRow >= 0) {
        codeword = this.codewords[nearImageRow];
        if (codeword != null) {
          return codeword;
        }
      }
      nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
      if (nearImageRow < this.codewords.length) {
        codeword = this.codewords[nearImageRow];
        if (codeword != null) {
          return codeword;
        }
      }
    }
    return null;
  };
  DetectionResultColumn2.prototype.imageRowToCodewordIndex = function(imageRow) {
    return imageRow - this.boundingBox.getMinY();
  };
  DetectionResultColumn2.prototype.setCodeword = function(imageRow, codeword) {
    this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
  };
  DetectionResultColumn2.prototype.getCodeword = function(imageRow) {
    return this.codewords[this.imageRowToCodewordIndex(imageRow)];
  };
  DetectionResultColumn2.prototype.getBoundingBox = function() {
    return this.boundingBox;
  };
  DetectionResultColumn2.prototype.getCodewords = function() {
    return this.codewords;
  };
  DetectionResultColumn2.prototype.toString = function() {
    var e_1, _a;
    var formatter = new Formatter_default();
    var row = 0;
    try {
      for (var _b = __values31(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {
        var codeword = _c.value;
        if (codeword == null) {
          formatter.format("%3d:    |   %n", row++);
          continue;
        }
        formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return formatter.toString();
  };
  DetectionResultColumn2.MAX_NEARBY_DISTANCE = 5;
  return DetectionResultColumn2;
}();
var DetectionResultColumn_default = DetectionResultColumn;

// node_modules/@zxing/library/esm/core/pdf417/decoder/BarcodeValue.js
var __values32 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = {error};
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var BarcodeValue = function() {
  function BarcodeValue2() {
    this.values = new Map();
  }
  BarcodeValue2.prototype.setValue = function(value) {
    value = Math.trunc(value);
    var confidence = this.values.get(value);
    if (confidence == null) {
      confidence = 0;
    }
    confidence++;
    this.values.set(value, confidence);
  };
  BarcodeValue2.prototype.getValue = function() {
    var e_1, _a;
    var maxConfidence = -1;
    var result = new Array();
    var _loop_1 = function(key2, value2) {
      var entry = {
        getKey: function() {
          return key2;
        },
        getValue: function() {
          return value2;
        }
      };
      if (entry.getValue() > maxConfidence) {
        maxConfidence = entry.getValue();
        result = [];
        result.push(entry.getKey());
      } else if (entry.getValue() === maxConfidence) {
        result.push(entry.getKey());
      }
    };
    try {
      for (var _b = __values32(this.values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
        _loop_1(key, value);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return PDF417Common_default.toIntArray(result);
  };
  BarcodeValue2.prototype.getConfidence = function(value) {
    return this.values.get(value);
  };
  return BarcodeValue2;
}();
var BarcodeValue_default = BarcodeValue;

// node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js
var __extends55 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values33 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DetectionResultRowIndicatorColumn = function(_super) {
  __extends55(DetectionResultRowIndicatorColumn2, _super);
  function DetectionResultRowIndicatorColumn2(boundingBox, isLeft) {
    var _this = _super.call(this, boundingBox) || this;
    _this._isLeft = isLeft;
    return _this;
  }
  DetectionResultRowIndicatorColumn2.prototype.setRowNumbers = function() {
    var e_1, _a;
    try {
      for (var _b = __values33(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var codeword = _c.value;
        if (codeword != null) {
          codeword.setRowNumberAsRowIndicatorColumn();
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  DetectionResultRowIndicatorColumn2.prototype.adjustCompleteIndicatorColumnRowNumbers = function(barcodeMetadata) {
    var codewords = this.getCodewords();
    this.setRowNumbers();
    this.removeIncorrectCodewords(codewords, barcodeMetadata);
    var boundingBox = this.getBoundingBox();
    var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
    var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
    var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
    var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
    var barcodeRow = -1;
    var maxRowHeight = 1;
    var currentRowHeight = 0;
    for (var codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
      if (codewords[codewordsRow] == null) {
        continue;
      }
      var codeword = codewords[codewordsRow];
      var rowDifference = codeword.getRowNumber() - barcodeRow;
      if (rowDifference === 0) {
        currentRowHeight++;
      } else if (rowDifference === 1) {
        maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
        currentRowHeight = 1;
        barcodeRow = codeword.getRowNumber();
      } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
        codewords[codewordsRow] = null;
      } else {
        var checkedRows = void 0;
        if (maxRowHeight > 2) {
          checkedRows = (maxRowHeight - 2) * rowDifference;
        } else {
          checkedRows = rowDifference;
        }
        var closePreviousCodewordFound = checkedRows >= codewordsRow;
        for (var i = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
          closePreviousCodewordFound = codewords[codewordsRow - i] != null;
        }
        if (closePreviousCodewordFound) {
          codewords[codewordsRow] = null;
        } else {
          barcodeRow = codeword.getRowNumber();
          currentRowHeight = 1;
        }
      }
    }
  };
  DetectionResultRowIndicatorColumn2.prototype.getRowHeights = function() {
    var e_2, _a;
    var barcodeMetadata = this.getBarcodeMetadata();
    if (barcodeMetadata == null) {
      return null;
    }
    this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
    var result = new Int32Array(barcodeMetadata.getRowCount());
    try {
      for (var _b = __values33(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var codeword = _c.value;
        if (codeword != null) {
          var rowNumber = codeword.getRowNumber();
          if (rowNumber >= result.length) {
            continue;
          }
          result[rowNumber]++;
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return result;
  };
  DetectionResultRowIndicatorColumn2.prototype.adjustIncompleteIndicatorColumnRowNumbers = function(barcodeMetadata) {
    var boundingBox = this.getBoundingBox();
    var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
    var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
    var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
    var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
    var codewords = this.getCodewords();
    var barcodeRow = -1;
    var maxRowHeight = 1;
    var currentRowHeight = 0;
    for (var codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
      if (codewords[codewordsRow] == null) {
        continue;
      }
      var codeword = codewords[codewordsRow];
      codeword.setRowNumberAsRowIndicatorColumn();
      var rowDifference = codeword.getRowNumber() - barcodeRow;
      if (rowDifference === 0) {
        currentRowHeight++;
      } else if (rowDifference === 1) {
        maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
        currentRowHeight = 1;
        barcodeRow = codeword.getRowNumber();
      } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
        codewords[codewordsRow] = null;
      } else {
        barcodeRow = codeword.getRowNumber();
        currentRowHeight = 1;
      }
    }
  };
  DetectionResultRowIndicatorColumn2.prototype.getBarcodeMetadata = function() {
    var e_3, _a;
    var codewords = this.getCodewords();
    var barcodeColumnCount = new BarcodeValue_default();
    var barcodeRowCountUpperPart = new BarcodeValue_default();
    var barcodeRowCountLowerPart = new BarcodeValue_default();
    var barcodeECLevel = new BarcodeValue_default();
    try {
      for (var codewords_1 = __values33(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {
        var codeword = codewords_1_1.value;
        if (codeword == null) {
          continue;
        }
        codeword.setRowNumberAsRowIndicatorColumn();
        var rowIndicatorValue = codeword.getValue() % 30;
        var codewordRowNumber = codeword.getRowNumber();
        if (!this._isLeft) {
          codewordRowNumber += 2;
        }
        switch (codewordRowNumber % 3) {
          case 0:
            barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
            break;
          case 1:
            barcodeECLevel.setValue(rowIndicatorValue / 3);
            barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
            break;
          case 2:
            barcodeColumnCount.setValue(rowIndicatorValue + 1);
            break;
        }
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (codewords_1_1 && !codewords_1_1.done && (_a = codewords_1.return))
          _a.call(codewords_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_default.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_default.MAX_ROWS_IN_BARCODE) {
      return null;
    }
    var barcodeMetadata = new BarcodeMetadata_default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
    this.removeIncorrectCodewords(codewords, barcodeMetadata);
    return barcodeMetadata;
  };
  DetectionResultRowIndicatorColumn2.prototype.removeIncorrectCodewords = function(codewords, barcodeMetadata) {
    for (var codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
      var codeword = codewords[codewordRow];
      if (codewords[codewordRow] == null) {
        continue;
      }
      var rowIndicatorValue = codeword.getValue() % 30;
      var codewordRowNumber = codeword.getRowNumber();
      if (codewordRowNumber > barcodeMetadata.getRowCount()) {
        codewords[codewordRow] = null;
        continue;
      }
      if (!this._isLeft) {
        codewordRowNumber += 2;
      }
      switch (codewordRowNumber % 3) {
        case 0:
          if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
            codewords[codewordRow] = null;
          }
          break;
        case 1:
          if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
            codewords[codewordRow] = null;
          }
          break;
        case 2:
          if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
            codewords[codewordRow] = null;
          }
          break;
      }
    }
  };
  DetectionResultRowIndicatorColumn2.prototype.isLeft = function() {
    return this._isLeft;
  };
  DetectionResultRowIndicatorColumn2.prototype.toString = function() {
    return "IsLeft: " + this._isLeft + "\n" + _super.prototype.toString.call(this);
  };
  return DetectionResultRowIndicatorColumn2;
}(DetectionResultColumn_default);
var DetectionResultRowIndicatorColumn_default = DetectionResultRowIndicatorColumn;

// node_modules/@zxing/library/esm/core/pdf417/decoder/DetectionResult.js
var __values34 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DetectionResult = function() {
  function DetectionResult2(barcodeMetadata, boundingBox) {
    this.ADJUST_ROW_NUMBER_SKIP = 2;
    this.barcodeMetadata = barcodeMetadata;
    this.barcodeColumnCount = barcodeMetadata.getColumnCount();
    this.boundingBox = boundingBox;
    this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
  }
  DetectionResult2.prototype.getDetectionResultColumns = function() {
    this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
    this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
    var unadjustedCodewordCount = PDF417Common_default.MAX_CODEWORDS_IN_BARCODE;
    var previousUnadjustedCount;
    do {
      previousUnadjustedCount = unadjustedCodewordCount;
      unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
    } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
    return this.detectionResultColumns;
  };
  DetectionResult2.prototype.adjustIndicatorColumnRowNumbers = function(detectionResultColumn) {
    if (detectionResultColumn != null) {
      detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
    }
  };
  DetectionResult2.prototype.adjustRowNumbersAndGetCount = function() {
    var unadjustedCount = this.adjustRowNumbersByRow();
    if (unadjustedCount === 0) {
      return 0;
    }
    for (var barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
      var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
      for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
        if (codewords[codewordsRow] == null) {
          continue;
        }
        if (!codewords[codewordsRow].hasValidRowNumber()) {
          this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
        }
      }
    }
    return unadjustedCount;
  };
  DetectionResult2.prototype.adjustRowNumbersByRow = function() {
    this.adjustRowNumbersFromBothRI();
    var unadjustedCount = this.adjustRowNumbersFromLRI();
    return unadjustedCount + this.adjustRowNumbersFromRRI();
  };
  DetectionResult2.prototype.adjustRowNumbersFromBothRI = function() {
    if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
      return;
    }
    var LRIcodewords = this.detectionResultColumns[0].getCodewords();
    var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
    for (var codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
      if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
        for (var barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
          var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
          if (codeword == null) {
            continue;
          }
          codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
          if (!codeword.hasValidRowNumber()) {
            this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
          }
        }
      }
    }
  };
  DetectionResult2.prototype.adjustRowNumbersFromRRI = function() {
    if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
      return 0;
    }
    var unadjustedCount = 0;
    var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
    for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
      if (codewords[codewordsRow] == null) {
        continue;
      }
      var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
      var invalidRowCounts = 0;
      for (var barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
        if (codeword != null) {
          invalidRowCounts = DetectionResult2.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
          if (!codeword.hasValidRowNumber()) {
            unadjustedCount++;
          }
        }
      }
    }
    return unadjustedCount;
  };
  DetectionResult2.prototype.adjustRowNumbersFromLRI = function() {
    if (this.detectionResultColumns[0] == null) {
      return 0;
    }
    var unadjustedCount = 0;
    var codewords = this.detectionResultColumns[0].getCodewords();
    for (var codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
      if (codewords[codewordsRow] == null) {
        continue;
      }
      var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
      var invalidRowCounts = 0;
      for (var barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
        if (codeword != null) {
          invalidRowCounts = DetectionResult2.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
          if (!codeword.hasValidRowNumber()) {
            unadjustedCount++;
          }
        }
      }
    }
    return unadjustedCount;
  };
  DetectionResult2.adjustRowNumberIfValid = function(rowIndicatorRowNumber, invalidRowCounts, codeword) {
    if (codeword == null) {
      return invalidRowCounts;
    }
    if (!codeword.hasValidRowNumber()) {
      if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
        codeword.setRowNumber(rowIndicatorRowNumber);
        invalidRowCounts = 0;
      } else {
        ++invalidRowCounts;
      }
    }
    return invalidRowCounts;
  };
  DetectionResult2.prototype.adjustRowNumbers = function(barcodeColumn, codewordsRow, codewords) {
    var e_1, _a;
    var codeword = codewords[codewordsRow];
    var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
    var nextColumnCodewords = previousColumnCodewords;
    if (this.detectionResultColumns[barcodeColumn + 1] != null) {
      nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
    }
    var otherCodewords = new Array(14);
    otherCodewords[2] = previousColumnCodewords[codewordsRow];
    otherCodewords[3] = nextColumnCodewords[codewordsRow];
    if (codewordsRow > 0) {
      otherCodewords[0] = codewords[codewordsRow - 1];
      otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
      otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
    }
    if (codewordsRow > 1) {
      otherCodewords[8] = codewords[codewordsRow - 2];
      otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
      otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
    }
    if (codewordsRow < codewords.length - 1) {
      otherCodewords[1] = codewords[codewordsRow + 1];
      otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
      otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
    }
    if (codewordsRow < codewords.length - 2) {
      otherCodewords[9] = codewords[codewordsRow + 2];
      otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
      otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
    }
    try {
      for (var otherCodewords_1 = __values34(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {
        var otherCodeword = otherCodewords_1_1.value;
        if (DetectionResult2.adjustRowNumber(codeword, otherCodeword)) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return))
          _a.call(otherCodewords_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  DetectionResult2.adjustRowNumber = function(codeword, otherCodeword) {
    if (otherCodeword == null) {
      return false;
    }
    if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
      codeword.setRowNumber(otherCodeword.getRowNumber());
      return true;
    }
    return false;
  };
  DetectionResult2.prototype.getBarcodeColumnCount = function() {
    return this.barcodeColumnCount;
  };
  DetectionResult2.prototype.getBarcodeRowCount = function() {
    return this.barcodeMetadata.getRowCount();
  };
  DetectionResult2.prototype.getBarcodeECLevel = function() {
    return this.barcodeMetadata.getErrorCorrectionLevel();
  };
  DetectionResult2.prototype.setBoundingBox = function(boundingBox) {
    this.boundingBox = boundingBox;
  };
  DetectionResult2.prototype.getBoundingBox = function() {
    return this.boundingBox;
  };
  DetectionResult2.prototype.setDetectionResultColumn = function(barcodeColumn, detectionResultColumn) {
    this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
  };
  DetectionResult2.prototype.getDetectionResultColumn = function(barcodeColumn) {
    return this.detectionResultColumns[barcodeColumn];
  };
  DetectionResult2.prototype.toString = function() {
    var rowIndicatorColumn = this.detectionResultColumns[0];
    if (rowIndicatorColumn == null) {
      rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
    }
    var formatter = new Formatter_default();
    for (var codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
      formatter.format("CW %3d:", codewordsRow);
      for (var barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
        if (this.detectionResultColumns[barcodeColumn] == null) {
          formatter.format("    |   ");
          continue;
        }
        var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
        if (codeword == null) {
          formatter.format("    |   ");
          continue;
        }
        formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
      }
      formatter.format("%n");
    }
    return formatter.toString();
  };
  return DetectionResult2;
}();
var DetectionResult_default = DetectionResult;

// node_modules/@zxing/library/esm/core/pdf417/decoder/Codeword.js
var Codeword = function() {
  function Codeword2(startX, endX, bucket, value) {
    this.rowNumber = Codeword2.BARCODE_ROW_UNKNOWN;
    this.startX = Math.trunc(startX);
    this.endX = Math.trunc(endX);
    this.bucket = Math.trunc(bucket);
    this.value = Math.trunc(value);
  }
  Codeword2.prototype.hasValidRowNumber = function() {
    return this.isValidRowNumber(this.rowNumber);
  };
  Codeword2.prototype.isValidRowNumber = function(rowNumber) {
    return rowNumber !== Codeword2.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
  };
  Codeword2.prototype.setRowNumberAsRowIndicatorColumn = function() {
    this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
  };
  Codeword2.prototype.getWidth = function() {
    return this.endX - this.startX;
  };
  Codeword2.prototype.getStartX = function() {
    return this.startX;
  };
  Codeword2.prototype.getEndX = function() {
    return this.endX;
  };
  Codeword2.prototype.getBucket = function() {
    return this.bucket;
  };
  Codeword2.prototype.getValue = function() {
    return this.value;
  };
  Codeword2.prototype.getRowNumber = function() {
    return this.rowNumber;
  };
  Codeword2.prototype.setRowNumber = function(rowNumber) {
    this.rowNumber = rowNumber;
  };
  Codeword2.prototype.toString = function() {
    return this.rowNumber + "|" + this.value;
  };
  Codeword2.BARCODE_ROW_UNKNOWN = -1;
  return Codeword2;
}();
var Codeword_default = Codeword;

// node_modules/@zxing/library/esm/core/pdf417/decoder/PDF417CodewordDecoder.js
var PDF417CodewordDecoder = function() {
  function PDF417CodewordDecoder2() {
  }
  PDF417CodewordDecoder2.initialize = function() {
    for (var i = 0; i < PDF417Common_default.SYMBOL_TABLE.length; i++) {
      var currentSymbol = PDF417Common_default.SYMBOL_TABLE[i];
      var currentBit = currentSymbol & 1;
      for (var j = 0; j < PDF417Common_default.BARS_IN_MODULE; j++) {
        var size = 0;
        while ((currentSymbol & 1) === currentBit) {
          size += 1;
          currentSymbol >>= 1;
        }
        currentBit = currentSymbol & 1;
        if (!PDF417CodewordDecoder2.RATIOS_TABLE[i]) {
          PDF417CodewordDecoder2.RATIOS_TABLE[i] = new Array(PDF417Common_default.BARS_IN_MODULE);
        }
        PDF417CodewordDecoder2.RATIOS_TABLE[i][PDF417Common_default.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common_default.MODULES_IN_CODEWORD);
      }
    }
    this.bSymbolTableReady = true;
  };
  PDF417CodewordDecoder2.getDecodedValue = function(moduleBitCount) {
    var decodedValue = PDF417CodewordDecoder2.getDecodedCodewordValue(PDF417CodewordDecoder2.sampleBitCounts(moduleBitCount));
    if (decodedValue !== -1) {
      return decodedValue;
    }
    return PDF417CodewordDecoder2.getClosestDecodedValue(moduleBitCount);
  };
  PDF417CodewordDecoder2.sampleBitCounts = function(moduleBitCount) {
    var bitCountSum = MathUtils_default.sum(moduleBitCount);
    var result = new Int32Array(PDF417Common_default.BARS_IN_MODULE);
    var bitCountIndex = 0;
    var sumPreviousBits = 0;
    for (var i = 0; i < PDF417Common_default.MODULES_IN_CODEWORD; i++) {
      var sampleIndex = bitCountSum / (2 * PDF417Common_default.MODULES_IN_CODEWORD) + i * bitCountSum / PDF417Common_default.MODULES_IN_CODEWORD;
      if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
        sumPreviousBits += moduleBitCount[bitCountIndex];
        bitCountIndex++;
      }
      result[bitCountIndex]++;
    }
    return result;
  };
  PDF417CodewordDecoder2.getDecodedCodewordValue = function(moduleBitCount) {
    var decodedValue = PDF417CodewordDecoder2.getBitValue(moduleBitCount);
    return PDF417Common_default.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
  };
  PDF417CodewordDecoder2.getBitValue = function(moduleBitCount) {
    var result = 0;
    for (var i = 0; i < moduleBitCount.length; i++) {
      for (var bit = 0; bit < moduleBitCount[i]; bit++) {
        result = result << 1 | (i % 2 === 0 ? 1 : 0);
      }
    }
    return Math.trunc(result);
  };
  PDF417CodewordDecoder2.getClosestDecodedValue = function(moduleBitCount) {
    var bitCountSum = MathUtils_default.sum(moduleBitCount);
    var bitCountRatios = new Array(PDF417Common_default.BARS_IN_MODULE);
    if (bitCountSum > 1) {
      for (var i = 0; i < bitCountRatios.length; i++) {
        bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
      }
    }
    var bestMatchError = Float_default.MAX_VALUE;
    var bestMatch = -1;
    if (!this.bSymbolTableReady) {
      PDF417CodewordDecoder2.initialize();
    }
    for (var j = 0; j < PDF417CodewordDecoder2.RATIOS_TABLE.length; j++) {
      var error = 0;
      var ratioTableRow = PDF417CodewordDecoder2.RATIOS_TABLE[j];
      for (var k = 0; k < PDF417Common_default.BARS_IN_MODULE; k++) {
        var diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
        error += Math.fround(diff * diff);
        if (error >= bestMatchError) {
          break;
        }
      }
      if (error < bestMatchError) {
        bestMatchError = error;
        bestMatch = PDF417Common_default.SYMBOL_TABLE[j];
      }
    }
    return bestMatch;
  };
  PDF417CodewordDecoder2.bSymbolTableReady = false;
  PDF417CodewordDecoder2.RATIOS_TABLE = new Array(PDF417Common_default.SYMBOL_TABLE.length).map(function(x2) {
    return x2 = new Array(PDF417Common_default.BARS_IN_MODULE);
  });
  return PDF417CodewordDecoder2;
}();
var PDF417CodewordDecoder_default = PDF417CodewordDecoder;

// node_modules/@zxing/library/esm/core/pdf417/PDF417ResultMetadata.js
var PDF417ResultMetadata = function() {
  function PDF417ResultMetadata2() {
    this.segmentCount = -1;
    this.fileSize = -1;
    this.timestamp = -1;
    this.checksum = -1;
  }
  PDF417ResultMetadata2.prototype.getSegmentIndex = function() {
    return this.segmentIndex;
  };
  PDF417ResultMetadata2.prototype.setSegmentIndex = function(segmentIndex) {
    this.segmentIndex = segmentIndex;
  };
  PDF417ResultMetadata2.prototype.getFileId = function() {
    return this.fileId;
  };
  PDF417ResultMetadata2.prototype.setFileId = function(fileId) {
    this.fileId = fileId;
  };
  PDF417ResultMetadata2.prototype.getOptionalData = function() {
    return this.optionalData;
  };
  PDF417ResultMetadata2.prototype.setOptionalData = function(optionalData) {
    this.optionalData = optionalData;
  };
  PDF417ResultMetadata2.prototype.isLastSegment = function() {
    return this.lastSegment;
  };
  PDF417ResultMetadata2.prototype.setLastSegment = function(lastSegment) {
    this.lastSegment = lastSegment;
  };
  PDF417ResultMetadata2.prototype.getSegmentCount = function() {
    return this.segmentCount;
  };
  PDF417ResultMetadata2.prototype.setSegmentCount = function(segmentCount) {
    this.segmentCount = segmentCount;
  };
  PDF417ResultMetadata2.prototype.getSender = function() {
    return this.sender || null;
  };
  PDF417ResultMetadata2.prototype.setSender = function(sender) {
    this.sender = sender;
  };
  PDF417ResultMetadata2.prototype.getAddressee = function() {
    return this.addressee || null;
  };
  PDF417ResultMetadata2.prototype.setAddressee = function(addressee) {
    this.addressee = addressee;
  };
  PDF417ResultMetadata2.prototype.getFileName = function() {
    return this.fileName;
  };
  PDF417ResultMetadata2.prototype.setFileName = function(fileName) {
    this.fileName = fileName;
  };
  PDF417ResultMetadata2.prototype.getFileSize = function() {
    return this.fileSize;
  };
  PDF417ResultMetadata2.prototype.setFileSize = function(fileSize) {
    this.fileSize = fileSize;
  };
  PDF417ResultMetadata2.prototype.getChecksum = function() {
    return this.checksum;
  };
  PDF417ResultMetadata2.prototype.setChecksum = function(checksum) {
    this.checksum = checksum;
  };
  PDF417ResultMetadata2.prototype.getTimestamp = function() {
    return this.timestamp;
  };
  PDF417ResultMetadata2.prototype.setTimestamp = function(timestamp) {
    this.timestamp = timestamp;
  };
  return PDF417ResultMetadata2;
}();
var PDF417ResultMetadata_default = PDF417ResultMetadata;

// node_modules/@zxing/library/esm/core/util/Long.js
var Long = function() {
  function Long2() {
  }
  Long2.parseLong = function(num, radix) {
    if (radix === void 0) {
      radix = void 0;
    }
    return parseInt(num, radix);
  };
  return Long2;
}();
var Long_default = Long;

// node_modules/@zxing/library/esm/core/NullPointerException.js
var __extends56 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NullPointerException = function(_super) {
  __extends56(NullPointerException2, _super);
  function NullPointerException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  NullPointerException2.kind = "NullPointerException";
  return NullPointerException2;
}(Exception_default);
var NullPointerException_default = NullPointerException;

// node_modules/@zxing/library/esm/core/util/OutputStream.js
var OutputStream = function() {
  function OutputStream2() {
  }
  OutputStream2.prototype.writeBytes = function(b) {
    this.writeBytesOffset(b, 0, b.length);
  };
  OutputStream2.prototype.writeBytesOffset = function(b, off, len) {
    if (b == null) {
      throw new NullPointerException_default();
    } else if (off < 0 || off > b.length || len < 0 || off + len > b.length || off + len < 0) {
      throw new IndexOutOfBoundsException_default();
    } else if (len === 0) {
      return;
    }
    for (var i = 0; i < len; i++) {
      this.write(b[off + i]);
    }
  };
  OutputStream2.prototype.flush = function() {
  };
  OutputStream2.prototype.close = function() {
  };
  return OutputStream2;
}();
var OutputStream_default = OutputStream;

// node_modules/@zxing/library/esm/core/OutOfMemoryError.js
var __extends57 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var OutOfMemoryError = function(_super) {
  __extends57(OutOfMemoryError2, _super);
  function OutOfMemoryError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return OutOfMemoryError2;
}(Exception_default);
var OutOfMemoryError_default = OutOfMemoryError;

// node_modules/@zxing/library/esm/core/util/ByteArrayOutputStream.js
var __extends58 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ByteArrayOutputStream = function(_super) {
  __extends58(ByteArrayOutputStream2, _super);
  function ByteArrayOutputStream2(size) {
    if (size === void 0) {
      size = 32;
    }
    var _this = _super.call(this) || this;
    _this.count = 0;
    if (size < 0) {
      throw new IllegalArgumentException_default("Negative initial size: " + size);
    }
    _this.buf = new Uint8Array(size);
    return _this;
  }
  ByteArrayOutputStream2.prototype.ensureCapacity = function(minCapacity) {
    if (minCapacity - this.buf.length > 0)
      this.grow(minCapacity);
  };
  ByteArrayOutputStream2.prototype.grow = function(minCapacity) {
    var oldCapacity = this.buf.length;
    var newCapacity = oldCapacity << 1;
    if (newCapacity - minCapacity < 0)
      newCapacity = minCapacity;
    if (newCapacity < 0) {
      if (minCapacity < 0)
        throw new OutOfMemoryError_default();
      newCapacity = Integer_default.MAX_VALUE;
    }
    this.buf = Arrays_default.copyOfUint8Array(this.buf, newCapacity);
  };
  ByteArrayOutputStream2.prototype.write = function(b) {
    this.ensureCapacity(this.count + 1);
    this.buf[this.count] = b;
    this.count += 1;
  };
  ByteArrayOutputStream2.prototype.writeBytesOffset = function(b, off, len) {
    if (off < 0 || off > b.length || len < 0 || off + len - b.length > 0) {
      throw new IndexOutOfBoundsException_default();
    }
    this.ensureCapacity(this.count + len);
    System_default.arraycopy(b, off, this.buf, this.count, len);
    this.count += len;
  };
  ByteArrayOutputStream2.prototype.writeTo = function(out) {
    out.writeBytesOffset(this.buf, 0, this.count);
  };
  ByteArrayOutputStream2.prototype.reset = function() {
    this.count = 0;
  };
  ByteArrayOutputStream2.prototype.toByteArray = function() {
    return Arrays_default.copyOfUint8Array(this.buf, this.count);
  };
  ByteArrayOutputStream2.prototype.size = function() {
    return this.count;
  };
  ByteArrayOutputStream2.prototype.toString = function(param) {
    if (!param) {
      return this.toString_void();
    }
    if (typeof param === "string") {
      return this.toString_string(param);
    }
    return this.toString_number(param);
  };
  ByteArrayOutputStream2.prototype.toString_void = function() {
    return new String(this.buf).toString();
  };
  ByteArrayOutputStream2.prototype.toString_string = function(charsetName) {
    return new String(this.buf).toString();
  };
  ByteArrayOutputStream2.prototype.toString_number = function(hibyte) {
    return new String(this.buf).toString();
  };
  ByteArrayOutputStream2.prototype.close = function() {
  };
  return ByteArrayOutputStream2;
}(OutputStream_default);
var ByteArrayOutputStream_default = ByteArrayOutputStream;

// node_modules/@zxing/library/esm/core/pdf417/decoder/DecodedBitStreamParser.js
var Mode3;
(function(Mode4) {
  Mode4[Mode4["ALPHA"] = 0] = "ALPHA";
  Mode4[Mode4["LOWER"] = 1] = "LOWER";
  Mode4[Mode4["MIXED"] = 2] = "MIXED";
  Mode4[Mode4["PUNCT"] = 3] = "PUNCT";
  Mode4[Mode4["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
  Mode4[Mode4["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
})(Mode3 || (Mode3 = {}));
function getBigIntConstructor() {
  if (typeof window !== "undefined") {
    return window["BigInt"] || null;
  }
  if (typeof global !== "undefined") {
    return global["BigInt"] || null;
  }
  if (typeof self !== "undefined") {
    return self["BigInt"] || null;
  }
  throw new Error("Can't search globals for BigInt!");
}
var BigInteger;
function createBigInt(num) {
  if (typeof BigInteger === "undefined") {
    BigInteger = getBigIntConstructor();
  }
  if (BigInteger === null) {
    throw new Error("BigInt is not supported!");
  }
  return BigInteger(num);
}
function getEXP900() {
  var EXP900 = [];
  EXP900[0] = createBigInt(1);
  var nineHundred = createBigInt(900);
  EXP900[1] = nineHundred;
  for (var i = 2; i < 16; i++) {
    EXP900[i] = EXP900[i - 1] * nineHundred;
  }
  return EXP900;
}
var DecodedBitStreamParser3 = function() {
  function DecodedBitStreamParser4() {
  }
  DecodedBitStreamParser4.decode = function(codewords, ecLevel) {
    var result = new StringBuilder_default("");
    var encoding2 = CharacterSetECI_default.ISO8859_1;
    result.enableDecoding(encoding2);
    var codeIndex = 1;
    var code = codewords[codeIndex++];
    var resultMetadata = new PDF417ResultMetadata_default();
    while (codeIndex < codewords[0]) {
      switch (code) {
        case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
          codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, result);
          break;
        case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
        case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
          codeIndex = DecodedBitStreamParser4.byteCompaction(code, codewords, encoding2, codeIndex, result);
          break;
        case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
          result.append(codewords[codeIndex++]);
          break;
        case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
          codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex, result);
          break;
        case DecodedBitStreamParser4.ECI_CHARSET:
          var charsetECI = CharacterSetECI_default.getCharacterSetECIByValue(codewords[codeIndex++]);
          break;
        case DecodedBitStreamParser4.ECI_GENERAL_PURPOSE:
          codeIndex += 2;
          break;
        case DecodedBitStreamParser4.ECI_USER_DEFINED:
          codeIndex++;
          break;
        case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          codeIndex = DecodedBitStreamParser4.decodeMacroBlock(codewords, codeIndex, resultMetadata);
          break;
        case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
        case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
          throw new FormatException_default();
        default:
          codeIndex--;
          codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, result);
          break;
      }
      if (codeIndex < codewords.length) {
        code = codewords[codeIndex++];
      } else {
        throw FormatException_default.getFormatInstance();
      }
    }
    if (result.length() === 0) {
      throw FormatException_default.getFormatInstance();
    }
    var decoderResult = new DecoderResult_default(null, result.toString(), null, ecLevel);
    decoderResult.setOther(resultMetadata);
    return decoderResult;
  };
  DecodedBitStreamParser4.decodeMacroBlock = function(codewords, codeIndex, resultMetadata) {
    if (codeIndex + DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
      throw FormatException_default.getFormatInstance();
    }
    var segmentIndexArray = new Int32Array(DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS);
    for (var i = 0; i < DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
      segmentIndexArray[i] = codewords[codeIndex];
    }
    resultMetadata.setSegmentIndex(Integer_default.parseInt(DecodedBitStreamParser4.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS)));
    var fileId = new StringBuilder_default();
    codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex, fileId);
    resultMetadata.setFileId(fileId.toString());
    var optionalFieldsStart = -1;
    if (codewords[codeIndex] === DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
      optionalFieldsStart = codeIndex + 1;
    }
    while (codeIndex < codewords[0]) {
      switch (codewords[codeIndex]) {
        case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          codeIndex++;
          switch (codewords[codeIndex]) {
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
              var fileName = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, fileName);
              resultMetadata.setFileName(fileName.toString());
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
              var sender = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, sender);
              resultMetadata.setSender(sender.toString());
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
              var addressee = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.textCompaction(codewords, codeIndex + 1, addressee);
              resultMetadata.setAddressee(addressee.toString());
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
              var segmentCount = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, segmentCount);
              resultMetadata.setSegmentCount(Integer_default.parseInt(segmentCount.toString()));
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
              var timestamp = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, timestamp);
              resultMetadata.setTimestamp(Long_default.parseLong(timestamp.toString()));
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
              var checksum = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, checksum);
              resultMetadata.setChecksum(Integer_default.parseInt(checksum.toString()));
              break;
            case DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
              var fileSize = new StringBuilder_default();
              codeIndex = DecodedBitStreamParser4.numericCompaction(codewords, codeIndex + 1, fileSize);
              resultMetadata.setFileSize(Long_default.parseLong(fileSize.toString()));
              break;
            default:
              throw FormatException_default.getFormatInstance();
          }
          break;
        case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
          codeIndex++;
          resultMetadata.setLastSegment(true);
          break;
        default:
          throw FormatException_default.getFormatInstance();
      }
    }
    if (optionalFieldsStart !== -1) {
      var optionalFieldsLength = codeIndex - optionalFieldsStart;
      if (resultMetadata.isLastSegment()) {
        optionalFieldsLength--;
      }
      resultMetadata.setOptionalData(Arrays_default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
    }
    return codeIndex;
  };
  DecodedBitStreamParser4.textCompaction = function(codewords, codeIndex, result) {
    var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
    var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
    var index = 0;
    var end = false;
    while (codeIndex < codewords[0] && !end) {
      var code = codewords[codeIndex++];
      if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
        textCompactionData[index] = code / 30;
        textCompactionData[index + 1] = code % 30;
        index += 2;
      } else {
        switch (code) {
          case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
            textCompactionData[index++] = DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH;
            break;
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
          case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
          case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
            codeIndex--;
            end = true;
            break;
          case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
            textCompactionData[index] = DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
            code = codewords[codeIndex++];
            byteCompactionData[index] = code;
            index++;
            break;
        }
      }
    }
    DecodedBitStreamParser4.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
    return codeIndex;
  };
  DecodedBitStreamParser4.decodeTextCompaction = function(textCompactionData, byteCompactionData, length, result) {
    var subMode = Mode3.ALPHA;
    var priorToShiftMode = Mode3.ALPHA;
    var i = 0;
    while (i < length) {
      var subModeCh = textCompactionData[i];
      var ch = "";
      switch (subMode) {
        case Mode3.ALPHA:
          if (subModeCh < 26) {
            ch = String.fromCharCode(65 + subModeCh);
          } else {
            switch (subModeCh) {
              case 26:
                ch = " ";
                break;
              case DecodedBitStreamParser4.LL:
                subMode = Mode3.LOWER;
                break;
              case DecodedBitStreamParser4.ML:
                subMode = Mode3.MIXED;
                break;
              case DecodedBitStreamParser4.PS:
                priorToShiftMode = subMode;
                subMode = Mode3.PUNCT_SHIFT;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(byteCompactionData[i]);
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
        case Mode3.LOWER:
          if (subModeCh < 26) {
            ch = String.fromCharCode(97 + subModeCh);
          } else {
            switch (subModeCh) {
              case 26:
                ch = " ";
                break;
              case DecodedBitStreamParser4.AS:
                priorToShiftMode = subMode;
                subMode = Mode3.ALPHA_SHIFT;
                break;
              case DecodedBitStreamParser4.ML:
                subMode = Mode3.MIXED;
                break;
              case DecodedBitStreamParser4.PS:
                priorToShiftMode = subMode;
                subMode = Mode3.PUNCT_SHIFT;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(byteCompactionData[i]);
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
        case Mode3.MIXED:
          if (subModeCh < DecodedBitStreamParser4.PL) {
            ch = DecodedBitStreamParser4.MIXED_CHARS[subModeCh];
          } else {
            switch (subModeCh) {
              case DecodedBitStreamParser4.PL:
                subMode = Mode3.PUNCT;
                break;
              case 26:
                ch = " ";
                break;
              case DecodedBitStreamParser4.LL:
                subMode = Mode3.LOWER;
                break;
              case DecodedBitStreamParser4.AL:
                subMode = Mode3.ALPHA;
                break;
              case DecodedBitStreamParser4.PS:
                priorToShiftMode = subMode;
                subMode = Mode3.PUNCT_SHIFT;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(byteCompactionData[i]);
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
        case Mode3.PUNCT:
          if (subModeCh < DecodedBitStreamParser4.PAL) {
            ch = DecodedBitStreamParser4.PUNCT_CHARS[subModeCh];
          } else {
            switch (subModeCh) {
              case DecodedBitStreamParser4.PAL:
                subMode = Mode3.ALPHA;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(byteCompactionData[i]);
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
        case Mode3.ALPHA_SHIFT:
          subMode = priorToShiftMode;
          if (subModeCh < 26) {
            ch = String.fromCharCode(65 + subModeCh);
          } else {
            switch (subModeCh) {
              case 26:
                ch = " ";
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
        case Mode3.PUNCT_SHIFT:
          subMode = priorToShiftMode;
          if (subModeCh < DecodedBitStreamParser4.PAL) {
            ch = DecodedBitStreamParser4.PUNCT_CHARS[subModeCh];
          } else {
            switch (subModeCh) {
              case DecodedBitStreamParser4.PAL:
                subMode = Mode3.ALPHA;
                break;
              case DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                result.append(byteCompactionData[i]);
                break;
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
                subMode = Mode3.ALPHA;
                break;
            }
          }
          break;
      }
      if (ch !== "") {
        result.append(ch);
      }
      i++;
    }
  };
  DecodedBitStreamParser4.byteCompaction = function(mode, codewords, encoding2, codeIndex, result) {
    var decodedBytes = new ByteArrayOutputStream_default();
    var count = 0;
    var value = 0;
    var end = false;
    switch (mode) {
      case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
        var byteCompactedCodewords = new Int32Array(6);
        var nextCode = codewords[codeIndex++];
        while (codeIndex < codewords[0] && !end) {
          byteCompactedCodewords[count++] = nextCode;
          value = 900 * value + nextCode;
          nextCode = codewords[codeIndex++];
          switch (nextCode) {
            case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
            case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
            case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
              codeIndex--;
              end = true;
              break;
            default:
              if (count % 5 === 0 && count > 0) {
                for (var j = 0; j < 6; ++j) {
                  decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                }
                value = 0;
                count = 0;
              }
              break;
          }
        }
        if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
          byteCompactedCodewords[count++] = nextCode;
        }
        for (var i = 0; i < count; i++) {
          decodedBytes.write(byteCompactedCodewords[i]);
        }
        break;
      case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
        while (codeIndex < codewords[0] && !end) {
          var code = codewords[codeIndex++];
          if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
            count++;
            value = 900 * value + code;
          } else {
            switch (code) {
              case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
            }
          }
          if (count % 5 === 0 && count > 0) {
            for (var j = 0; j < 6; ++j) {
              decodedBytes.write(Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
            }
            value = 0;
            count = 0;
          }
        }
        break;
    }
    result.append(StringEncoding_default.decode(decodedBytes.toByteArray(), encoding2));
    return codeIndex;
  };
  DecodedBitStreamParser4.numericCompaction = function(codewords, codeIndex, result) {
    var count = 0;
    var end = false;
    var numericCodewords = new Int32Array(DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS);
    while (codeIndex < codewords[0] && !end) {
      var code = codewords[codeIndex++];
      if (codeIndex === codewords[0]) {
        end = true;
      }
      if (code < DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH) {
        numericCodewords[count] = code;
        count++;
      } else {
        switch (code) {
          case DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH:
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH:
          case DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6:
          case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
          case DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
          case DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR:
            codeIndex--;
            end = true;
            break;
        }
      }
      if ((count % DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
        result.append(DecodedBitStreamParser4.decodeBase900toBase10(numericCodewords, count));
        count = 0;
      }
    }
    return codeIndex;
  };
  DecodedBitStreamParser4.decodeBase900toBase10 = function(codewords, count) {
    var result = createBigInt(0);
    for (var i = 0; i < count; i++) {
      result += DecodedBitStreamParser4.EXP900[count - i - 1] * createBigInt(codewords[i]);
    }
    var resultString = result.toString();
    if (resultString.charAt(0) !== "1") {
      throw new FormatException_default();
    }
    return resultString.substring(1);
  };
  DecodedBitStreamParser4.TEXT_COMPACTION_MODE_LATCH = 900;
  DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH = 901;
  DecodedBitStreamParser4.NUMERIC_COMPACTION_MODE_LATCH = 902;
  DecodedBitStreamParser4.BYTE_COMPACTION_MODE_LATCH_6 = 924;
  DecodedBitStreamParser4.ECI_USER_DEFINED = 925;
  DecodedBitStreamParser4.ECI_GENERAL_PURPOSE = 926;
  DecodedBitStreamParser4.ECI_CHARSET = 927;
  DecodedBitStreamParser4.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
  DecodedBitStreamParser4.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
  DecodedBitStreamParser4.MACRO_PDF417_TERMINATOR = 922;
  DecodedBitStreamParser4.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
  DecodedBitStreamParser4.MAX_NUMERIC_CODEWORDS = 15;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
  DecodedBitStreamParser4.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
  DecodedBitStreamParser4.PL = 25;
  DecodedBitStreamParser4.LL = 27;
  DecodedBitStreamParser4.AS = 27;
  DecodedBitStreamParser4.ML = 28;
  DecodedBitStreamParser4.AL = 28;
  DecodedBitStreamParser4.PS = 29;
  DecodedBitStreamParser4.PAL = 29;
  DecodedBitStreamParser4.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
  DecodedBitStreamParser4.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
  DecodedBitStreamParser4.EXP900 = getBigIntConstructor() ? getEXP900() : [];
  DecodedBitStreamParser4.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
  return DecodedBitStreamParser4;
}();
var DecodedBitStreamParser_default3 = DecodedBitStreamParser3;

// node_modules/@zxing/library/esm/core/pdf417/decoder/PDF417ScanningDecoder.js
var __values35 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var PDF417ScanningDecoder = function() {
  function PDF417ScanningDecoder2() {
  }
  PDF417ScanningDecoder2.decode = function(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
    var boundingBox = new BoundingBox_default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
    var leftRowIndicatorColumn = null;
    var rightRowIndicatorColumn = null;
    var detectionResult;
    for (var firstPass = true; ; firstPass = false) {
      if (imageTopLeft != null) {
        leftRowIndicatorColumn = PDF417ScanningDecoder2.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
      }
      if (imageTopRight != null) {
        rightRowIndicatorColumn = PDF417ScanningDecoder2.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
      }
      detectionResult = PDF417ScanningDecoder2.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
      if (detectionResult == null) {
        throw NotFoundException_default.getNotFoundInstance();
      }
      var resultBox = detectionResult.getBoundingBox();
      if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
        boundingBox = resultBox;
      } else {
        break;
      }
    }
    detectionResult.setBoundingBox(boundingBox);
    var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
    detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
    detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
    var leftToRight = leftRowIndicatorColumn != null;
    for (var barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
      var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
      if (detectionResult.getDetectionResultColumn(barcodeColumn) !== void 0) {
        continue;
      }
      var detectionResultColumn = void 0;
      if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
        detectionResultColumn = new DetectionResultRowIndicatorColumn_default(boundingBox, barcodeColumn === 0);
      } else {
        detectionResultColumn = new DetectionResultColumn_default(boundingBox);
      }
      detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
      var startColumn = -1;
      var previousStartColumn = startColumn;
      for (var imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
        startColumn = PDF417ScanningDecoder2.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
        if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
          if (previousStartColumn === -1) {
            continue;
          }
          startColumn = previousStartColumn;
        }
        var codeword = PDF417ScanningDecoder2.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
        if (codeword != null) {
          detectionResultColumn.setCodeword(imageRow, codeword);
          previousStartColumn = startColumn;
          minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
          maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
        }
      }
    }
    return PDF417ScanningDecoder2.createDecoderResult(detectionResult);
  };
  PDF417ScanningDecoder2.merge = function(leftRowIndicatorColumn, rightRowIndicatorColumn) {
    if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
      return null;
    }
    var barcodeMetadata = PDF417ScanningDecoder2.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
    if (barcodeMetadata == null) {
      return null;
    }
    var boundingBox = BoundingBox_default.merge(PDF417ScanningDecoder2.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder2.adjustBoundingBox(rightRowIndicatorColumn));
    return new DetectionResult_default(barcodeMetadata, boundingBox);
  };
  PDF417ScanningDecoder2.adjustBoundingBox = function(rowIndicatorColumn) {
    var e_1, _a;
    if (rowIndicatorColumn == null) {
      return null;
    }
    var rowHeights = rowIndicatorColumn.getRowHeights();
    if (rowHeights == null) {
      return null;
    }
    var maxRowHeight = PDF417ScanningDecoder2.getMax(rowHeights);
    var missingStartRows = 0;
    try {
      for (var rowHeights_1 = __values35(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {
        var rowHeight = rowHeights_1_1.value;
        missingStartRows += maxRowHeight - rowHeight;
        if (rowHeight > 0) {
          break;
        }
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return))
          _a.call(rowHeights_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var codewords = rowIndicatorColumn.getCodewords();
    for (var row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
      missingStartRows--;
    }
    var missingEndRows = 0;
    for (var row = rowHeights.length - 1; row >= 0; row--) {
      missingEndRows += maxRowHeight - rowHeights[row];
      if (rowHeights[row] > 0) {
        break;
      }
    }
    for (var row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
      missingEndRows--;
    }
    return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
  };
  PDF417ScanningDecoder2.getMax = function(values) {
    var e_2, _a;
    var maxValue = -1;
    try {
      for (var values_1 = __values35(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
        var value = values_1_1.value;
        maxValue = Math.max(maxValue, value);
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (values_1_1 && !values_1_1.done && (_a = values_1.return))
          _a.call(values_1);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return maxValue;
  };
  PDF417ScanningDecoder2.getBarcodeMetadata = function(leftRowIndicatorColumn, rightRowIndicatorColumn) {
    var leftBarcodeMetadata;
    if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
      return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
    }
    var rightBarcodeMetadata;
    if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
      return leftBarcodeMetadata;
    }
    if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
      return null;
    }
    return leftBarcodeMetadata;
  };
  PDF417ScanningDecoder2.getRowIndicatorColumn = function(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
    var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_default(boundingBox, leftToRight);
    for (var i = 0; i < 2; i++) {
      var increment = i === 0 ? 1 : -1;
      var startColumn = Math.trunc(Math.trunc(startPoint.getX()));
      for (var imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
        var codeword = PDF417ScanningDecoder2.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
        if (codeword != null) {
          rowIndicatorColumn.setCodeword(imageRow, codeword);
          if (leftToRight) {
            startColumn = codeword.getStartX();
          } else {
            startColumn = codeword.getEndX();
          }
        }
      }
    }
    return rowIndicatorColumn;
  };
  PDF417ScanningDecoder2.adjustCodewordCount = function(detectionResult, barcodeMatrix) {
    var barcodeMatrix01 = barcodeMatrix[0][1];
    var numberOfCodewords = barcodeMatrix01.getValue();
    var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder2.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
    if (numberOfCodewords.length === 0) {
      if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_default.MAX_CODEWORDS_IN_BARCODE) {
        throw NotFoundException_default.getNotFoundInstance();
      }
      barcodeMatrix01.setValue(calculatedNumberOfCodewords);
    } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
      barcodeMatrix01.setValue(calculatedNumberOfCodewords);
    }
  };
  PDF417ScanningDecoder2.createDecoderResult = function(detectionResult) {
    var barcodeMatrix = PDF417ScanningDecoder2.createBarcodeMatrix(detectionResult);
    PDF417ScanningDecoder2.adjustCodewordCount(detectionResult, barcodeMatrix);
    var erasures = new Array();
    var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
    var ambiguousIndexValuesList = [];
    var ambiguousIndexesList = new Array();
    for (var row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
      for (var column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
        var values = barcodeMatrix[row][column + 1].getValue();
        var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
        if (values.length === 0) {
          erasures.push(codewordIndex);
        } else if (values.length === 1) {
          codewords[codewordIndex] = values[0];
        } else {
          ambiguousIndexesList.push(codewordIndex);
          ambiguousIndexValuesList.push(values);
        }
      }
    }
    var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
    for (var i = 0; i < ambiguousIndexValues.length; i++) {
      ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
    }
    return PDF417ScanningDecoder2.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_default.toIntArray(erasures), PDF417Common_default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
  };
  PDF417ScanningDecoder2.createDecoderResultFromAmbiguousValues = function(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
    var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
    var tries = 100;
    while (tries-- > 0) {
      for (var i = 0; i < ambiguousIndexCount.length; i++) {
        codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
      }
      try {
        return PDF417ScanningDecoder2.decodeCodewords(codewords, ecLevel, erasureArray);
      } catch (err2) {
        var ignored = err2 instanceof ChecksumException_default;
        if (!ignored) {
          throw err2;
        }
      }
      if (ambiguousIndexCount.length === 0) {
        throw ChecksumException_default.getChecksumInstance();
      }
      for (var i = 0; i < ambiguousIndexCount.length; i++) {
        if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
          ambiguousIndexCount[i]++;
          break;
        } else {
          ambiguousIndexCount[i] = 0;
          if (i === ambiguousIndexCount.length - 1) {
            throw ChecksumException_default.getChecksumInstance();
          }
        }
      }
    }
    throw ChecksumException_default.getChecksumInstance();
  };
  PDF417ScanningDecoder2.createBarcodeMatrix = function(detectionResult) {
    var e_3, _a, e_4, _b;
    var barcodeMatrix = Array.from({length: detectionResult.getBarcodeRowCount()}, function() {
      return new Array(detectionResult.getBarcodeColumnCount() + 2);
    });
    for (var row = 0; row < barcodeMatrix.length; row++) {
      for (var column_1 = 0; column_1 < barcodeMatrix[row].length; column_1++) {
        barcodeMatrix[row][column_1] = new BarcodeValue_default();
      }
    }
    var column = 0;
    try {
      for (var _c = __values35(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {
        var detectionResultColumn = _d.value;
        if (detectionResultColumn != null) {
          try {
            for (var _e = (e_4 = void 0, __values35(detectionResultColumn.getCodewords())), _f = _e.next(); !_f.done; _f = _e.next()) {
              var codeword = _f.value;
              if (codeword != null) {
                var rowNumber = codeword.getRowNumber();
                if (rowNumber >= 0) {
                  if (rowNumber >= barcodeMatrix.length) {
                    continue;
                  }
                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                }
              }
            }
          } catch (e_4_1) {
            e_4 = {error: e_4_1};
          } finally {
            try {
              if (_f && !_f.done && (_b = _e.return))
                _b.call(_e);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
        }
        column++;
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return barcodeMatrix;
  };
  PDF417ScanningDecoder2.isValidBarcodeColumn = function(detectionResult, barcodeColumn) {
    return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
  };
  PDF417ScanningDecoder2.getStartColumn = function(detectionResult, barcodeColumn, imageRow, leftToRight) {
    var e_5, _a;
    var offset = leftToRight ? 1 : -1;
    var codeword = null;
    if (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
    }
    if (codeword != null) {
      return leftToRight ? codeword.getEndX() : codeword.getStartX();
    }
    codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
    if (codeword != null) {
      return leftToRight ? codeword.getStartX() : codeword.getEndX();
    }
    if (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
      codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
    }
    if (codeword != null) {
      return leftToRight ? codeword.getEndX() : codeword.getStartX();
    }
    var skippedColumns = 0;
    while (PDF417ScanningDecoder2.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
      barcodeColumn -= offset;
      try {
        for (var _b = (e_5 = void 0, __values35(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords())), _c = _b.next(); !_c.done; _c = _b.next()) {
          var previousRowCodeword = _c.value;
          if (previousRowCodeword != null) {
            return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
          }
        }
      } catch (e_5_1) {
        e_5 = {error: e_5_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      skippedColumns++;
    }
    return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
  };
  PDF417ScanningDecoder2.detectCodeword = function(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
    startColumn = PDF417ScanningDecoder2.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
    var moduleBitCount = PDF417ScanningDecoder2.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
    if (moduleBitCount == null) {
      return null;
    }
    var endColumn;
    var codewordBitCount = MathUtils_default.sum(moduleBitCount);
    if (leftToRight) {
      endColumn = startColumn + codewordBitCount;
    } else {
      for (var i = 0; i < moduleBitCount.length / 2; i++) {
        var tmpCount = moduleBitCount[i];
        moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
        moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
      }
      endColumn = startColumn;
      startColumn = endColumn - codewordBitCount;
    }
    if (!PDF417ScanningDecoder2.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
      return null;
    }
    var decodedValue = PDF417CodewordDecoder_default.getDecodedValue(moduleBitCount);
    var codeword = PDF417Common_default.getCodeword(decodedValue);
    if (codeword === -1) {
      return null;
    }
    return new Codeword_default(startColumn, endColumn, PDF417ScanningDecoder2.getCodewordBucketNumber(decodedValue), codeword);
  };
  PDF417ScanningDecoder2.getModuleBitCount = function(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
    var imageColumn = startColumn;
    var moduleBitCount = new Int32Array(8);
    var moduleNumber = 0;
    var increment = leftToRight ? 1 : -1;
    var previousPixelValue = leftToRight;
    while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
      if (image.get(imageColumn, imageRow) === previousPixelValue) {
        moduleBitCount[moduleNumber]++;
        imageColumn += increment;
      } else {
        moduleNumber++;
        previousPixelValue = !previousPixelValue;
      }
    }
    if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
      return moduleBitCount;
    }
    return null;
  };
  PDF417ScanningDecoder2.getNumberOfECCodeWords = function(barcodeECLevel) {
    return 2 << barcodeECLevel;
  };
  PDF417ScanningDecoder2.adjustCodewordStartColumn = function(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
    var correctedStartColumn = codewordStartColumn;
    var increment = leftToRight ? -1 : 1;
    for (var i = 0; i < 2; i++) {
      while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
        if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE) {
          return codewordStartColumn;
        }
        correctedStartColumn += increment;
      }
      increment = -increment;
      leftToRight = !leftToRight;
    }
    return correctedStartColumn;
  };
  PDF417ScanningDecoder2.checkCodewordSkew = function(codewordSize, minCodewordWidth, maxCodewordWidth) {
    return minCodewordWidth - PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE;
  };
  PDF417ScanningDecoder2.decodeCodewords = function(codewords, ecLevel, erasures) {
    if (codewords.length === 0) {
      throw FormatException_default.getFormatInstance();
    }
    var numECCodewords = 1 << ecLevel + 1;
    var correctedErrorsCount = PDF417ScanningDecoder2.correctErrors(codewords, erasures, numECCodewords);
    PDF417ScanningDecoder2.verifyCodewordCount(codewords, numECCodewords);
    var decoderResult = DecodedBitStreamParser_default3.decode(codewords, "" + ecLevel);
    decoderResult.setErrorsCorrected(correctedErrorsCount);
    decoderResult.setErasures(erasures.length);
    return decoderResult;
  };
  PDF417ScanningDecoder2.correctErrors = function(codewords, erasures, numECCodewords) {
    if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder2.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder2.MAX_EC_CODEWORDS) {
      throw ChecksumException_default.getChecksumInstance();
    }
    return PDF417ScanningDecoder2.errorCorrection.decode(codewords, numECCodewords, erasures);
  };
  PDF417ScanningDecoder2.verifyCodewordCount = function(codewords, numECCodewords) {
    if (codewords.length < 4) {
      throw FormatException_default.getFormatInstance();
    }
    var numberOfCodewords = codewords[0];
    if (numberOfCodewords > codewords.length) {
      throw FormatException_default.getFormatInstance();
    }
    if (numberOfCodewords === 0) {
      if (numECCodewords < codewords.length) {
        codewords[0] = codewords.length - numECCodewords;
      } else {
        throw FormatException_default.getFormatInstance();
      }
    }
  };
  PDF417ScanningDecoder2.getBitCountForCodeword = function(codeword) {
    var result = new Int32Array(8);
    var previousValue = 0;
    var i = result.length - 1;
    while (true) {
      if ((codeword & 1) !== previousValue) {
        previousValue = codeword & 1;
        i--;
        if (i < 0) {
          break;
        }
      }
      result[i]++;
      codeword >>= 1;
    }
    return result;
  };
  PDF417ScanningDecoder2.getCodewordBucketNumber = function(codeword) {
    if (codeword instanceof Int32Array) {
      return this.getCodewordBucketNumber_Int32Array(codeword);
    }
    return this.getCodewordBucketNumber_number(codeword);
  };
  PDF417ScanningDecoder2.getCodewordBucketNumber_number = function(codeword) {
    return PDF417ScanningDecoder2.getCodewordBucketNumber(PDF417ScanningDecoder2.getBitCountForCodeword(codeword));
  };
  PDF417ScanningDecoder2.getCodewordBucketNumber_Int32Array = function(moduleBitCount) {
    return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
  };
  PDF417ScanningDecoder2.toString = function(barcodeMatrix) {
    var formatter = new Formatter_default();
    for (var row = 0; row < barcodeMatrix.length; row++) {
      formatter.format("Row %2d: ", row);
      for (var column = 0; column < barcodeMatrix[row].length; column++) {
        var barcodeValue = barcodeMatrix[row][column];
        if (barcodeValue.getValue().length === 0) {
          formatter.format("        ", null);
        } else {
          formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
        }
      }
      formatter.format("%n");
    }
    return formatter.toString();
  };
  PDF417ScanningDecoder2.CODEWORD_SKEW_SIZE = 2;
  PDF417ScanningDecoder2.MAX_ERRORS = 3;
  PDF417ScanningDecoder2.MAX_EC_CODEWORDS = 512;
  PDF417ScanningDecoder2.errorCorrection = new ErrorCorrection_default();
  return PDF417ScanningDecoder2;
}();
var PDF417ScanningDecoder_default = PDF417ScanningDecoder;

// node_modules/@zxing/library/esm/core/pdf417/PDF417Reader.js
var __values36 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var PDF417Reader = function() {
  function PDF417Reader2() {
  }
  PDF417Reader2.prototype.decode = function(image, hints) {
    if (hints === void 0) {
      hints = null;
    }
    var result = PDF417Reader2.decode(image, hints, false);
    if (result == null || result.length === 0 || result[0] == null) {
      throw NotFoundException_default.getNotFoundInstance();
    }
    return result[0];
  };
  PDF417Reader2.prototype.decodeMultiple = function(image, hints) {
    if (hints === void 0) {
      hints = null;
    }
    try {
      return PDF417Reader2.decode(image, hints, true);
    } catch (ignored) {
      if (ignored instanceof FormatException_default || ignored instanceof ChecksumException_default) {
        throw NotFoundException_default.getNotFoundInstance();
      }
      throw ignored;
    }
  };
  PDF417Reader2.decode = function(image, hints, multiple) {
    var e_1, _a;
    var results = new Array();
    var detectorResult = Detector_default4.detectMultiple(image, hints, multiple);
    try {
      for (var _b = __values36(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var points = _c.value;
        var decoderResult = PDF417ScanningDecoder_default.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader2.getMinCodewordWidth(points), PDF417Reader2.getMaxCodewordWidth(points));
        var result = new Result_default(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat_default.PDF_417);
        result.putMetadata(ResultMetadataType_default.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
        var pdf417ResultMetadata = decoderResult.getOther();
        if (pdf417ResultMetadata != null) {
          result.putMetadata(ResultMetadataType_default.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
        }
        results.push(result);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return results.map(function(x2) {
      return x2;
    });
  };
  PDF417Reader2.getMaxWidth = function(p1, p2) {
    if (p1 == null || p2 == null) {
      return 0;
    }
    return Math.trunc(Math.abs(p1.getX() - p2.getX()));
  };
  PDF417Reader2.getMinWidth = function(p1, p2) {
    if (p1 == null || p2 == null) {
      return Integer_default.MAX_VALUE;
    }
    return Math.trunc(Math.abs(p1.getX() - p2.getX()));
  };
  PDF417Reader2.getMaxCodewordWidth = function(p) {
    return Math.floor(Math.max(Math.max(PDF417Reader2.getMaxWidth(p[0], p[4]), PDF417Reader2.getMaxWidth(p[6], p[2]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader2.getMaxWidth(p[1], p[5]), PDF417Reader2.getMaxWidth(p[7], p[3]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN)));
  };
  PDF417Reader2.getMinCodewordWidth = function(p) {
    return Math.floor(Math.min(Math.min(PDF417Reader2.getMinWidth(p[0], p[4]), PDF417Reader2.getMinWidth(p[6], p[2]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader2.getMinWidth(p[1], p[5]), PDF417Reader2.getMinWidth(p[7], p[3]) * PDF417Common_default.MODULES_IN_CODEWORD / PDF417Common_default.MODULES_IN_STOP_PATTERN)));
  };
  PDF417Reader2.prototype.reset = function() {
  };
  return PDF417Reader2;
}();
var PDF417Reader_default = PDF417Reader;

// node_modules/@zxing/library/esm/core/ReaderException.js
var __extends59 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ReaderException = function(_super) {
  __extends59(ReaderException2, _super);
  function ReaderException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ReaderException2.kind = "ReaderException";
  return ReaderException2;
}(Exception_default);
var ReaderException_default = ReaderException;

// node_modules/@zxing/library/esm/core/MultiFormatReader.js
var __values37 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var MultiFormatReader = function() {
  function MultiFormatReader2() {
  }
  MultiFormatReader2.prototype.decode = function(image, hints) {
    this.setHints(hints);
    return this.decodeInternal(image);
  };
  MultiFormatReader2.prototype.decodeWithState = function(image) {
    if (this.readers === null || this.readers === void 0) {
      this.setHints(null);
    }
    return this.decodeInternal(image);
  };
  MultiFormatReader2.prototype.setHints = function(hints) {
    this.hints = hints;
    var tryHarder = hints !== null && hints !== void 0 && hints.get(DecodeHintType_default.TRY_HARDER) !== void 0;
    var formats = hints === null || hints === void 0 ? null : hints.get(DecodeHintType_default.POSSIBLE_FORMATS);
    var readers = new Array();
    if (formats !== null && formats !== void 0) {
      var addOneDReader = formats.some(function(f) {
        return f === BarcodeFormat_default.UPC_A || f === BarcodeFormat_default.UPC_E || f === BarcodeFormat_default.EAN_13 || f === BarcodeFormat_default.EAN_8 || f === BarcodeFormat_default.CODABAR || f === BarcodeFormat_default.CODE_39 || f === BarcodeFormat_default.CODE_93 || f === BarcodeFormat_default.CODE_128 || f === BarcodeFormat_default.ITF || f === BarcodeFormat_default.RSS_14 || f === BarcodeFormat_default.RSS_EXPANDED;
      });
      if (addOneDReader && !tryHarder) {
        readers.push(new MultiFormatOneDReader_default(hints));
      }
      if (formats.includes(BarcodeFormat_default.QR_CODE)) {
        readers.push(new QRCodeReader_default());
      }
      if (formats.includes(BarcodeFormat_default.DATA_MATRIX)) {
        readers.push(new DataMatrixReader_default());
      }
      if (formats.includes(BarcodeFormat_default.AZTEC)) {
        readers.push(new AztecReader_default());
      }
      if (formats.includes(BarcodeFormat_default.PDF_417)) {
        readers.push(new PDF417Reader_default());
      }
      if (addOneDReader && tryHarder) {
        readers.push(new MultiFormatOneDReader_default(hints));
      }
    }
    if (readers.length === 0) {
      if (!tryHarder) {
        readers.push(new MultiFormatOneDReader_default(hints));
      }
      readers.push(new QRCodeReader_default());
      readers.push(new DataMatrixReader_default());
      readers.push(new AztecReader_default());
      readers.push(new PDF417Reader_default());
      if (tryHarder) {
        readers.push(new MultiFormatOneDReader_default(hints));
      }
    }
    this.readers = readers;
  };
  MultiFormatReader2.prototype.reset = function() {
    var e_1, _a;
    if (this.readers !== null) {
      try {
        for (var _b = __values37(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
          var reader = _c.value;
          reader.reset();
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
  };
  MultiFormatReader2.prototype.decodeInternal = function(image) {
    var e_2, _a;
    if (this.readers === null) {
      throw new ReaderException_default("No readers where selected, nothing can be read.");
    }
    try {
      for (var _b = __values37(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
        var reader = _c.value;
        try {
          return reader.decode(image, this.hints);
        } catch (ex) {
          if (ex instanceof ReaderException_default) {
            continue;
          }
        }
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    throw new NotFoundException_default("No MultiFormat Readers were able to detect the code.");
  };
  return MultiFormatReader2;
}();
var MultiFormatReader_default = MultiFormatReader;

// node_modules/@zxing/library/esm/browser/BrowserMultiFormatReader.js
var __extends60 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserMultiFormatReader = function(_super) {
  __extends60(BrowserMultiFormatReader2, _super);
  function BrowserMultiFormatReader2(hints, timeBetweenScansMillis) {
    if (hints === void 0) {
      hints = null;
    }
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    var _this = this;
    var reader = new MultiFormatReader_default();
    reader.setHints(hints);
    _this = _super.call(this, reader, timeBetweenScansMillis) || this;
    return _this;
  }
  BrowserMultiFormatReader2.prototype.decodeBitmap = function(binaryBitmap) {
    return this.reader.decodeWithState(binaryBitmap);
  };
  return BrowserMultiFormatReader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/browser/BrowserPDF417Reader.js
var __extends61 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserPDF417Reader = function(_super) {
  __extends61(BrowserPDF417Reader2, _super);
  function BrowserPDF417Reader2(timeBetweenScansMillis) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    return _super.call(this, new PDF417Reader_default(), timeBetweenScansMillis) || this;
  }
  return BrowserPDF417Reader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/browser/BrowserQRCodeReader.js
var __extends62 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BrowserQRCodeReader = function(_super) {
  __extends62(BrowserQRCodeReader2, _super);
  function BrowserQRCodeReader2(timeBetweenScansMillis) {
    if (timeBetweenScansMillis === void 0) {
      timeBetweenScansMillis = 500;
    }
    return _super.call(this, new QRCodeReader_default(), timeBetweenScansMillis) || this;
  }
  return BrowserQRCodeReader2;
}(BrowserCodeReader);

// node_modules/@zxing/library/esm/core/EncodeHintType.js
var EncodeHintType;
(function(EncodeHintType2) {
  EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
  EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
  EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
  EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
  EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
  EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
  EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
  EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
  EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
  EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
  EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
})(EncodeHintType || (EncodeHintType = {}));
var EncodeHintType_default = EncodeHintType;

// node_modules/@zxing/library/esm/core/common/reedsolomon/ReedSolomonEncoder.js
var ReedSolomonEncoder = function() {
  function ReedSolomonEncoder2(field) {
    this.field = field;
    this.cachedGenerators = [];
    this.cachedGenerators.push(new GenericGFPoly_default(field, Int32Array.from([1])));
  }
  ReedSolomonEncoder2.prototype.buildGenerator = function(degree) {
    var cachedGenerators = this.cachedGenerators;
    if (degree >= cachedGenerators.length) {
      var lastGenerator = cachedGenerators[cachedGenerators.length - 1];
      var field = this.field;
      for (var d = cachedGenerators.length; d <= degree; d++) {
        var nextGenerator = lastGenerator.multiply(new GenericGFPoly_default(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
        cachedGenerators.push(nextGenerator);
        lastGenerator = nextGenerator;
      }
    }
    return cachedGenerators[degree];
  };
  ReedSolomonEncoder2.prototype.encode = function(toEncode, ecBytes) {
    if (ecBytes === 0) {
      throw new IllegalArgumentException_default("No error correction bytes");
    }
    var dataBytes = toEncode.length - ecBytes;
    if (dataBytes <= 0) {
      throw new IllegalArgumentException_default("No data bytes provided");
    }
    var generator = this.buildGenerator(ecBytes);
    var infoCoefficients = new Int32Array(dataBytes);
    System_default.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
    var info = new GenericGFPoly_default(this.field, infoCoefficients);
    info = info.multiplyByMonomial(ecBytes, 1);
    var remainder = info.divide(generator)[1];
    var coefficients = remainder.getCoefficients();
    var numZeroCoefficients = ecBytes - coefficients.length;
    for (var i = 0; i < numZeroCoefficients; i++) {
      toEncode[dataBytes + i] = 0;
    }
    System_default.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
  };
  return ReedSolomonEncoder2;
}();
var ReedSolomonEncoder_default = ReedSolomonEncoder;

// node_modules/@zxing/library/esm/core/qrcode/encoder/MaskUtil.js
var MaskUtil = function() {
  function MaskUtil2() {
  }
  MaskUtil2.applyMaskPenaltyRule1 = function(matrix) {
    return MaskUtil2.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil2.applyMaskPenaltyRule1Internal(matrix, false);
  };
  MaskUtil2.applyMaskPenaltyRule2 = function(matrix) {
    var penalty = 0;
    var array = matrix.getArray();
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    for (var y = 0; y < height - 1; y++) {
      var arrayY = array[y];
      for (var x2 = 0; x2 < width - 1; x2++) {
        var value = arrayY[x2];
        if (value === arrayY[x2 + 1] && value === array[y + 1][x2] && value === array[y + 1][x2 + 1]) {
          penalty++;
        }
      }
    }
    return MaskUtil2.N2 * penalty;
  };
  MaskUtil2.applyMaskPenaltyRule3 = function(matrix) {
    var numPenalties = 0;
    var array = matrix.getArray();
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    for (var y = 0; y < height; y++) {
      for (var x2 = 0; x2 < width; x2++) {
        var arrayY = array[y];
        if (x2 + 6 < width && arrayY[x2] === 1 && arrayY[x2 + 1] === 0 && arrayY[x2 + 2] === 1 && arrayY[x2 + 3] === 1 && arrayY[x2 + 4] === 1 && arrayY[x2 + 5] === 0 && arrayY[x2 + 6] === 1 && (MaskUtil2.isWhiteHorizontal(arrayY, x2 - 4, x2) || MaskUtil2.isWhiteHorizontal(arrayY, x2 + 7, x2 + 11))) {
          numPenalties++;
        }
        if (y + 6 < height && array[y][x2] === 1 && array[y + 1][x2] === 0 && array[y + 2][x2] === 1 && array[y + 3][x2] === 1 && array[y + 4][x2] === 1 && array[y + 5][x2] === 0 && array[y + 6][x2] === 1 && (MaskUtil2.isWhiteVertical(array, x2, y - 4, y) || MaskUtil2.isWhiteVertical(array, x2, y + 7, y + 11))) {
          numPenalties++;
        }
      }
    }
    return numPenalties * MaskUtil2.N3;
  };
  MaskUtil2.isWhiteHorizontal = function(rowArray, from, to) {
    from = Math.max(from, 0);
    to = Math.min(to, rowArray.length);
    for (var i = from; i < to; i++) {
      if (rowArray[i] === 1) {
        return false;
      }
    }
    return true;
  };
  MaskUtil2.isWhiteVertical = function(array, col, from, to) {
    from = Math.max(from, 0);
    to = Math.min(to, array.length);
    for (var i = from; i < to; i++) {
      if (array[i][col] === 1) {
        return false;
      }
    }
    return true;
  };
  MaskUtil2.applyMaskPenaltyRule4 = function(matrix) {
    var numDarkCells = 0;
    var array = matrix.getArray();
    var width = matrix.getWidth();
    var height = matrix.getHeight();
    for (var y = 0; y < height; y++) {
      var arrayY = array[y];
      for (var x2 = 0; x2 < width; x2++) {
        if (arrayY[x2] === 1) {
          numDarkCells++;
        }
      }
    }
    var numTotalCells = matrix.getHeight() * matrix.getWidth();
    var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
    return fivePercentVariances * MaskUtil2.N4;
  };
  MaskUtil2.getDataMaskBit = function(maskPattern, x2, y) {
    var intermediate;
    var temp;
    switch (maskPattern) {
      case 0:
        intermediate = y + x2 & 1;
        break;
      case 1:
        intermediate = y & 1;
        break;
      case 2:
        intermediate = x2 % 3;
        break;
      case 3:
        intermediate = (y + x2) % 3;
        break;
      case 4:
        intermediate = Math.floor(y / 2) + Math.floor(x2 / 3) & 1;
        break;
      case 5:
        temp = y * x2;
        intermediate = (temp & 1) + temp % 3;
        break;
      case 6:
        temp = y * x2;
        intermediate = (temp & 1) + temp % 3 & 1;
        break;
      case 7:
        temp = y * x2;
        intermediate = temp % 3 + (y + x2 & 1) & 1;
        break;
      default:
        throw new IllegalArgumentException_default("Invalid mask pattern: " + maskPattern);
    }
    return intermediate === 0;
  };
  MaskUtil2.applyMaskPenaltyRule1Internal = function(matrix, isHorizontal) {
    var penalty = 0;
    var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
    var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
    var array = matrix.getArray();
    for (var i = 0; i < iLimit; i++) {
      var numSameBitCells = 0;
      var prevBit = -1;
      for (var j = 0; j < jLimit; j++) {
        var bit = isHorizontal ? array[i][j] : array[j][i];
        if (bit === prevBit) {
          numSameBitCells++;
        } else {
          if (numSameBitCells >= 5) {
            penalty += MaskUtil2.N1 + (numSameBitCells - 5);
          }
          numSameBitCells = 1;
          prevBit = bit;
        }
      }
      if (numSameBitCells >= 5) {
        penalty += MaskUtil2.N1 + (numSameBitCells - 5);
      }
    }
    return penalty;
  };
  MaskUtil2.N1 = 3;
  MaskUtil2.N2 = 3;
  MaskUtil2.N3 = 40;
  MaskUtil2.N4 = 10;
  return MaskUtil2;
}();
var MaskUtil_default = MaskUtil;

// node_modules/@zxing/library/esm/core/qrcode/encoder/ByteMatrix.js
var __values38 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var ByteMatrix = function() {
  function ByteMatrix2(width, height) {
    this.width = width;
    this.height = height;
    var bytes = new Array(height);
    for (var i = 0; i !== height; i++) {
      bytes[i] = new Uint8Array(width);
    }
    this.bytes = bytes;
  }
  ByteMatrix2.prototype.getHeight = function() {
    return this.height;
  };
  ByteMatrix2.prototype.getWidth = function() {
    return this.width;
  };
  ByteMatrix2.prototype.get = function(x2, y) {
    return this.bytes[y][x2];
  };
  ByteMatrix2.prototype.getArray = function() {
    return this.bytes;
  };
  ByteMatrix2.prototype.setNumber = function(x2, y, value) {
    this.bytes[y][x2] = value;
  };
  ByteMatrix2.prototype.setBoolean = function(x2, y, value) {
    this.bytes[y][x2] = value ? 1 : 0;
  };
  ByteMatrix2.prototype.clear = function(value) {
    var e_1, _a;
    try {
      for (var _b = __values38(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {
        var aByte = _c.value;
        Arrays_default.fill(aByte, value);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  ByteMatrix2.prototype.equals = function(o) {
    if (!(o instanceof ByteMatrix2)) {
      return false;
    }
    var other = o;
    if (this.width !== other.width) {
      return false;
    }
    if (this.height !== other.height) {
      return false;
    }
    for (var y = 0, height = this.height; y < height; ++y) {
      var bytesY = this.bytes[y];
      var otherBytesY = other.bytes[y];
      for (var x2 = 0, width = this.width; x2 < width; ++x2) {
        if (bytesY[x2] !== otherBytesY[x2]) {
          return false;
        }
      }
    }
    return true;
  };
  ByteMatrix2.prototype.toString = function() {
    var result = new StringBuilder_default();
    for (var y = 0, height = this.height; y < height; ++y) {
      var bytesY = this.bytes[y];
      for (var x2 = 0, width = this.width; x2 < width; ++x2) {
        switch (bytesY[x2]) {
          case 0:
            result.append(" 0");
            break;
          case 1:
            result.append(" 1");
            break;
          default:
            result.append("  ");
            break;
        }
      }
      result.append("\n");
    }
    return result.toString();
  };
  return ByteMatrix2;
}();
var ByteMatrix_default = ByteMatrix;

// node_modules/@zxing/library/esm/core/qrcode/encoder/QRCode.js
var QRCode = function() {
  function QRCode2() {
    this.maskPattern = -1;
  }
  QRCode2.prototype.getMode = function() {
    return this.mode;
  };
  QRCode2.prototype.getECLevel = function() {
    return this.ecLevel;
  };
  QRCode2.prototype.getVersion = function() {
    return this.version;
  };
  QRCode2.prototype.getMaskPattern = function() {
    return this.maskPattern;
  };
  QRCode2.prototype.getMatrix = function() {
    return this.matrix;
  };
  QRCode2.prototype.toString = function() {
    var result = new StringBuilder_default();
    result.append("<<\n");
    result.append(" mode: ");
    result.append(this.mode ? this.mode.toString() : "null");
    result.append("\n ecLevel: ");
    result.append(this.ecLevel ? this.ecLevel.toString() : "null");
    result.append("\n version: ");
    result.append(this.version ? this.version.toString() : "null");
    result.append("\n maskPattern: ");
    result.append(this.maskPattern.toString());
    if (this.matrix) {
      result.append("\n matrix:\n");
      result.append(this.matrix.toString());
    } else {
      result.append("\n matrix: null\n");
    }
    result.append(">>\n");
    return result.toString();
  };
  QRCode2.prototype.setMode = function(value) {
    this.mode = value;
  };
  QRCode2.prototype.setECLevel = function(value) {
    this.ecLevel = value;
  };
  QRCode2.prototype.setVersion = function(version) {
    this.version = version;
  };
  QRCode2.prototype.setMaskPattern = function(value) {
    this.maskPattern = value;
  };
  QRCode2.prototype.setMatrix = function(value) {
    this.matrix = value;
  };
  QRCode2.isValidMaskPattern = function(maskPattern) {
    return maskPattern >= 0 && maskPattern < QRCode2.NUM_MASK_PATTERNS;
  };
  QRCode2.NUM_MASK_PATTERNS = 8;
  return QRCode2;
}();
var QRCode_default = QRCode;

// node_modules/@zxing/library/esm/core/WriterException.js
var __extends63 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WriterException = function(_super) {
  __extends63(WriterException2, _super);
  function WriterException2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  WriterException2.kind = "WriterException";
  return WriterException2;
}(Exception_default);
var WriterException_default = WriterException;

// node_modules/@zxing/library/esm/core/qrcode/encoder/MatrixUtil.js
var MatrixUtil = function() {
  function MatrixUtil2() {
  }
  MatrixUtil2.clearMatrix = function(matrix) {
    matrix.clear(255);
  };
  MatrixUtil2.buildMatrix = function(dataBits, ecLevel, version, maskPattern, matrix) {
    MatrixUtil2.clearMatrix(matrix);
    MatrixUtil2.embedBasicPatterns(version, matrix);
    MatrixUtil2.embedTypeInfo(ecLevel, maskPattern, matrix);
    MatrixUtil2.maybeEmbedVersionInfo(version, matrix);
    MatrixUtil2.embedDataBits(dataBits, maskPattern, matrix);
  };
  MatrixUtil2.embedBasicPatterns = function(version, matrix) {
    MatrixUtil2.embedPositionDetectionPatternsAndSeparators(matrix);
    MatrixUtil2.embedDarkDotAtLeftBottomCorner(matrix);
    MatrixUtil2.maybeEmbedPositionAdjustmentPatterns(version, matrix);
    MatrixUtil2.embedTimingPatterns(matrix);
  };
  MatrixUtil2.embedTypeInfo = function(ecLevel, maskPattern, matrix) {
    var typeInfoBits = new BitArray_default();
    MatrixUtil2.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
    for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
      var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
      var coordinates = MatrixUtil2.TYPE_INFO_COORDINATES[i];
      var x1 = coordinates[0];
      var y1 = coordinates[1];
      matrix.setBoolean(x1, y1, bit);
      if (i < 8) {
        var x2 = matrix.getWidth() - i - 1;
        var y2 = 8;
        matrix.setBoolean(x2, y2, bit);
      } else {
        var x2 = 8;
        var y2 = matrix.getHeight() - 7 + (i - 8);
        matrix.setBoolean(x2, y2, bit);
      }
    }
  };
  MatrixUtil2.maybeEmbedVersionInfo = function(version, matrix) {
    if (version.getVersionNumber() < 7) {
      return;
    }
    var versionInfoBits = new BitArray_default();
    MatrixUtil2.makeVersionInfoBits(version, versionInfoBits);
    var bitIndex = 6 * 3 - 1;
    for (var i = 0; i < 6; ++i) {
      for (var j = 0; j < 3; ++j) {
        var bit = versionInfoBits.get(bitIndex);
        bitIndex--;
        matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
        matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
      }
    }
  };
  MatrixUtil2.embedDataBits = function(dataBits, maskPattern, matrix) {
    var bitIndex = 0;
    var direction = -1;
    var x2 = matrix.getWidth() - 1;
    var y = matrix.getHeight() - 1;
    while (x2 > 0) {
      if (x2 === 6) {
        x2 -= 1;
      }
      while (y >= 0 && y < matrix.getHeight()) {
        for (var i = 0; i < 2; ++i) {
          var xx = x2 - i;
          if (!MatrixUtil2.isEmpty(matrix.get(xx, y))) {
            continue;
          }
          var bit = void 0;
          if (bitIndex < dataBits.getSize()) {
            bit = dataBits.get(bitIndex);
            ++bitIndex;
          } else {
            bit = false;
          }
          if (maskPattern !== 255 && MaskUtil_default.getDataMaskBit(maskPattern, xx, y)) {
            bit = !bit;
          }
          matrix.setBoolean(xx, y, bit);
        }
        y += direction;
      }
      direction = -direction;
      y += direction;
      x2 -= 2;
    }
    if (bitIndex !== dataBits.getSize()) {
      throw new WriterException_default("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
    }
  };
  MatrixUtil2.findMSBSet = function(value) {
    return 32 - Integer_default.numberOfLeadingZeros(value);
  };
  MatrixUtil2.calculateBCHCode = function(value, poly) {
    if (poly === 0) {
      throw new IllegalArgumentException_default("0 polynomial");
    }
    var msbSetInPoly = MatrixUtil2.findMSBSet(poly);
    value <<= msbSetInPoly - 1;
    while (MatrixUtil2.findMSBSet(value) >= msbSetInPoly) {
      value ^= poly << MatrixUtil2.findMSBSet(value) - msbSetInPoly;
    }
    return value;
  };
  MatrixUtil2.makeTypeInfoBits = function(ecLevel, maskPattern, bits) {
    if (!QRCode_default.isValidMaskPattern(maskPattern)) {
      throw new WriterException_default("Invalid mask pattern");
    }
    var typeInfo = ecLevel.getBits() << 3 | maskPattern;
    bits.appendBits(typeInfo, 5);
    var bchCode = MatrixUtil2.calculateBCHCode(typeInfo, MatrixUtil2.TYPE_INFO_POLY);
    bits.appendBits(bchCode, 10);
    var maskBits = new BitArray_default();
    maskBits.appendBits(MatrixUtil2.TYPE_INFO_MASK_PATTERN, 15);
    bits.xor(maskBits);
    if (bits.getSize() !== 15) {
      throw new WriterException_default("should not happen but we got: " + bits.getSize());
    }
  };
  MatrixUtil2.makeVersionInfoBits = function(version, bits) {
    bits.appendBits(version.getVersionNumber(), 6);
    var bchCode = MatrixUtil2.calculateBCHCode(version.getVersionNumber(), MatrixUtil2.VERSION_INFO_POLY);
    bits.appendBits(bchCode, 12);
    if (bits.getSize() !== 18) {
      throw new WriterException_default("should not happen but we got: " + bits.getSize());
    }
  };
  MatrixUtil2.isEmpty = function(value) {
    return value === 255;
  };
  MatrixUtil2.embedTimingPatterns = function(matrix) {
    for (var i = 8; i < matrix.getWidth() - 8; ++i) {
      var bit = (i + 1) % 2;
      if (MatrixUtil2.isEmpty(matrix.get(i, 6))) {
        matrix.setNumber(i, 6, bit);
      }
      if (MatrixUtil2.isEmpty(matrix.get(6, i))) {
        matrix.setNumber(6, i, bit);
      }
    }
  };
  MatrixUtil2.embedDarkDotAtLeftBottomCorner = function(matrix) {
    if (matrix.get(8, matrix.getHeight() - 8) === 0) {
      throw new WriterException_default();
    }
    matrix.setNumber(8, matrix.getHeight() - 8, 1);
  };
  MatrixUtil2.embedHorizontalSeparationPattern = function(xStart, yStart, matrix) {
    for (var x2 = 0; x2 < 8; ++x2) {
      if (!MatrixUtil2.isEmpty(matrix.get(xStart + x2, yStart))) {
        throw new WriterException_default();
      }
      matrix.setNumber(xStart + x2, yStart, 0);
    }
  };
  MatrixUtil2.embedVerticalSeparationPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 7; ++y) {
      if (!MatrixUtil2.isEmpty(matrix.get(xStart, yStart + y))) {
        throw new WriterException_default();
      }
      matrix.setNumber(xStart, yStart + y, 0);
    }
  };
  MatrixUtil2.embedPositionAdjustmentPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 5; ++y) {
      var patternY = MatrixUtil2.POSITION_ADJUSTMENT_PATTERN[y];
      for (var x2 = 0; x2 < 5; ++x2) {
        matrix.setNumber(xStart + x2, yStart + y, patternY[x2]);
      }
    }
  };
  MatrixUtil2.embedPositionDetectionPattern = function(xStart, yStart, matrix) {
    for (var y = 0; y < 7; ++y) {
      var patternY = MatrixUtil2.POSITION_DETECTION_PATTERN[y];
      for (var x2 = 0; x2 < 7; ++x2) {
        matrix.setNumber(xStart + x2, yStart + y, patternY[x2]);
      }
    }
  };
  MatrixUtil2.embedPositionDetectionPatternsAndSeparators = function(matrix) {
    var pdpWidth = MatrixUtil2.POSITION_DETECTION_PATTERN[0].length;
    MatrixUtil2.embedPositionDetectionPattern(0, 0, matrix);
    MatrixUtil2.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
    MatrixUtil2.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
    var hspWidth = 8;
    MatrixUtil2.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
    MatrixUtil2.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
    MatrixUtil2.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
    var vspSize = 7;
    MatrixUtil2.embedVerticalSeparationPattern(vspSize, 0, matrix);
    MatrixUtil2.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
    MatrixUtil2.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
  };
  MatrixUtil2.maybeEmbedPositionAdjustmentPatterns = function(version, matrix) {
    if (version.getVersionNumber() < 2) {
      return;
    }
    var index = version.getVersionNumber() - 1;
    var coordinates = MatrixUtil2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
    for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {
      var y = coordinates[i];
      if (y >= 0) {
        for (var j = 0; j !== length_1; j++) {
          var x2 = coordinates[j];
          if (x2 >= 0 && MatrixUtil2.isEmpty(matrix.get(x2, y))) {
            MatrixUtil2.embedPositionAdjustmentPattern(x2 - 2, y - 2, matrix);
          }
        }
      }
    }
  };
  MatrixUtil2.POSITION_DETECTION_PATTERN = Array.from([
    Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
    Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
    Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
    Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
    Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
    Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
    Int32Array.from([1, 1, 1, 1, 1, 1, 1])
  ]);
  MatrixUtil2.POSITION_ADJUSTMENT_PATTERN = Array.from([
    Int32Array.from([1, 1, 1, 1, 1]),
    Int32Array.from([1, 0, 0, 0, 1]),
    Int32Array.from([1, 0, 1, 0, 1]),
    Int32Array.from([1, 0, 0, 0, 1]),
    Int32Array.from([1, 1, 1, 1, 1])
  ]);
  MatrixUtil2.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
    Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
    Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
    Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
    Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
    Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
    Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
    Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
    Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
    Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
    Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
    Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
    Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
    Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
    Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
    Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
    Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
    Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
    Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
    Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
    Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
    Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
    Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
    Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
    Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
    Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
    Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
    Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
    Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
    Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
    Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
    Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
    Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
    Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
    Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
    Int32Array.from([6, 30, 58, 86, 114, 142, 170])
  ]);
  MatrixUtil2.TYPE_INFO_COORDINATES = Array.from([
    Int32Array.from([8, 0]),
    Int32Array.from([8, 1]),
    Int32Array.from([8, 2]),
    Int32Array.from([8, 3]),
    Int32Array.from([8, 4]),
    Int32Array.from([8, 5]),
    Int32Array.from([8, 7]),
    Int32Array.from([8, 8]),
    Int32Array.from([7, 8]),
    Int32Array.from([5, 8]),
    Int32Array.from([4, 8]),
    Int32Array.from([3, 8]),
    Int32Array.from([2, 8]),
    Int32Array.from([1, 8]),
    Int32Array.from([0, 8])
  ]);
  MatrixUtil2.VERSION_INFO_POLY = 7973;
  MatrixUtil2.TYPE_INFO_POLY = 1335;
  MatrixUtil2.TYPE_INFO_MASK_PATTERN = 21522;
  return MatrixUtil2;
}();
var MatrixUtil_default = MatrixUtil;

// node_modules/@zxing/library/esm/core/qrcode/encoder/BlockPair.js
var BlockPair = function() {
  function BlockPair2(dataBytes, errorCorrectionBytes) {
    this.dataBytes = dataBytes;
    this.errorCorrectionBytes = errorCorrectionBytes;
  }
  BlockPair2.prototype.getDataBytes = function() {
    return this.dataBytes;
  };
  BlockPair2.prototype.getErrorCorrectionBytes = function() {
    return this.errorCorrectionBytes;
  };
  return BlockPair2;
}();
var BlockPair_default = BlockPair;

// node_modules/@zxing/library/esm/core/qrcode/encoder/Encoder.js
var __values39 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Encoder = function() {
  function Encoder3() {
  }
  Encoder3.calculateMaskPenalty = function(matrix) {
    return MaskUtil_default.applyMaskPenaltyRule1(matrix) + MaskUtil_default.applyMaskPenaltyRule2(matrix) + MaskUtil_default.applyMaskPenaltyRule3(matrix) + MaskUtil_default.applyMaskPenaltyRule4(matrix);
  };
  Encoder3.encode = function(content, ecLevel, hints) {
    if (hints === void 0) {
      hints = null;
    }
    var encoding2 = Encoder3.DEFAULT_BYTE_MODE_ENCODING;
    var hasEncodingHint = hints !== null && hints.get(EncodeHintType_default.CHARACTER_SET) !== void 0;
    if (hasEncodingHint) {
      encoding2 = hints.get(EncodeHintType_default.CHARACTER_SET).toString();
    }
    var mode = this.chooseMode(content, encoding2);
    var headerBits = new BitArray_default();
    if (mode === Mode_default.BYTE && (hasEncodingHint || Encoder3.DEFAULT_BYTE_MODE_ENCODING !== encoding2)) {
      var eci = CharacterSetECI_default.getCharacterSetECIByName(encoding2);
      if (eci !== void 0) {
        this.appendECI(eci, headerBits);
      }
    }
    this.appendModeInfo(mode, headerBits);
    var dataBits = new BitArray_default();
    this.appendBytes(content, mode, dataBits, encoding2);
    var version;
    if (hints !== null && hints.get(EncodeHintType_default.QR_VERSION) !== void 0) {
      var versionNumber = Number.parseInt(hints.get(EncodeHintType_default.QR_VERSION).toString(), 10);
      version = Version_default2.getVersionForNumber(versionNumber);
      var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
      if (!this.willFit(bitsNeeded, version, ecLevel)) {
        throw new WriterException_default("Data too big for requested version");
      }
    } else {
      version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
    }
    var headerAndDataBits = new BitArray_default();
    headerAndDataBits.appendBitArray(headerBits);
    var numLetters = mode === Mode_default.BYTE ? dataBits.getSizeInBytes() : content.length;
    this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
    headerAndDataBits.appendBitArray(dataBits);
    var ecBlocks = version.getECBlocksForLevel(ecLevel);
    var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
    this.terminateBits(numDataBytes, headerAndDataBits);
    var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
    var qrCode = new QRCode_default();
    qrCode.setECLevel(ecLevel);
    qrCode.setMode(mode);
    qrCode.setVersion(version);
    var dimension = version.getDimensionForVersion();
    var matrix = new ByteMatrix_default(dimension, dimension);
    var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
    qrCode.setMaskPattern(maskPattern);
    MatrixUtil_default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
    qrCode.setMatrix(matrix);
    return qrCode;
  };
  Encoder3.recommendVersion = function(ecLevel, mode, headerBits, dataBits) {
    var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_default2.getVersionForNumber(1));
    var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
    var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
    return this.chooseVersion(bitsNeeded, ecLevel);
  };
  Encoder3.calculateBitsNeeded = function(mode, headerBits, dataBits, version) {
    return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
  };
  Encoder3.getAlphanumericCode = function(code) {
    if (code < Encoder3.ALPHANUMERIC_TABLE.length) {
      return Encoder3.ALPHANUMERIC_TABLE[code];
    }
    return -1;
  };
  Encoder3.chooseMode = function(content, encoding2) {
    if (encoding2 === void 0) {
      encoding2 = null;
    }
    if (CharacterSetECI_default.SJIS.getName() === encoding2 && this.isOnlyDoubleByteKanji(content)) {
      return Mode_default.KANJI;
    }
    var hasNumeric = false;
    var hasAlphanumeric = false;
    for (var i = 0, length_1 = content.length; i < length_1; ++i) {
      var c = content.charAt(i);
      if (Encoder3.isDigit(c)) {
        hasNumeric = true;
      } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
        hasAlphanumeric = true;
      } else {
        return Mode_default.BYTE;
      }
    }
    if (hasAlphanumeric) {
      return Mode_default.ALPHANUMERIC;
    }
    if (hasNumeric) {
      return Mode_default.NUMERIC;
    }
    return Mode_default.BYTE;
  };
  Encoder3.isOnlyDoubleByteKanji = function(content) {
    var bytes;
    try {
      bytes = StringEncoding_default.encode(content, CharacterSetECI_default.SJIS);
    } catch (ignored) {
      return false;
    }
    var length = bytes.length;
    if (length % 2 !== 0) {
      return false;
    }
    for (var i = 0; i < length; i += 2) {
      var byte1 = bytes[i] & 255;
      if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
        return false;
      }
    }
    return true;
  };
  Encoder3.chooseMaskPattern = function(bits, ecLevel, version, matrix) {
    var minPenalty = Number.MAX_SAFE_INTEGER;
    var bestMaskPattern = -1;
    for (var maskPattern = 0; maskPattern < QRCode_default.NUM_MASK_PATTERNS; maskPattern++) {
      MatrixUtil_default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
      var penalty = this.calculateMaskPenalty(matrix);
      if (penalty < minPenalty) {
        minPenalty = penalty;
        bestMaskPattern = maskPattern;
      }
    }
    return bestMaskPattern;
  };
  Encoder3.chooseVersion = function(numInputBits, ecLevel) {
    for (var versionNum = 1; versionNum <= 40; versionNum++) {
      var version = Version_default2.getVersionForNumber(versionNum);
      if (Encoder3.willFit(numInputBits, version, ecLevel)) {
        return version;
      }
    }
    throw new WriterException_default("Data too big");
  };
  Encoder3.willFit = function(numInputBits, version, ecLevel) {
    var numBytes = version.getTotalCodewords();
    var ecBlocks = version.getECBlocksForLevel(ecLevel);
    var numEcBytes = ecBlocks.getTotalECCodewords();
    var numDataBytes = numBytes - numEcBytes;
    var totalInputBytes = (numInputBits + 7) / 8;
    return numDataBytes >= totalInputBytes;
  };
  Encoder3.terminateBits = function(numDataBytes, bits) {
    var capacity = numDataBytes * 8;
    if (bits.getSize() > capacity) {
      throw new WriterException_default("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
    }
    for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {
      bits.appendBit(false);
    }
    var numBitsInLastByte = bits.getSize() & 7;
    if (numBitsInLastByte > 0) {
      for (var i = numBitsInLastByte; i < 8; i++) {
        bits.appendBit(false);
      }
    }
    var numPaddingBytes = numDataBytes - bits.getSizeInBytes();
    for (var i = 0; i < numPaddingBytes; ++i) {
      bits.appendBits((i & 1) === 0 ? 236 : 17, 8);
    }
    if (bits.getSize() !== capacity) {
      throw new WriterException_default("Bits size does not equal capacity");
    }
  };
  Encoder3.getNumDataBytesAndNumECBytesForBlockID = function(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
    if (blockID >= numRSBlocks) {
      throw new WriterException_default("Block ID too large");
    }
    var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
    var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
    var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
    var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
    var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
    var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
    var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
    var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
    if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
      throw new WriterException_default("EC bytes mismatch");
    }
    if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
      throw new WriterException_default("RS blocks mismatch");
    }
    if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
      throw new WriterException_default("Total bytes mismatch");
    }
    if (blockID < numRsBlocksInGroup1) {
      numDataBytesInBlock[0] = numDataBytesInGroup1;
      numECBytesInBlock[0] = numEcBytesInGroup1;
    } else {
      numDataBytesInBlock[0] = numDataBytesInGroup2;
      numECBytesInBlock[0] = numEcBytesInGroup2;
    }
  };
  Encoder3.interleaveWithECBytes = function(bits, numTotalBytes, numDataBytes, numRSBlocks) {
    var e_1, _a, e_2, _b;
    if (bits.getSizeInBytes() !== numDataBytes) {
      throw new WriterException_default("Number of bits and data bytes does not match");
    }
    var dataBytesOffset = 0;
    var maxNumDataBytes = 0;
    var maxNumEcBytes = 0;
    var blocks = new Array();
    for (var i = 0; i < numRSBlocks; ++i) {
      var numDataBytesInBlock = new Int32Array(1);
      var numEcBytesInBlock = new Int32Array(1);
      Encoder3.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
      var size = numDataBytesInBlock[0];
      var dataBytes = new Uint8Array(size);
      bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
      var ecBytes = Encoder3.generateECBytes(dataBytes, numEcBytesInBlock[0]);
      blocks.push(new BlockPair_default(dataBytes, ecBytes));
      maxNumDataBytes = Math.max(maxNumDataBytes, size);
      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
      dataBytesOffset += numDataBytesInBlock[0];
    }
    if (numDataBytes !== dataBytesOffset) {
      throw new WriterException_default("Data bytes does not match offset");
    }
    var result = new BitArray_default();
    for (var i = 0; i < maxNumDataBytes; ++i) {
      try {
        for (var blocks_1 = (e_1 = void 0, __values39(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
          var block = blocks_1_1.value;
          var dataBytes = block.getDataBytes();
          if (i < dataBytes.length) {
            result.appendBits(dataBytes[i], 8);
          }
        }
      } catch (e_1_1) {
        e_1 = {error: e_1_1};
      } finally {
        try {
          if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return))
            _a.call(blocks_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    for (var i = 0; i < maxNumEcBytes; ++i) {
      try {
        for (var blocks_2 = (e_2 = void 0, __values39(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {
          var block = blocks_2_1.value;
          var ecBytes = block.getErrorCorrectionBytes();
          if (i < ecBytes.length) {
            result.appendBits(ecBytes[i], 8);
          }
        }
      } catch (e_2_1) {
        e_2 = {error: e_2_1};
      } finally {
        try {
          if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return))
            _b.call(blocks_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
    if (numTotalBytes !== result.getSizeInBytes()) {
      throw new WriterException_default("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
    }
    return result;
  };
  Encoder3.generateECBytes = function(dataBytes, numEcBytesInBlock) {
    var numDataBytes = dataBytes.length;
    var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
    for (var i = 0; i < numDataBytes; i++) {
      toEncode[i] = dataBytes[i] & 255;
    }
    new ReedSolomonEncoder_default(GenericGF_default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
    var ecBytes = new Uint8Array(numEcBytesInBlock);
    for (var i = 0; i < numEcBytesInBlock; i++) {
      ecBytes[i] = toEncode[numDataBytes + i];
    }
    return ecBytes;
  };
  Encoder3.appendModeInfo = function(mode, bits) {
    bits.appendBits(mode.getBits(), 4);
  };
  Encoder3.appendLengthInfo = function(numLetters, version, mode, bits) {
    var numBits = mode.getCharacterCountBits(version);
    if (numLetters >= 1 << numBits) {
      throw new WriterException_default(numLetters + " is bigger than " + ((1 << numBits) - 1));
    }
    bits.appendBits(numLetters, numBits);
  };
  Encoder3.appendBytes = function(content, mode, bits, encoding2) {
    switch (mode) {
      case Mode_default.NUMERIC:
        Encoder3.appendNumericBytes(content, bits);
        break;
      case Mode_default.ALPHANUMERIC:
        Encoder3.appendAlphanumericBytes(content, bits);
        break;
      case Mode_default.BYTE:
        Encoder3.append8BitBytes(content, bits, encoding2);
        break;
      case Mode_default.KANJI:
        Encoder3.appendKanjiBytes(content, bits);
        break;
      default:
        throw new WriterException_default("Invalid mode: " + mode);
    }
  };
  Encoder3.getDigit = function(singleCharacter) {
    return singleCharacter.charCodeAt(0) - 48;
  };
  Encoder3.isDigit = function(singleCharacter) {
    var cn = Encoder3.getDigit(singleCharacter);
    return cn >= 0 && cn <= 9;
  };
  Encoder3.appendNumericBytes = function(content, bits) {
    var length = content.length;
    var i = 0;
    while (i < length) {
      var num1 = Encoder3.getDigit(content.charAt(i));
      if (i + 2 < length) {
        var num2 = Encoder3.getDigit(content.charAt(i + 1));
        var num3 = Encoder3.getDigit(content.charAt(i + 2));
        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
        i += 3;
      } else if (i + 1 < length) {
        var num2 = Encoder3.getDigit(content.charAt(i + 1));
        bits.appendBits(num1 * 10 + num2, 7);
        i += 2;
      } else {
        bits.appendBits(num1, 4);
        i++;
      }
    }
  };
  Encoder3.appendAlphanumericBytes = function(content, bits) {
    var length = content.length;
    var i = 0;
    while (i < length) {
      var code1 = Encoder3.getAlphanumericCode(content.charCodeAt(i));
      if (code1 === -1) {
        throw new WriterException_default();
      }
      if (i + 1 < length) {
        var code2 = Encoder3.getAlphanumericCode(content.charCodeAt(i + 1));
        if (code2 === -1) {
          throw new WriterException_default();
        }
        bits.appendBits(code1 * 45 + code2, 11);
        i += 2;
      } else {
        bits.appendBits(code1, 6);
        i++;
      }
    }
  };
  Encoder3.append8BitBytes = function(content, bits, encoding2) {
    var bytes;
    try {
      bytes = StringEncoding_default.encode(content, encoding2);
    } catch (uee) {
      throw new WriterException_default(uee);
    }
    for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {
      var b = bytes[i];
      bits.appendBits(b, 8);
    }
  };
  Encoder3.appendKanjiBytes = function(content, bits) {
    var bytes;
    try {
      bytes = StringEncoding_default.encode(content, CharacterSetECI_default.SJIS);
    } catch (uee) {
      throw new WriterException_default(uee);
    }
    var length = bytes.length;
    for (var i = 0; i < length; i += 2) {
      var byte1 = bytes[i] & 255;
      var byte2 = bytes[i + 1] & 255;
      var code = byte1 << 8 & 4294967295 | byte2;
      var subtracted = -1;
      if (code >= 33088 && code <= 40956) {
        subtracted = code - 33088;
      } else if (code >= 57408 && code <= 60351) {
        subtracted = code - 49472;
      }
      if (subtracted === -1) {
        throw new WriterException_default("Invalid byte sequence");
      }
      var encoded = (subtracted >> 8) * 192 + (subtracted & 255);
      bits.appendBits(encoded, 13);
    }
  };
  Encoder3.appendECI = function(eci, bits) {
    bits.appendBits(Mode_default.ECI.getBits(), 4);
    bits.appendBits(eci.getValue(), 8);
  };
  Encoder3.ALPHANUMERIC_TABLE = Int32Array.from([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    36,
    -1,
    -1,
    -1,
    37,
    38,
    -1,
    -1,
    -1,
    -1,
    39,
    40,
    -1,
    41,
    42,
    43,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    44,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    -1,
    -1,
    -1,
    -1,
    -1
  ]);
  Encoder3.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_default.UTF8.getName();
  return Encoder3;
}();
var Encoder_default = Encoder;

// node_modules/@zxing/library/esm/browser/BrowserQRCodeSvgWriter.js
var BrowserQRCodeSvgWriter = function() {
  function BrowserQRCodeSvgWriter2() {
  }
  BrowserQRCodeSvgWriter2.prototype.write = function(contents, width, height, hints) {
    if (hints === void 0) {
      hints = null;
    }
    if (contents.length === 0) {
      throw new IllegalArgumentException_default("Found empty contents");
    }
    if (width < 0 || height < 0) {
      throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
    }
    var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
    var quietZone = BrowserQRCodeSvgWriter2.QUIET_ZONE_SIZE;
    if (hints !== null) {
      if (hints.get(EncodeHintType_default.ERROR_CORRECTION) !== void 0) {
        errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
      }
      if (hints.get(EncodeHintType_default.MARGIN) !== void 0) {
        quietZone = Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10);
      }
    }
    var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
    return this.renderResult(code, width, height, quietZone);
  };
  BrowserQRCodeSvgWriter2.prototype.writeToDom = function(containerElement, contents, width, height, hints) {
    if (hints === void 0) {
      hints = null;
    }
    if (typeof containerElement === "string") {
      containerElement = document.querySelector(containerElement);
    }
    var svgElement = this.write(contents, width, height, hints);
    if (containerElement)
      containerElement.appendChild(svgElement);
  };
  BrowserQRCodeSvgWriter2.prototype.renderResult = function(code, width, height, quietZone) {
    var input = code.getMatrix();
    if (input === null) {
      throw new IllegalStateException_default();
    }
    var inputWidth = input.getWidth();
    var inputHeight = input.getHeight();
    var qrWidth = inputWidth + quietZone * 2;
    var qrHeight = inputHeight + quietZone * 2;
    var outputWidth = Math.max(width, qrWidth);
    var outputHeight = Math.max(height, qrHeight);
    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
    var svgElement = this.createSVGElement(outputWidth, outputHeight);
    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
        if (input.get(inputX, inputY) === 1) {
          var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
          svgElement.appendChild(svgRectElement);
        }
      }
    }
    return svgElement;
  };
  BrowserQRCodeSvgWriter2.prototype.createSVGElement = function(w, h) {
    var svgElement = document.createElementNS(BrowserQRCodeSvgWriter2.SVG_NS, "svg");
    svgElement.setAttributeNS(null, "height", w.toString());
    svgElement.setAttributeNS(null, "width", h.toString());
    return svgElement;
  };
  BrowserQRCodeSvgWriter2.prototype.createSvgRectElement = function(x2, y, w, h) {
    var rect = document.createElementNS(BrowserQRCodeSvgWriter2.SVG_NS, "rect");
    rect.setAttributeNS(null, "x", x2.toString());
    rect.setAttributeNS(null, "y", y.toString());
    rect.setAttributeNS(null, "height", w.toString());
    rect.setAttributeNS(null, "width", h.toString());
    rect.setAttributeNS(null, "fill", "#000000");
    return rect;
  };
  BrowserQRCodeSvgWriter2.QUIET_ZONE_SIZE = 4;
  BrowserQRCodeSvgWriter2.SVG_NS = "http://www.w3.org/2000/svg";
  return BrowserQRCodeSvgWriter2;
}();

// node_modules/@zxing/library/esm/core/qrcode/QRCodeWriter.js
var QRCodeWriter = function() {
  function QRCodeWriter2() {
  }
  QRCodeWriter2.prototype.encode = function(contents, format, width, height, hints) {
    if (contents.length === 0) {
      throw new IllegalArgumentException_default("Found empty contents");
    }
    if (format !== BarcodeFormat_default.QR_CODE) {
      throw new IllegalArgumentException_default("Can only encode QR_CODE, but got " + format);
    }
    if (width < 0 || height < 0) {
      throw new IllegalArgumentException_default("Requested dimensions are too small: " + width + "x" + height);
    }
    var errorCorrectionLevel = ErrorCorrectionLevel_default.L;
    var quietZone = QRCodeWriter2.QUIET_ZONE_SIZE;
    if (hints !== null) {
      if (hints.get(EncodeHintType_default.ERROR_CORRECTION) !== void 0) {
        errorCorrectionLevel = ErrorCorrectionLevel_default.fromString(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
      }
      if (hints.get(EncodeHintType_default.MARGIN) !== void 0) {
        quietZone = Number.parseInt(hints.get(EncodeHintType_default.MARGIN).toString(), 10);
      }
    }
    var code = Encoder_default.encode(contents, errorCorrectionLevel, hints);
    return QRCodeWriter2.renderResult(code, width, height, quietZone);
  };
  QRCodeWriter2.renderResult = function(code, width, height, quietZone) {
    var input = code.getMatrix();
    if (input === null) {
      throw new IllegalStateException_default();
    }
    var inputWidth = input.getWidth();
    var inputHeight = input.getHeight();
    var qrWidth = inputWidth + quietZone * 2;
    var qrHeight = inputHeight + quietZone * 2;
    var outputWidth = Math.max(width, qrWidth);
    var outputHeight = Math.max(height, qrHeight);
    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
    var output = new BitMatrix_default(outputWidth, outputHeight);
    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
        if (input.get(inputX, inputY) === 1) {
          output.setRegion(outputX, outputY, multiple, multiple);
        }
      }
    }
    return output;
  };
  QRCodeWriter2.QUIET_ZONE_SIZE = 4;
  return QRCodeWriter2;
}();
var QRCodeWriter_default = QRCodeWriter;

// node_modules/@zxing/library/esm/core/MultiFormatWriter.js
var MultiFormatWriter = function() {
  function MultiFormatWriter2() {
  }
  MultiFormatWriter2.prototype.encode = function(contents, format, width, height, hints) {
    var writer;
    switch (format) {
      case BarcodeFormat_default.QR_CODE:
        writer = new QRCodeWriter_default();
        break;
      default:
        throw new IllegalArgumentException_default("No encoder available for format " + format);
    }
    return writer.encode(contents, format, width, height, hints);
  };
  return MultiFormatWriter2;
}();

// node_modules/@zxing/library/esm/core/PlanarYUVLuminanceSource.js
var __extends64 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PlanarYUVLuminanceSource = function(_super) {
  __extends64(PlanarYUVLuminanceSource2, _super);
  function PlanarYUVLuminanceSource2(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
    var _this = _super.call(this, width, height) || this;
    _this.yuvData = yuvData;
    _this.dataWidth = dataWidth;
    _this.dataHeight = dataHeight;
    _this.left = left;
    _this.top = top;
    if (left + width > dataWidth || top + height > dataHeight) {
      throw new IllegalArgumentException_default("Crop rectangle does not fit within image data.");
    }
    if (reverseHorizontal) {
      _this.reverseHorizontal(width, height);
    }
    return _this;
  }
  PlanarYUVLuminanceSource2.prototype.getRow = function(y, row) {
    if (y < 0 || y >= this.getHeight()) {
      throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
    }
    var width = this.getWidth();
    if (row === null || row === void 0 || row.length < width) {
      row = new Uint8ClampedArray(width);
    }
    var offset = (y + this.top) * this.dataWidth + this.left;
    System_default.arraycopy(this.yuvData, offset, row, 0, width);
    return row;
  };
  PlanarYUVLuminanceSource2.prototype.getMatrix = function() {
    var width = this.getWidth();
    var height = this.getHeight();
    if (width === this.dataWidth && height === this.dataHeight) {
      return this.yuvData;
    }
    var area = width * height;
    var matrix = new Uint8ClampedArray(area);
    var inputOffset = this.top * this.dataWidth + this.left;
    if (width === this.dataWidth) {
      System_default.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
      return matrix;
    }
    for (var y = 0; y < height; y++) {
      var outputOffset = y * width;
      System_default.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
      inputOffset += this.dataWidth;
    }
    return matrix;
  };
  PlanarYUVLuminanceSource2.prototype.isCropSupported = function() {
    return true;
  };
  PlanarYUVLuminanceSource2.prototype.crop = function(left, top, width, height) {
    return new PlanarYUVLuminanceSource2(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
  };
  PlanarYUVLuminanceSource2.prototype.renderThumbnail = function() {
    var width = this.getWidth() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
    var height = this.getHeight() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
    var pixels = new Int32Array(width * height);
    var yuv = this.yuvData;
    var inputOffset = this.top * this.dataWidth + this.left;
    for (var y = 0; y < height; y++) {
      var outputOffset = y * width;
      for (var x2 = 0; x2 < width; x2++) {
        var grey = yuv[inputOffset + x2 * PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR] & 255;
        pixels[outputOffset + x2] = 4278190080 | grey * 65793;
      }
      inputOffset += this.dataWidth * PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
    }
    return pixels;
  };
  PlanarYUVLuminanceSource2.prototype.getThumbnailWidth = function() {
    return this.getWidth() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
  };
  PlanarYUVLuminanceSource2.prototype.getThumbnailHeight = function() {
    return this.getHeight() / PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR;
  };
  PlanarYUVLuminanceSource2.prototype.reverseHorizontal = function(width, height) {
    var yuvData = this.yuvData;
    for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
      var middle = rowStart + width / 2;
      for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
        var temp = yuvData[x1];
        yuvData[x1] = yuvData[x2];
        yuvData[x2] = temp;
      }
    }
  };
  PlanarYUVLuminanceSource2.prototype.invert = function() {
    return new InvertedLuminanceSource_default(this);
  };
  PlanarYUVLuminanceSource2.THUMBNAIL_SCALE_FACTOR = 2;
  return PlanarYUVLuminanceSource2;
}(LuminanceSource_default);

// node_modules/@zxing/library/esm/core/RGBLuminanceSource.js
var __extends65 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RGBLuminanceSource = function(_super) {
  __extends65(RGBLuminanceSource2, _super);
  function RGBLuminanceSource2(luminances, width, height, dataWidth, dataHeight, left, top) {
    var _this = _super.call(this, width, height) || this;
    _this.dataWidth = dataWidth;
    _this.dataHeight = dataHeight;
    _this.left = left;
    _this.top = top;
    if (luminances.BYTES_PER_ELEMENT === 4) {
      var size = width * height;
      var luminancesUint8Array = new Uint8ClampedArray(size);
      for (var offset = 0; offset < size; offset++) {
        var pixel = luminances[offset];
        var r = pixel >> 16 & 255;
        var g2 = pixel >> 7 & 510;
        var b = pixel & 255;
        luminancesUint8Array[offset] = (r + g2 + b) / 4 & 255;
      }
      _this.luminances = luminancesUint8Array;
    } else {
      _this.luminances = luminances;
    }
    if (dataWidth === void 0) {
      _this.dataWidth = width;
    }
    if (dataHeight === void 0) {
      _this.dataHeight = height;
    }
    if (left === void 0) {
      _this.left = 0;
    }
    if (top === void 0) {
      _this.top = 0;
    }
    if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {
      throw new IllegalArgumentException_default("Crop rectangle does not fit within image data.");
    }
    return _this;
  }
  RGBLuminanceSource2.prototype.getRow = function(y, row) {
    if (y < 0 || y >= this.getHeight()) {
      throw new IllegalArgumentException_default("Requested row is outside the image: " + y);
    }
    var width = this.getWidth();
    if (row === null || row === void 0 || row.length < width) {
      row = new Uint8ClampedArray(width);
    }
    var offset = (y + this.top) * this.dataWidth + this.left;
    System_default.arraycopy(this.luminances, offset, row, 0, width);
    return row;
  };
  RGBLuminanceSource2.prototype.getMatrix = function() {
    var width = this.getWidth();
    var height = this.getHeight();
    if (width === this.dataWidth && height === this.dataHeight) {
      return this.luminances;
    }
    var area = width * height;
    var matrix = new Uint8ClampedArray(area);
    var inputOffset = this.top * this.dataWidth + this.left;
    if (width === this.dataWidth) {
      System_default.arraycopy(this.luminances, inputOffset, matrix, 0, area);
      return matrix;
    }
    for (var y = 0; y < height; y++) {
      var outputOffset = y * width;
      System_default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
      inputOffset += this.dataWidth;
    }
    return matrix;
  };
  RGBLuminanceSource2.prototype.isCropSupported = function() {
    return true;
  };
  RGBLuminanceSource2.prototype.crop = function(left, top, width, height) {
    return new RGBLuminanceSource2(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
  };
  RGBLuminanceSource2.prototype.invert = function() {
    return new InvertedLuminanceSource_default(this);
  };
  return RGBLuminanceSource2;
}(LuminanceSource_default);

// node_modules/@zxing/library/esm/core/util/Charset.js
var __extends66 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Charset = function(_super) {
  __extends66(Charset2, _super);
  function Charset2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Charset2.forName = function(name) {
    return this.getCharacterSetECIByName(name);
  };
  return Charset2;
}(CharacterSetECI_default);
var Charset_default = Charset;

// node_modules/@zxing/library/esm/core/util/StandardCharsets.js
var StandardCharsets = function() {
  function StandardCharsets2() {
  }
  StandardCharsets2.ISO_8859_1 = CharacterSetECI_default.ISO8859_1;
  return StandardCharsets2;
}();
var StandardCharsets_default = StandardCharsets;

// node_modules/@zxing/library/esm/core/aztec/encoder/AztecCode.js
var AztecCode = function() {
  function AztecCode2() {
  }
  AztecCode2.prototype.isCompact = function() {
    return this.compact;
  };
  AztecCode2.prototype.setCompact = function(compact) {
    this.compact = compact;
  };
  AztecCode2.prototype.getSize = function() {
    return this.size;
  };
  AztecCode2.prototype.setSize = function(size) {
    this.size = size;
  };
  AztecCode2.prototype.getLayers = function() {
    return this.layers;
  };
  AztecCode2.prototype.setLayers = function(layers) {
    this.layers = layers;
  };
  AztecCode2.prototype.getCodeWords = function() {
    return this.codeWords;
  };
  AztecCode2.prototype.setCodeWords = function(codeWords) {
    this.codeWords = codeWords;
  };
  AztecCode2.prototype.getMatrix = function() {
    return this.matrix;
  };
  AztecCode2.prototype.setMatrix = function(matrix) {
    this.matrix = matrix;
  };
  return AztecCode2;
}();
var AztecCode_default = AztecCode;

// node_modules/@zxing/library/esm/core/util/Collections.js
var Collections = function() {
  function Collections2() {
  }
  Collections2.singletonList = function(item) {
    return [item];
  };
  Collections2.min = function(collection, comparator) {
    return collection.sort(comparator)[0];
  };
  return Collections2;
}();
var Collections_default = Collections;

// node_modules/@zxing/library/esm/core/aztec/encoder/Token.js
var Token = function() {
  function Token2(previous) {
    this.previous = previous;
  }
  Token2.prototype.getPrevious = function() {
    return this.previous;
  };
  return Token2;
}();
var Token_default = Token;

// node_modules/@zxing/library/esm/core/aztec/encoder/SimpleToken.js
var __extends67 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SimpleToken = function(_super) {
  __extends67(SimpleToken2, _super);
  function SimpleToken2(previous, value, bitCount) {
    var _this = _super.call(this, previous) || this;
    _this.value = value;
    _this.bitCount = bitCount;
    return _this;
  }
  SimpleToken2.prototype.appendTo = function(bitArray, text) {
    bitArray.appendBits(this.value, this.bitCount);
  };
  SimpleToken2.prototype.add = function(value, bitCount) {
    return new SimpleToken2(this, value, bitCount);
  };
  SimpleToken2.prototype.addBinaryShift = function(start, byteCount) {
    console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
    return new SimpleToken2(this, start, byteCount);
  };
  SimpleToken2.prototype.toString = function() {
    var value = this.value & (1 << this.bitCount) - 1;
    value |= 1 << this.bitCount;
    return "<" + Integer_default.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
  };
  return SimpleToken2;
}(Token_default);
var SimpleToken_default = SimpleToken;

// node_modules/@zxing/library/esm/core/aztec/encoder/BinaryShiftToken.js
var __extends68 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var BinaryShiftToken = function(_super) {
  __extends68(BinaryShiftToken2, _super);
  function BinaryShiftToken2(previous, binaryShiftStart, binaryShiftByteCount) {
    var _this = _super.call(this, previous, 0, 0) || this;
    _this.binaryShiftStart = binaryShiftStart;
    _this.binaryShiftByteCount = binaryShiftByteCount;
    return _this;
  }
  BinaryShiftToken2.prototype.appendTo = function(bitArray, text) {
    for (var i = 0; i < this.binaryShiftByteCount; i++) {
      if (i === 0 || i === 31 && this.binaryShiftByteCount <= 62) {
        bitArray.appendBits(31, 5);
        if (this.binaryShiftByteCount > 62) {
          bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
        } else if (i === 0) {
          bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
        } else {
          bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
        }
      }
      bitArray.appendBits(text[this.binaryShiftStart + i], 8);
    }
  };
  BinaryShiftToken2.prototype.addBinaryShift = function(start, byteCount) {
    return new BinaryShiftToken2(this, start, byteCount);
  };
  BinaryShiftToken2.prototype.toString = function() {
    return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
  };
  return BinaryShiftToken2;
}(SimpleToken_default);
var BinaryShiftToken_default = BinaryShiftToken;

// node_modules/@zxing/library/esm/core/aztec/encoder/TokenHelpers.js
function addBinaryShift(token, start, byteCount) {
  return new BinaryShiftToken_default(token, start, byteCount);
}
function add(token, value, bitCount) {
  return new SimpleToken_default(token, value, bitCount);
}

// node_modules/@zxing/library/esm/core/aztec/encoder/EncoderConstants.js
var MODE_NAMES = [
  "UPPER",
  "LOWER",
  "DIGIT",
  "MIXED",
  "PUNCT"
];
var MODE_UPPER = 0;
var MODE_LOWER = 1;
var MODE_DIGIT = 2;
var MODE_MIXED = 3;
var MODE_PUNCT = 4;
var EMPTY_TOKEN = new SimpleToken_default(null, 0, 0);

// node_modules/@zxing/library/esm/core/aztec/encoder/LatchTable.js
var LATCH_TABLE = [
  Int32Array.from([
    0,
    (5 << 16) + 28,
    (5 << 16) + 30,
    (5 << 16) + 29,
    (10 << 16) + (29 << 5) + 30
  ]),
  Int32Array.from([
    (9 << 16) + (30 << 4) + 14,
    0,
    (5 << 16) + 30,
    (5 << 16) + 29,
    (10 << 16) + (29 << 5) + 30
  ]),
  Int32Array.from([
    (4 << 16) + 14,
    (9 << 16) + (14 << 5) + 28,
    0,
    (9 << 16) + (14 << 5) + 29,
    (14 << 16) + (14 << 10) + (29 << 5) + 30
  ]),
  Int32Array.from([
    (5 << 16) + 29,
    (5 << 16) + 28,
    (10 << 16) + (29 << 5) + 30,
    0,
    (5 << 16) + 30
  ]),
  Int32Array.from([
    (5 << 16) + 31,
    (10 << 16) + (31 << 5) + 28,
    (10 << 16) + (31 << 5) + 30,
    (10 << 16) + (31 << 5) + 29,
    0
  ])
];

// node_modules/@zxing/library/esm/core/aztec/encoder/ShiftTable.js
var __values40 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function static_SHIFT_TABLE(SHIFT_TABLE2) {
  var e_1, _a;
  try {
    for (var SHIFT_TABLE_1 = __values40(SHIFT_TABLE2), SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next(); !SHIFT_TABLE_1_1.done; SHIFT_TABLE_1_1 = SHIFT_TABLE_1.next()) {
      var table = SHIFT_TABLE_1_1.value;
      Arrays_default.fill(table, -1);
    }
  } catch (e_1_1) {
    e_1 = {error: e_1_1};
  } finally {
    try {
      if (SHIFT_TABLE_1_1 && !SHIFT_TABLE_1_1.done && (_a = SHIFT_TABLE_1.return))
        _a.call(SHIFT_TABLE_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
  SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
  SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
  SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
  SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
  SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
  return SHIFT_TABLE2;
}
var SHIFT_TABLE = static_SHIFT_TABLE(Arrays_default.createInt32Array(6, 6));

// node_modules/@zxing/library/esm/core/aztec/encoder/State.js
var __values41 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var State = function() {
  function State2(token, mode, binaryBytes, bitCount) {
    this.token = token;
    this.mode = mode;
    this.binaryShiftByteCount = binaryBytes;
    this.bitCount = bitCount;
  }
  State2.prototype.getMode = function() {
    return this.mode;
  };
  State2.prototype.getToken = function() {
    return this.token;
  };
  State2.prototype.getBinaryShiftByteCount = function() {
    return this.binaryShiftByteCount;
  };
  State2.prototype.getBitCount = function() {
    return this.bitCount;
  };
  State2.prototype.latchAndAppend = function(mode, value) {
    var bitCount = this.bitCount;
    var token = this.token;
    if (mode !== this.mode) {
      var latch = LATCH_TABLE[this.mode][mode];
      token = add(token, latch & 65535, latch >> 16);
      bitCount += latch >> 16;
    }
    var latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
    token = add(token, value, latchModeBitCount);
    return new State2(token, mode, 0, bitCount + latchModeBitCount);
  };
  State2.prototype.shiftAndAppend = function(mode, value) {
    var token = this.token;
    var thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
    token = add(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
    token = add(token, value, 5);
    return new State2(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
  };
  State2.prototype.addBinaryShiftChar = function(index) {
    var token = this.token;
    var mode = this.mode;
    var bitCount = this.bitCount;
    if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
      var latch = LATCH_TABLE[mode][MODE_UPPER];
      token = add(token, latch & 65535, latch >> 16);
      bitCount += latch >> 16;
      mode = MODE_UPPER;
    }
    var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
    var result = new State2(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
    if (result.binaryShiftByteCount === 2047 + 31) {
      result = result.endBinaryShift(index + 1);
    }
    return result;
  };
  State2.prototype.endBinaryShift = function(index) {
    if (this.binaryShiftByteCount === 0) {
      return this;
    }
    var token = this.token;
    token = addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);
    return new State2(token, this.mode, 0, this.bitCount);
  };
  State2.prototype.isBetterThanOrEqualTo = function(other) {
    var newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
    if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
      newModeBitCount += State2.calculateBinaryShiftCost(other) - State2.calculateBinaryShiftCost(this);
    } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
      newModeBitCount += 10;
    }
    return newModeBitCount <= other.bitCount;
  };
  State2.prototype.toBitArray = function(text) {
    var e_1, _a;
    var symbols = [];
    for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
      symbols.unshift(token);
    }
    var bitArray = new BitArray_default();
    try {
      for (var symbols_1 = __values41(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {
        var symbol = symbols_1_1.value;
        symbol.appendTo(bitArray, text);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return))
          _a.call(symbols_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return bitArray;
  };
  State2.prototype.toString = function() {
    return StringUtils_default.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
  };
  State2.calculateBinaryShiftCost = function(state) {
    if (state.binaryShiftByteCount > 62) {
      return 21;
    }
    if (state.binaryShiftByteCount > 31) {
      return 20;
    }
    if (state.binaryShiftByteCount > 0) {
      return 10;
    }
    return 0;
  };
  State2.INITIAL_STATE = new State2(EMPTY_TOKEN, MODE_UPPER, 0, 0);
  return State2;
}();
var State_default = State;

// node_modules/@zxing/library/esm/core/aztec/encoder/CharMap.js
function static_CHAR_MAP(CHAR_MAP2) {
  var spaceCharCode = StringUtils_default.getCharCode(" ");
  var pointCharCode = StringUtils_default.getCharCode(".");
  var commaCharCode = StringUtils_default.getCharCode(",");
  CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
  var zUpperCharCode = StringUtils_default.getCharCode("Z");
  var aUpperCharCode = StringUtils_default.getCharCode("A");
  for (var c = aUpperCharCode; c <= zUpperCharCode; c++) {
    CHAR_MAP2[MODE_UPPER][c] = c - aUpperCharCode + 2;
  }
  CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
  var zLowerCharCode = StringUtils_default.getCharCode("z");
  var aLowerCharCode = StringUtils_default.getCharCode("a");
  for (var c = aLowerCharCode; c <= zLowerCharCode; c++) {
    CHAR_MAP2[MODE_LOWER][c] = c - aLowerCharCode + 2;
  }
  CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
  var nineCharCode = StringUtils_default.getCharCode("9");
  var zeroCharCode = StringUtils_default.getCharCode("0");
  for (var c = zeroCharCode; c <= nineCharCode; c++) {
    CHAR_MAP2[MODE_DIGIT][c] = c - zeroCharCode + 2;
  }
  CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
  CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
  var mixedTable = [
    "\0",
    " ",
    "",
    "",
    "",
    "",
    "",
    "",
    "\x07",
    "\b",
    "	",
    "\n",
    "\v",
    "\f",
    "\r",
    "",
    "",
    "",
    "",
    "",
    "@",
    "\\",
    "^",
    "_",
    "`",
    "|",
    "~",
    "\x7F"
  ];
  for (var i = 0; i < mixedTable.length; i++) {
    CHAR_MAP2[MODE_MIXED][StringUtils_default.getCharCode(mixedTable[i])] = i;
  }
  var punctTable = [
    "\0",
    "\r",
    "\0",
    "\0",
    "\0",
    "\0",
    "!",
    "'",
    "#",
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "?",
    "[",
    "]",
    "{",
    "}"
  ];
  for (var i = 0; i < punctTable.length; i++) {
    if (StringUtils_default.getCharCode(punctTable[i]) > 0) {
      CHAR_MAP2[MODE_PUNCT][StringUtils_default.getCharCode(punctTable[i])] = i;
    }
  }
  return CHAR_MAP2;
}
var CHAR_MAP = static_CHAR_MAP(Arrays_default.createInt32Array(5, 256));

// node_modules/@zxing/library/esm/core/aztec/encoder/HighLevelEncoder.js
var __values42 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var HighLevelEncoder = function() {
  function HighLevelEncoder2(text) {
    this.text = text;
  }
  HighLevelEncoder2.prototype.encode = function() {
    var spaceCharCode = StringUtils_default.getCharCode(" ");
    var lineBreakCharCode = StringUtils_default.getCharCode("\n");
    var states = Collections_default.singletonList(State_default.INITIAL_STATE);
    for (var index = 0; index < this.text.length; index++) {
      var pairCode = void 0;
      var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;
      switch (this.text[index]) {
        case StringUtils_default.getCharCode("\r"):
          pairCode = nextChar === lineBreakCharCode ? 2 : 0;
          break;
        case StringUtils_default.getCharCode("."):
          pairCode = nextChar === spaceCharCode ? 3 : 0;
          break;
        case StringUtils_default.getCharCode(","):
          pairCode = nextChar === spaceCharCode ? 4 : 0;
          break;
        case StringUtils_default.getCharCode(":"):
          pairCode = nextChar === spaceCharCode ? 5 : 0;
          break;
        default:
          pairCode = 0;
      }
      if (pairCode > 0) {
        states = HighLevelEncoder2.updateStateListForPair(states, index, pairCode);
        index++;
      } else {
        states = this.updateStateListForChar(states, index);
      }
    }
    var minState = Collections_default.min(states, function(a, b) {
      return a.getBitCount() - b.getBitCount();
    });
    return minState.toBitArray(this.text);
  };
  HighLevelEncoder2.prototype.updateStateListForChar = function(states, index) {
    var e_1, _a;
    var result = [];
    try {
      for (var states_1 = __values42(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {
        var state = states_1_1.value;
        this.updateStateForChar(state, index, result);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (states_1_1 && !states_1_1.done && (_a = states_1.return))
          _a.call(states_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return HighLevelEncoder2.simplifyStates(result);
  };
  HighLevelEncoder2.prototype.updateStateForChar = function(state, index, result) {
    var ch = this.text[index] & 255;
    var charInCurrentTable = CHAR_MAP[state.getMode()][ch] > 0;
    var stateNoBinary = null;
    for (var mode = 0; mode <= MODE_PUNCT; mode++) {
      var charInMode = CHAR_MAP[mode][ch];
      if (charInMode > 0) {
        if (stateNoBinary == null) {
          stateNoBinary = state.endBinaryShift(index);
        }
        if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
          var latchState = stateNoBinary.latchAndAppend(mode, charInMode);
          result.push(latchState);
        }
        if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
          var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
          result.push(shiftState);
        }
      }
    }
    if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch] === 0) {
      var binaryState = state.addBinaryShiftChar(index);
      result.push(binaryState);
    }
  };
  HighLevelEncoder2.updateStateListForPair = function(states, index, pairCode) {
    var e_2, _a;
    var result = [];
    try {
      for (var states_2 = __values42(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {
        var state = states_2_1.value;
        this.updateStateForPair(state, index, pairCode, result);
      }
    } catch (e_2_1) {
      e_2 = {error: e_2_1};
    } finally {
      try {
        if (states_2_1 && !states_2_1.done && (_a = states_2.return))
          _a.call(states_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return this.simplifyStates(result);
  };
  HighLevelEncoder2.updateStateForPair = function(state, index, pairCode, result) {
    var stateNoBinary = state.endBinaryShift(index);
    result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
    if (state.getMode() !== MODE_PUNCT) {
      result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
    }
    if (pairCode === 3 || pairCode === 4) {
      var digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
      result.push(digitState);
    }
    if (state.getBinaryShiftByteCount() > 0) {
      var binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);
      result.push(binaryState);
    }
  };
  HighLevelEncoder2.simplifyStates = function(states) {
    var e_3, _a, e_4, _b;
    var result = [];
    try {
      for (var states_3 = __values42(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {
        var newState = states_3_1.value;
        var add2 = true;
        var _loop_1 = function(oldState2) {
          if (oldState2.isBetterThanOrEqualTo(newState)) {
            add2 = false;
            return "break";
          }
          if (newState.isBetterThanOrEqualTo(oldState2)) {
            result = result.filter(function(x2) {
              return x2 !== oldState2;
            });
          }
        };
        try {
          for (var result_1 = (e_4 = void 0, __values42(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
            var oldState = result_1_1.value;
            var state_1 = _loop_1(oldState);
            if (state_1 === "break")
              break;
          }
        } catch (e_4_1) {
          e_4 = {error: e_4_1};
        } finally {
          try {
            if (result_1_1 && !result_1_1.done && (_b = result_1.return))
              _b.call(result_1);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        if (add2) {
          result.push(newState);
        }
      }
    } catch (e_3_1) {
      e_3 = {error: e_3_1};
    } finally {
      try {
        if (states_3_1 && !states_3_1.done && (_a = states_3.return))
          _a.call(states_3);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    return result;
  };
  return HighLevelEncoder2;
}();
var HighLevelEncoder_default = HighLevelEncoder;

// node_modules/@zxing/library/esm/core/aztec/encoder/Encoder.js
var __values43 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {value: o && o[i++], done: !o};
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Encoder2 = function() {
  function Encoder3() {
  }
  Encoder3.encodeBytes = function(data) {
    return Encoder3.encode(data, Encoder3.DEFAULT_EC_PERCENT, Encoder3.DEFAULT_AZTEC_LAYERS);
  };
  Encoder3.encode = function(data, minECCPercent, userSpecifiedLayers) {
    var bits = new HighLevelEncoder_default(data).encode();
    var eccBits = Integer_default.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
    var totalSizeBits = bits.getSize() + eccBits;
    var compact;
    var layers;
    var totalBitsInLayer;
    var wordSize;
    var stuffedBits;
    if (userSpecifiedLayers !== Encoder3.DEFAULT_AZTEC_LAYERS) {
      compact = userSpecifiedLayers < 0;
      layers = Math.abs(userSpecifiedLayers);
      if (layers > (compact ? Encoder3.MAX_NB_BITS_COMPACT : Encoder3.MAX_NB_BITS)) {
        throw new IllegalArgumentException_default(StringUtils_default.format("Illegal value %s for layers", userSpecifiedLayers));
      }
      totalBitsInLayer = Encoder3.totalBitsInLayer(layers, compact);
      wordSize = Encoder3.WORD_SIZE[layers];
      var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
      stuffedBits = Encoder3.stuffBits(bits, wordSize);
      if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
        throw new IllegalArgumentException_default("Data to large for user specified layer");
      }
      if (compact && stuffedBits.getSize() > wordSize * 64) {
        throw new IllegalArgumentException_default("Data to large for user specified layer");
      }
    } else {
      wordSize = 0;
      stuffedBits = null;
      for (var i = 0; ; i++) {
        if (i > Encoder3.MAX_NB_BITS) {
          throw new IllegalArgumentException_default("Data too large for an Aztec code");
        }
        compact = i <= 3;
        layers = compact ? i + 1 : i;
        totalBitsInLayer = Encoder3.totalBitsInLayer(layers, compact);
        if (totalSizeBits > totalBitsInLayer) {
          continue;
        }
        if (stuffedBits == null || wordSize !== Encoder3.WORD_SIZE[layers]) {
          wordSize = Encoder3.WORD_SIZE[layers];
          stuffedBits = Encoder3.stuffBits(bits, wordSize);
        }
        var usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
        if (compact && stuffedBits.getSize() > wordSize * 64) {
          continue;
        }
        if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
          break;
        }
      }
    }
    var messageBits = Encoder3.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
    var messageSizeInWords = stuffedBits.getSize() / wordSize;
    var modeMessage = Encoder3.generateModeMessage(compact, layers, messageSizeInWords);
    var baseMatrixSize = (compact ? 11 : 14) + layers * 4;
    var alignmentMap = new Int32Array(baseMatrixSize);
    var matrixSize;
    if (compact) {
      matrixSize = baseMatrixSize;
      for (var i = 0; i < alignmentMap.length; i++) {
        alignmentMap[i] = i;
      }
    } else {
      matrixSize = baseMatrixSize + 1 + 2 * Integer_default.truncDivision(Integer_default.truncDivision(baseMatrixSize, 2) - 1, 15);
      var origCenter = Integer_default.truncDivision(baseMatrixSize, 2);
      var center = Integer_default.truncDivision(matrixSize, 2);
      for (var i = 0; i < origCenter; i++) {
        var newOffset = i + Integer_default.truncDivision(i, 15);
        alignmentMap[origCenter - i - 1] = center - newOffset - 1;
        alignmentMap[origCenter + i] = center + newOffset + 1;
      }
    }
    var matrix = new BitMatrix_default(matrixSize);
    for (var i = 0, rowOffset = 0; i < layers; i++) {
      var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
      for (var j = 0; j < rowSize; j++) {
        var columnOffset = j * 2;
        for (var k = 0; k < 2; k++) {
          if (messageBits.get(rowOffset + columnOffset + k)) {
            matrix.set(alignmentMap[i * 2 + k], alignmentMap[i * 2 + j]);
          }
          if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k)) {
            matrix.set(alignmentMap[i * 2 + j], alignmentMap[baseMatrixSize - 1 - i * 2 - k]);
          }
          if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k)) {
            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - k], alignmentMap[baseMatrixSize - 1 - i * 2 - j]);
          }
          if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k)) {
            matrix.set(alignmentMap[baseMatrixSize - 1 - i * 2 - j], alignmentMap[i * 2 + k]);
          }
        }
      }
      rowOffset += rowSize * 8;
    }
    Encoder3.drawModeMessage(matrix, compact, matrixSize, modeMessage);
    if (compact) {
      Encoder3.drawBullsEye(matrix, Integer_default.truncDivision(matrixSize, 2), 5);
    } else {
      Encoder3.drawBullsEye(matrix, Integer_default.truncDivision(matrixSize, 2), 7);
      for (var i = 0, j = 0; i < Integer_default.truncDivision(baseMatrixSize, 2) - 1; i += 15, j += 16) {
        for (var k = Integer_default.truncDivision(matrixSize, 2) & 1; k < matrixSize; k += 2) {
          matrix.set(Integer_default.truncDivision(matrixSize, 2) - j, k);
          matrix.set(Integer_default.truncDivision(matrixSize, 2) + j, k);
          matrix.set(k, Integer_default.truncDivision(matrixSize, 2) - j);
          matrix.set(k, Integer_default.truncDivision(matrixSize, 2) + j);
        }
      }
    }
    var aztec = new AztecCode_default();
    aztec.setCompact(compact);
    aztec.setSize(matrixSize);
    aztec.setLayers(layers);
    aztec.setCodeWords(messageSizeInWords);
    aztec.setMatrix(matrix);
    return aztec;
  };
  Encoder3.drawBullsEye = function(matrix, center, size) {
    for (var i = 0; i < size; i += 2) {
      for (var j = center - i; j <= center + i; j++) {
        matrix.set(j, center - i);
        matrix.set(j, center + i);
        matrix.set(center - i, j);
        matrix.set(center + i, j);
      }
    }
    matrix.set(center - size, center - size);
    matrix.set(center - size + 1, center - size);
    matrix.set(center - size, center - size + 1);
    matrix.set(center + size, center - size);
    matrix.set(center + size, center - size + 1);
    matrix.set(center + size, center + size - 1);
  };
  Encoder3.generateModeMessage = function(compact, layers, messageSizeInWords) {
    var modeMessage = new BitArray_default();
    if (compact) {
      modeMessage.appendBits(layers - 1, 2);
      modeMessage.appendBits(messageSizeInWords - 1, 6);
      modeMessage = Encoder3.generateCheckWords(modeMessage, 28, 4);
    } else {
      modeMessage.appendBits(layers - 1, 5);
      modeMessage.appendBits(messageSizeInWords - 1, 11);
      modeMessage = Encoder3.generateCheckWords(modeMessage, 40, 4);
    }
    return modeMessage;
  };
  Encoder3.drawModeMessage = function(matrix, compact, matrixSize, modeMessage) {
    var center = Integer_default.truncDivision(matrixSize, 2);
    if (compact) {
      for (var i = 0; i < 7; i++) {
        var offset = center - 3 + i;
        if (modeMessage.get(i)) {
          matrix.set(offset, center - 5);
        }
        if (modeMessage.get(i + 7)) {
          matrix.set(center + 5, offset);
        }
        if (modeMessage.get(20 - i)) {
          matrix.set(offset, center + 5);
        }
        if (modeMessage.get(27 - i)) {
          matrix.set(center - 5, offset);
        }
      }
    } else {
      for (var i = 0; i < 10; i++) {
        var offset = center - 5 + i + Integer_default.truncDivision(i, 5);
        if (modeMessage.get(i)) {
          matrix.set(offset, center - 7);
        }
        if (modeMessage.get(i + 10)) {
          matrix.set(center + 7, offset);
        }
        if (modeMessage.get(29 - i)) {
          matrix.set(offset, center + 7);
        }
        if (modeMessage.get(39 - i)) {
          matrix.set(center - 7, offset);
        }
      }
    }
  };
  Encoder3.generateCheckWords = function(bitArray, totalBits, wordSize) {
    var e_1, _a;
    var messageSizeInWords = bitArray.getSize() / wordSize;
    var rs = new ReedSolomonEncoder_default(Encoder3.getGF(wordSize));
    var totalWords = Integer_default.truncDivision(totalBits, wordSize);
    var messageWords = Encoder3.bitsToWords(bitArray, wordSize, totalWords);
    rs.encode(messageWords, totalWords - messageSizeInWords);
    var startPad = totalBits % wordSize;
    var messageBits = new BitArray_default();
    messageBits.appendBits(0, startPad);
    try {
      for (var _b = __values43(Array.from(messageWords)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var messageWord = _c.value;
        messageBits.appendBits(messageWord, wordSize);
      }
    } catch (e_1_1) {
      e_1 = {error: e_1_1};
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return messageBits;
  };
  Encoder3.bitsToWords = function(stuffedBits, wordSize, totalWords) {
    var message = new Int32Array(totalWords);
    var i;
    var n;
    for (i = 0, n = stuffedBits.getSize() / wordSize; i < n; i++) {
      var value = 0;
      for (var j = 0; j < wordSize; j++) {
        value |= stuffedBits.get(i * wordSize + j) ? 1 << wordSize - j - 1 : 0;
      }
      message[i] = value;
    }
    return message;
  };
  Encoder3.getGF = function(wordSize) {
    switch (wordSize) {
      case 4:
        return GenericGF_default.AZTEC_PARAM;
      case 6:
        return GenericGF_default.AZTEC_DATA_6;
      case 8:
        return GenericGF_default.AZTEC_DATA_8;
      case 10:
        return GenericGF_default.AZTEC_DATA_10;
      case 12:
        return GenericGF_default.AZTEC_DATA_12;
      default:
        throw new IllegalArgumentException_default("Unsupported word size " + wordSize);
    }
  };
  Encoder3.stuffBits = function(bits, wordSize) {
    var out = new BitArray_default();
    var n = bits.getSize();
    var mask = (1 << wordSize) - 2;
    for (var i = 0; i < n; i += wordSize) {
      var word = 0;
      for (var j = 0; j < wordSize; j++) {
        if (i + j >= n || bits.get(i + j)) {
          word |= 1 << wordSize - 1 - j;
        }
      }
      if ((word & mask) === mask) {
        out.appendBits(word & mask, wordSize);
        i--;
      } else if ((word & mask) === 0) {
        out.appendBits(word | 1, wordSize);
        i--;
      } else {
        out.appendBits(word, wordSize);
      }
    }
    return out;
  };
  Encoder3.totalBitsInLayer = function(layers, compact) {
    return ((compact ? 88 : 112) + 16 * layers) * layers;
  };
  Encoder3.DEFAULT_EC_PERCENT = 33;
  Encoder3.DEFAULT_AZTEC_LAYERS = 0;
  Encoder3.MAX_NB_BITS = 32;
  Encoder3.MAX_NB_BITS_COMPACT = 4;
  Encoder3.WORD_SIZE = Int32Array.from([
    4,
    6,
    6,
    8,
    8,
    8,
    8,
    8,
    8,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    10,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12
  ]);
  return Encoder3;
}();
var Encoder_default2 = Encoder2;

// node_modules/@zxing/library/esm/core/aztec/AztecWriter.js
var AztecWriter = function() {
  function AztecWriter2() {
  }
  AztecWriter2.prototype.encode = function(contents, format, width, height) {
    return this.encodeWithHints(contents, format, width, height, null);
  };
  AztecWriter2.prototype.encodeWithHints = function(contents, format, width, height, hints) {
    var charset = StandardCharsets_default.ISO_8859_1;
    var eccPercent = Encoder_default2.DEFAULT_EC_PERCENT;
    var layers = Encoder_default2.DEFAULT_AZTEC_LAYERS;
    if (hints != null) {
      if (hints.has(EncodeHintType_default.CHARACTER_SET)) {
        charset = Charset_default.forName(hints.get(EncodeHintType_default.CHARACTER_SET).toString());
      }
      if (hints.has(EncodeHintType_default.ERROR_CORRECTION)) {
        eccPercent = Integer_default.parseInt(hints.get(EncodeHintType_default.ERROR_CORRECTION).toString());
      }
      if (hints.has(EncodeHintType_default.AZTEC_LAYERS)) {
        layers = Integer_default.parseInt(hints.get(EncodeHintType_default.AZTEC_LAYERS).toString());
      }
    }
    return AztecWriter2.encodeLayers(contents, format, width, height, charset, eccPercent, layers);
  };
  AztecWriter2.encodeLayers = function(contents, format, width, height, charset, eccPercent, layers) {
    if (format !== BarcodeFormat_default.AZTEC) {
      throw new IllegalArgumentException_default("Can only encode AZTEC, but got " + format);
    }
    var aztec = Encoder_default2.encode(StringUtils_default.getBytes(contents, charset), eccPercent, layers);
    return AztecWriter2.renderResult(aztec, width, height);
  };
  AztecWriter2.renderResult = function(code, width, height) {
    var input = code.getMatrix();
    if (input == null) {
      throw new IllegalStateException_default();
    }
    var inputWidth = input.getWidth();
    var inputHeight = input.getHeight();
    var outputWidth = Math.max(width, inputWidth);
    var outputHeight = Math.max(height, inputHeight);
    var multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
    var leftPadding = (outputWidth - inputWidth * multiple) / 2;
    var topPadding = (outputHeight - inputHeight * multiple) / 2;
    var output = new BitMatrix_default(outputWidth, outputHeight);
    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
        if (input.get(inputX, inputY)) {
          output.setRegion(outputX, outputY, multiple, multiple);
        }
      }
    }
    return output;
  };
  return AztecWriter2;
}();

// src/pages/scanqr.js
var ScanQrPage = class extends AbstractPage {
  constructor(domElem2) {
    console.log("SCANQR: Inside constructor");
    super(domElem2);
    this.codeReader = new BrowserMultiFormatReader();
    this.selectedDeviceId = void 0;
    this.selectHtml = html``;
    this.resultObj = void 0;
    this.result = void 0;
    this.videoElem = void 0;
    this.self = this;
  }
  _render() {
    return html`
        <!-- =========================================== -->
        <!-- SCAN QR PAGE.                               -->
        <!-- =========================================== -->
                    
        <div id="videoPlaceholder">
        </div>        
        `;
  }
  async enter() {
    console.log("SCANQR Enter", this.clientWidth);
    this.result = void 0;
    this.render(this._render());
    if (this.videoElem === void 0) {
      let constraints = {
        video: {
          facingMode: "environment"
        }
      };
      try {
        var stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        if (e instanceof NotAllowedError) {
          throw e;
        }
        if (e instanceof NotFoundError) {
          throw e;
        }
      }
      let streamDeviceId = stream.getVideoTracks()[0].getSettings().deviceId;
      this.selectedDeviceId = streamDeviceId;
      let placeHolder = document.querySelector("#videoPlaceholder");
      this.videoElem = document.createElement("video");
      this.videoElem.style.width = "100%";
      placeHolder.append(this.videoElem);
    }
    this.codeReader.decodeFromVideoDevice(this.selectedDeviceId, this.videoElem, (result, err2) => {
      if (result) {
        console.log("RESULT", result);
        this.codeReader.reset();
        processQRpiece(result);
      }
      if (err2 && !(err2 instanceof NotFoundException_default)) {
        console.error(err2);
        this.result = err2;
        this.requestUpdate();
      }
    });
    console.log(`Started continous decode from camera with id ${this.selectedDeviceId}`);
    this.render(this._render());
  }
  selected(deviceId) {
    this.selectedDeviceId = deviceId;
    var x2 = document.querySelector("#selectList");
    x2.classList.toggle("w3-show");
    this.codeReader.reset();
    this.codeReader.decodeFromVideoDevice(this.selectedDeviceId, this.videoElem, (result, err2) => {
      if (result) {
        console.log("RESULT", result);
        this.codeReader.reset();
        processQRpiece(result);
      }
      if (err2 && !(err2 instanceof NotFoundException_default)) {
        console.error(err2);
        this.result = err2;
        this.render(this._render());
      }
    });
    console.log(`Started continous decode from camera with id ${this.selectedDeviceId}`);
    this.render(this._render());
  }
  async exit() {
    this.codeReader.reset();
  }
};
var QR_UNKNOWN = 0;
var QR_URL = 1;
var QR_MULTI = 2;
var QR_HC1 = 3;
async function processQRpiece(readerResult) {
  let qrData = readerResult.text;
  let qrType = detectQRtype(qrData);
  if (qrType === QR_UNKNOWN || qrType === QR_URL) {
    gotoPage("displayNormalQR", qrData);
    return;
  }
  if (qrType === QR_HC1) {
    gotoPage("displayhcert", qrData);
    return;
  }
}
function detectQRtype(qrData) {
  console.log("detectQRtype:", qrData);
  if (!qrData.startsWith) {
    log.myerror("detectQRtype: data is not string");
  }
  if (qrData.startsWith("https")) {
    return QR_URL;
  } else if (qrData.startsWith("multi|w3cvc|")) {
    return QR_MULTI;
  } else if (qrData.startsWith("HC1:")) {
    return QR_HC1;
  } else {
    return QR_UNKNOWN;
  }
}

// src/pages/swnotify.js
var SWNotify = class extends AbstractPage {
  constructor(domElem2) {
    console.log("SWNOTIFY: inside constructor");
    super(domElem2);
  }
  enter() {
    console.log("SWNOTIFY: enter page");
    let theHtml = html`
        <div class="container">
            <div class="w3-card-4 w3-center" style="margin-top:100px;">
        
                <header class="w3-container color-primary" style="padding:10px">
                    <h1>${T("Application updated")}</h1>
                </header>
        
                <div class="w3-container w3-padding-16">
                    <p>${T("There is a new version of the application and it has already been updated.")}</p>
                    <p>${T("Please click Accept to refresh the page.")}</p>
                </div>
        
                <div class="w3-padding-16">
        
                    <button @click=${() => gotoPage("spinner")} class="w3-button btn-color-primary btn-hover-color-primary w3-xlarge w3-round-xlarge">${T("Accept")}</button>
        
                </div>
        
            </div>
        </div>
        `;
    this.render(theHtml);
  }
};

// src/img/shield.png
var shield_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAEQCAMAAADs2erIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAM1BMVEVHcEz////////////////////////////////////////////////////////////////P0YphAAAAEHRSTlMAwaHhENHxYECBMCCRcLFQ52KobwAABipJREFUeNrt3Wm62yoMBmCwGY0H7X+1/ZHb3pycxGEUEg/fAtq+NaMNihCYsbsYNhuAHdZmYFjdZgBG1f1nG1Jn/9oAjuFs8JRlYNtgugVeotUoNHXCr+gwhi1oeBOzDTUFvMYON5SMNKyoBW7Cu+NtGm5j3BCrkk/Zh2ySvJumWyEqhuGo6SE6pxprJHl5eBen3uYhMXweXmxv+/HwjoEGyd+RDBabh4Hc7MTbptNQENKzQjihMJrqekztUCGS4opFeQN1soRhaeR4dWmkePVpZHhhaUEDADh7j5zuhIbRHec9ZVdoHOP7tM6tWXt8aZ3o+6FwrIAWs2+YzVECcvQRcGQndElzXzgkdIxu1j7Vta/QPWax1Xd9zksgE71ftYDh2jWQy7rYwia6WS8N0I3cbcYSLTjrTw0sskp/uO9PcXPOen/KFRjGSOn94dyPR7lJKaWGwbJKKaUVDoaNn7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJm7iJo5vz2B7n/81wuOfLndYMhXspUZRa9YE07nfNOjsM7l09PjsI7n2twWUI3Kc6iusAuI81Ih1/3E39S80dd1fb82COu61bGnjjvtRkNZxx3+rNSsa4r7V0GeO+1wnmi4uogcy2z0XY2I6WMbWruc5zUXW5ma5QomxM15ZRNsVzVxBXK57nfi7OxnMn3sBGBtfCRgXXxEYE18aWhzOnd875akXNGtlycE8F8KymbEvHvdRbPgxdWzJOb0V1xFFtqbg3/xKlqdoSceZdQbgiXUtbIu59McYCXVNbGu78tFLXJG1puI9VCjN1jW1JOH2zy9IEbUm4u18UyNA1tyXhbsvaJeva25JwX/b/mpqtIi5Nh2GriUvRodiScKGaDseWhPteLDpSh2RLwkX8JleUDsuWhFtFFR2aLW35ZWvo8GxpuFWV6xBtiVueqF/Cu9Vh2lJ34rZQh2pLfodSpsO1pb/9KtEh2zLeW+brsG05L2Vzdei2rNfpeTp8W963ghxdB1vmV550XQ9b7iesVF0XW/b3uTRdH1v+x8cUXSdbwZfVeF0vW8ln41hdN1vRN/E43dLNVvbBv94PqDWxFZ5msKRtpUc1LGVb8TkUS9hWfsjG0rVVOEFkydpqHI+yVG1Vzn5ZorY6B9ssTVulU3uWpK3WkURL0QaHENBL19oGrhIuQ9fcBi7p+m5NXXsbhIQbW1V1CDYQQuzQQYdh00m3murpMGxwpt38qaVDsYEXotZwmaDDsT2Oc0lkHZLtcSjIA6oOyyYfB8wBU4dle3S5hOu7FXRoNtjSL9wV6vBsf48EXYClw7P9f6xkRdIh2uDf1ZUdUHSYtjXj0nyJDtP2fNpcIuhQbfD0+eWq/6f7gjvQ5Vme/+oGv4+un4/qO+QfYA/N24y0j78jWOwfY5c/W02j/9lVSmkAPa5nd8d9cM0eXZe4glIc1HMW1C0inze3O7ZRbG9PYu9j2IwqLRJDOB+2JNcINvlpL3kO0Cg/3xo27HE3F2uvYRvlACOmCVUvDdPKl/uLG+dut1B5290gEcdWF7Ydbqt075TR0mSI2W6P+/DJcn8gSX2yRh9M/saPOJhwHTKTbNw2CInHl1hNCMkHzxjpfPqJQTa6RWSEyTuVLBuTHUKmjYUu28ZAV2AjP6oU2YjrCm2kdcU2wjovaoTmKrrWtctlYFvNQ9599jhf9ua0Jry1po3YdJ7wTiEugc6gudS2CaHOoaYAkq+NjBVtQmBYqTyU/BhWenc8qUS7dO54u2ibjvO5uUTruF4dTwfRPkoO2SQ7Nk2EJvlv1MR+6yeDwIvC3QV5gZsLb1xpOHF3H1d2JTrkwHh4xok+Ce0f3qlEtzR+eIgTAPrD25XonGb7oNWJ/mk053klSKTBHSu5CTKp/Aai2bsEAgPLrgSxXOuALfKpbdYYN1craKZ83DReCbLZyrreEgTpFHQ9mp3tZcmSx5NOcIjKGFnIjiPlPEa0VB4zWgqPIS2Wx5QWw2MyQn7k3UwMC2/aY957u2oxexBDxC2/u5oSwyT4dbD2+L51rocSAyb41aA+tD/ZpuJKPPMvTQAAAABJRU5ErkJggg==";

// src/img/cloud.png
var cloud_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAACoCAMAAADkSON9AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAM1BMVEVHcEz////////////////////////////////////////////////////////////////P0YphAAAAEHRSTlMAMMEgodFgQBDxgeFwULGRH31/sgAABSVJREFUeNrlnQl64yAMhWvMamNb9z/tTKfTNq03nKBnBO8Cyf8JC6EF3t7KlHfDohR9aVTzYN1bzeriPNK2zDL5KpknvYf8hR772uy8BEqRiRXZ3BpKl+6qYPZxpGtSFXg4G+i6pIO7kZ7TLNi79TM9rTBIpY6BXpER6dv8TK8qCtypR3pds7Rd3FIWjbIWuqZMCpOgzzob9V9ZMdSGqD3uzNRCuLNTy+CeiRrk1sSh0v15ZKGmUPb+7YhJY8nxmg9c2DQXjK2IT7G1D/u/Sv28e1ZqMg0u8XeVmW+xzNQU+ra8+FcKvUDsgfjlWjQ2kWrS2OWZG2Ls8syNMXZxMUsAYSOduZ+GWX2CGbVEB9+zv4Q6iU3LVqJf/ew8mGHYkBNJp0NK50EPo0ZE5vYsytY94uj1U9wR6pRSxfoAN0Bs3lXeJ56nwuDfPJCad5Vf2IdHZ5HYjL68v7ZqRyg2W/LYBSpYi9R8QZFx+UKFS1A1p/TjSPG2ZvFptnxqhgyqE0Cd//DZBwnY2V25kkCdPTwdSIZaXOLZsRW1iO2oSWzVJLYcY1Obxs6J3VGT2EuD2N5NQQ71mIV4UIKQs8TkfVQkT6915vloSKReOW93mqTq+TZrp0iuXIvQzxb/vCbhWp6oB8VA4nV5OswrqkLXxiCnQJUoXHBsA1Wk1Pq+n6kqpeXLvaHKZBI+8L466hTuLhC1x+1Hova4vaFKdVgZ4qIOSqUkKUal2MIkDe9QCB9HwLOLdMy/yMJzBQ27x+/I/F0df0LaM3vVCZoLfphPOuLW7BWI7UEpLic+JLlMDei/VsgMuE/ZKn46nAkXnnPVtkzKFvnLzXL15K6XOVucohJCg9XmQqA/w3fWHM9DohU135SBgzVm9GfcGtj1NsJaKfVJCLwRPjEeDCxmVdFWvvqRW8PCprW5WXPDG7eCfHNrdGOnBRn7kBtO/Whu7pThLjee+vGbY88t7HDfQf1d/53Yf2qb+xbq72gZkSDe4r6pTT3yRsCn3Dc15xvoJMA5N2okoYcOu5xxwwYxLHSC/oQbN34yg/sKj7iBQzcBPVS9zw0dNerQc2x73NgBKwueJd/jBo+VLYwJnOR8FiRM/J1bQndK6wJKbyN8GkAXUXLEOvL9AhyYu8O25+hCSswOiq1LKa075MiLLqZVKAKxzxqlgNwDDvu8PQzHjcNOaYqDccOwt/Jm3W3cKOzNbGG4jXvAHMB2cqS3cU+QfXs3M3wXNyRcOciH38TtAEfdwyrAPdye/wS28RyAPc478J+FAcUBe5JL2eDmdrMGkC8+zSCtublX4Mw/fq/O82ZrbvZtm724rRKyhStudkfOnr8LKTnSX9zcPs0DCp4uJTP8kzvyezT2RLlKyoc/cnNPbiyQWyZiUhXggVtD1h97dDAkdQZ9zqGyT98FVMfOGF3nzl9cVtY5t7DXnbXAu1SynDoh3XiFaZR4T1I+TyPj+s5s6iGdzKVJC7utNb+xGzK3Fnc5b35jN2PuRe4Vh6/Epau83twC9jqv50P91FtDnlP9S7yXea1+9iVe98UMW1t27ZePfGr/Mo6puQ+79mDtuIW/Wrc2SX8lJaMTr5074e7P+rhD0o2ntfm1kPh40FTV/m2S7zvtKorXrtx96WupGISLDzzWsdDN5TfBKjB4eOotT+E3N3/fRHZVk+DEonrlzTsr1OL61WfmnbyoLSw53iX2VlJWNeh8Txt6q0V85mbJ/pxj//6EfLlGVnpwjC/Ld65AXf6W/wANkw5fMqE61wAAAABJRU5ErkJggg==";

// src/img/freeofcookie.png
var freeofcookie_default = "data:image/png;base64,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";

// src/img/v_hand.png
var v_hand_default = "data:image/png;base64,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";

// src/img/fight_covid.png
var fight_covid_default = "data:image/png;base64,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";

// src/pages/intro.js
var spinIcon = svg`
<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>`;
var Intro = class extends AbstractPage {
  constructor(domElem2) {
    console.log("INTRO: inside constructor");
    super(domElem2);
  }
  enter() {
    console.log("INTRO: enter page");
    let theHtml = html`

            <div class="sect-white">
                <h2 class="w3-margin-bottom">${T("EU Digital COVID Credential Verifier")}</h2>
                <p>${T("$intro01")}</p>

                <div class="w3-padding-16 w3-center">

                    <button @click=${() => gotoPage("verifier")} class="w3-button btn-color-primary btn-hover-color-primary
                        w3-xlarge w3-round-xlarge">
                        ${T("Start verifying")}</button>

                </div>
            </div>

            <div class="sect-green">
                <h2 class="fw-8 mb-32">${T("Easy & Secure")}</h2>

                <div class="w3-row mb-16">
                    <div class="w3-third mb-16">
                        <img src=${shield_default} style="height:70px" alt="">
                        <h2>${T("We don't save data")}</h2>
                    </div>
                    <div class="w3-third mb-16">
                        <img src=${cloud_default} style="height:70px" alt="">
                        <h2>${T("No installs")}</h2>
                    </div>
                    <div class="w3-third">
                        <img src=${freeofcookie_default} style="height:70px" alt="">
                        <h2>${T("Free of cookies")}</h2>
                    </div>
                </div>

                <div>
                    <img src=${v_hand_default} style="height:70px" alt="" />
                </div>
                <div>
                    <button @click=${() => gotoPage("verifier")} class="w3-button btn-color-primary btn-hover-color-primary
                        w3-xlarge w3-round-xlarge">
                        ${T("Start verifying")}</button>

                </div>

            </div>

            <div class="sect-dark">
                <div class="margin-bottom">
                    ${T("$callus")}
                </div>
                <div>
                    <a href="mailto:government@evidenceledger.eu">Send Email as Government</a>
                </div>
                <div>
                    <a href="mailto:enterprise@evidenceledger.eu">Send Email as Enterprise</a>
                </div>


                <div>
                    <img src=${fight_covid_default} style="height:70px" alt="" />
                </div>
                <div>
                    <a @click=${() => gotoPage("termsOfUse")} href="javascript:void(0)">
                    ${T("Terms of use")}
                    </a>
                </div>
                <div>
                    <a @click=${() => gotoPage("privacyPolicy")} href="javascript:void(0)">
                    ${T("Privacy policy")}
                    </a>
                </div>
                <div>
                    <p style="font-weight:600">*This website does not use cookies</p>
                </div>
                <div>
                    <p class="fore-primary">Evidence Ledger 2021</p>
                </div>

            </div>

        `;
    this.render(theHtml);
  }
};

// src/pages/spinner.js
var Spinner = class extends AbstractPage {
  constructor(domElem2) {
    console.log("SPINNER: inside constructor");
    super(domElem2);
  }
  enter(pageData) {
    window.initialScreen();
    window.location.reload();
  }
};

// src/pages/displayNormalQR.js
var displayNormalQR = class extends AbstractPage {
  constructor(domElem2) {
    super(domElem2);
  }
  enter(qrData) {
    let isURL = false;
    if (qrData.startsWith("https://") || qrData.startsWith("http://")) {
      isURL = true;
    }
    let theHtml = html`
        <div class="container" style="margin-top:50px;">
            <h2 class="w3-margin-bottom w3-center">Received QR</h2>
            <p class="w3-large" style="word-break: break-all;">${qrData}</p>
        
            <div class="w3-bar w3-padding-16 w3-center" style="max-width:70%;margin:50px auto;">

                <a href="javascript:void(0)" @click=${() => window.history.back()} class="w3-button w3-left btn-color-primary btn-hover-color-primary
                    w3-large w3-round-xlarge">Back</a>
    
                ${isURL ? html`<a href="${qrData}" class="w3-button w3-right btn-color-primary btn-hover-color-primary
                    w3-large w3-round-xlarge">Go to site</a>` : html``}
                
            </div>
        </div>
        `;
    this.render(theHtml);
  }
};

// src/i18n/flags/uk.png
var uk_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAZCAYAAABzVH1EAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAAWJLR0QCZgt8ZAAAAAd0SU1FB+MJEREKI/zdwbgAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTktMDktMTdUMTc6MTA6MzUrMDA6MDCNS6NOAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE5LTA5LTE3VDE3OjEwOjM1KzAwOjAw/BYb8gAAAvJJREFUWEdjvOaT9F+6PJOBz8aEAQa+fv/FMGPJIYbuWbsZXr39DBUlDmipSjJc2VnL8KRjOsPTzhlQUQiQLs9gkKnIZNBxb2a4dvs5VJQ4ICbMy1CS5sqQZKPE8GH6IoY3yzcz/P/zB+xukPuZPp+8wHDdNxmMPx05A9bEzcnGUJzqwnD3UDNDd2UQ2BDqAEYoTTwA2d0FdMO1RekMQZePMNyxC2V4vXg9A6+FAYPm5rlgDPIMk8rB1QyisYEM9PUQYUCsB0AAlIKYtOJmMqzTtWEYLB4i1QO9s/cwKNvVMjCB8kBZ+zoGDA+doIWH/kNpTECuB0qBbgf5gQksAwQYHjpEnxii1AMwAPcIDOCMIap4CJHZqeUBGGBkVMzEHd9AALIQpdhbASz2fiOKPZhlIACycMveSwzhPiY4it9MYPGbwbBi8xkGNxUhrMUounnEVgOMq7aexesRGAB5yN5cleHnw6cMX89fhYoyMPCY6jOwSYtDeQiAzyP/vv9g+LjvGDhAQIBNWgJojh6YjQwOnrxN0AMwwPgfCKBsqgJ8FSItAOMJAT2aeITeACOzD1Uw6pHBBoaNR4ZPqUVqPYIOvpy+xPDr6Qswm5GVhYHfyYqBiZMDbz2CDn49e8nw5dRFKA/YYjDUYmCXl2E4BKxHXhJZj7CE58yBMrEDWM3u5agDFYEAUDPlaed0MM3IwsIgEuHLIJAVx7B67xVwzY4PgGp2Xxc9cBMHBNikxBlYRIQwzNMBmnf60juianaceQTWFgK1o0qA7SmYpSCLYG0uUAtZNCYQ3MBcr2cDbp81T94OVocPtEzZDm439QDbT6BmCAiAmiawNhaovfV6yXpw+yvw0hFwe4xQWw7DI+R6AFdjDhUgUjFILahxSi0PwT1CWw/gBtTyEBN9PYC7z06phxi/fPv5H+Z4EAB5AFsmnn/kHlGZDv8oCqTUImYUBeQ4UCGTGWMHD1wQwOU+JnolIVIBqTHERF8PkF73EuchAwYA57jFBXb252kAAAAASUVORK5CYII=";

// src/i18n/flags/es.png
var es_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAhCAIAAAAUH2/TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAABmJLR0QA/wD/AP+gvaeTAAAAB3RJTUUH4QgJEwYXl11ZpAAAACV0RVh0ZGF0ZTpjcmVhdGUAMjAxNy0wOC0wOVQxOTowNjoyMyswMDowMK8z9O0AAAAldEVYdGRhdGU6bW9kaWZ5ADIwMTctMDgtMDlUMTk6MDY6MjMrMDA6MDDebkxRAAACT0lEQVRYR+2XT2vTYBzH86dJk6UNXduVSWba6USdzlkr1losE3YbeBBPvgLfwQ7iwZfgQVGHevI0D+LNg050VpCtbJQxpShqt9bV2j9pm6ZZnjxGfe5p4BFyyOfw5MfzfAkfnufhyRMyL8iE+6DQ02V4Wk7wtJzgaTmBbN/1o9JNkHAVVa7C8SJ+boyg6n8y7Gw1Vb7e5SjS2KyKKaml6qzIAymkoGHcDKv1+m0YFH26MqiNCmNbOjgNoxF18pJvXOygBFbsFxGYf9poqFtu7ZcFaFCNH9N69Sdo6zAiqBD+DeHGRss0iXuP2U8lKjFhTM139ijY2w1oXCyS489fDprAvPOI/VrGf8rYvNGaC/linAlzhQfi9n0xtsHIbGZ64XaAuVnUngyAT8oeooMsSuPDRoumiLGDiySQLcHKCV9lhrY6wZ4i1v0kTQOdCI/f4HnpXxgjNlrbL/ja8vLuK7VeYlRG6JmhDzXY7NQASzEsu/VM6L95uvawh9L4sNGSkrqQmhv0fKNZ9ei3trzZeZmcyr9bVcxiY+V5KDEw+GRiLojS+LDRqhQZvfT92BWKjRuBk/1YRrmw8f6Umme+LBGFpfgZjQuB8oqG0viw0ZrMDMILacqPNjUtwEzkozShNIMc1Emrh5+dOX4N/1fVRqsDubX1W6VaK8BBwtIgoXHgrFYdEXf26YDZhUJhfXGni/9EtdFqaFHIpGv9I7NZPZUDcjpNZiX26rx0jstdV35pMdJvjR5GaXy49Abh1vuW9/vqAE/LCZ6WEzyt4SGI35oS1ztsLIjjAAAAAElFTkSuQmCC";

// src/i18n/flags/ca.png
var ca_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAhCAYAAACbffiEAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAAWJLR0QGYWa4fQAAAAd0SU1FB+EICBI4LjDjx4MAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMDgtMDhUMTg6NTY6NDYrMDA6MDA5zTabAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTA4LTA4VDE4OjU2OjQ2KzAwOjAwSJCOJwAAAH5JREFUWEft2DEKgDAQBMCsnZWgqXyYf/Nrp5Y+wP5ACfiIzbIDIfWR7OUI8hrfImD49+7JFIJnnySuFmJenREmzggbvyNskIfGiSAWlfbbyhBYOhm5t9pq6p7bLxtnhI3HeDaIqnEiyFNk1vI7Qsa/KGw8orDxLwobZ4RLKR9rcF87LWU8VAAAAABJRU5ErkJggg==";

// src/i18n/flags/fr.png
var fr_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAhCAYAAACbffiEAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAAWJLR0QCZgt8ZAAAAAd0SU1FB+EICgkYJhHG7wkAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMDgtMTBUMDk6MjQ6MzgrMDA6MDD61e2eAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTA4LTEwVDA5OjI0OjM4KzAwOjAwi4hVIgAAAGhJREFUWEftzzENgEAUBNEPVk4MQQBC6HFBMIEDGlRRXQPNV3A0A5nXbLacLsp2xwvTWGJfh3xtrnmJepz52vS5n2cIjSE0htAYQmMIjSE0htAYQmMIjSE0htAYQmMIjSE0htD8JCTiAb1HCJD9/v0sAAAAAElFTkSuQmCC";

// src/i18n/flags/de.png
var de_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAeCAYAAABuUU38AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAAWJLR0QDEQxM8gAAAAd0SU1FB+EIChA4KQcKTsUAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMDgtMTBUMTY6NTY6NDArMDA6MDBUTlsdAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTA4LTEwVDE2OjU2OjQwKzAwOjAwJRPjoQAAAExJREFUWEft1bENACAMxMAP+8/GBswSKBjCkXxSlNrVV5J+N976fzxDaAyhMYTGEJo6LjuLITSG0BhCYwhN9XbZUQyhMYTGEBpDWJILVpUF4WyZFNQAAAAASUVORK5CYII=";

// src/i18n/flags/it.png
var it_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAhCAYAAACbffiEAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAAWJLR0QDEQxM8gAAAAd0SU1FB+EICQQrEUd9E4sAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTctMDgtMDlUMDQ6NDM6MTYrMDA6MDD/V+VnAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE3LTA4LTA5VDA0OjQzOjE2KzAwOjAwjgpd2wAAAGxJREFUWEftzzENgEAQBdEFLeigJEEAPihJcIEMNFCg5Dxg4KBBAdtMyLxui/3JNLENdyRMXV/3cW3f85MyL/U6ztRG6pnEEBpDaAyhMYTGEBpDaAyhMYTGEBpDaAyhMYTGEBpDaAyh+UlIxAO7VQpxfOuUeAAAAABJRU5ErkJggg==";

// src/i18n/ii8.js
var SelectLanguage = class extends AbstractPage {
  constructor(domElem2) {
    super(domElem2);
  }
  enter() {
    let theHtml = html`
<div class="w3-container" style="padding:10px 0px;">

    <ul class="w3-ul w3-card-4">

        <li class="w3-bar" @click=${() => this.selectLang("en")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${uk_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">English</span>
            </div>
        </li>

        <li class="w3-bar" @click=${() => this.selectLang("ca")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${ca_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">Català</span>
            </div>
        </li>

        <li class="w3-bar" @click=${() => this.selectLang("es")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${es_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">Español</span>
            </div>
        </li>

        <li class="w3-bar" @click=${() => this.selectLang("fr")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${fr_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">Français</span>
            </div>
        </li>

        <li class="w3-bar" @click=${() => this.selectLang("de")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${de_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">Deutsch</span>
            </div>
        </li>

        <li class="w3-bar" @click=${() => this.selectLang("it")}>
            <div class="w3-bar-item" style="padding:8px;">
                <img src=${it_default} style="padding:8px;width:70px">
                <span class="h3" style="vertical-align:middle;">Italiano</span>
            </div>
        </li>

    </ul>
</div>
`;
    this.render(theHtml);
  }
  async selectLang(l2) {
    console.log("Selecting language", l2);
    window.preferredLanguage = l2;
    localStorage.setItem("preferredLanguage", l2);
    window.history.back();
  }
};

// src/img/legal.png
var legal_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA30AAANICAYAAABzPYanAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAAEsAAAAAQAAASwAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAA32gAwAEAAAAAQAAA0gAAAAApKazAAAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAAQABJREFUeAHsvQmULFd553lzqb3qvXpPTwghS3q28BxL6gaf4+OtDQYMNkuboW1tgD2yOINtEIsFbg/YY8FxjxnjPrbZGgxuus0Yg4RkemSxC7G4oWfwuGdsYZAwfjYgwEZH0nv1asvKym3uzcqIuhnxRcSNpTIjM39xzlNGfPF93/3uL0qZ9dXN+IdSbBCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAA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ATN90zTam/Q1L1t7Nnl54C+185nTWWgclM45cGoVECBAgAABAgQITLmAoG+KPwB7nnhxMQvlbN0ErXz++ZXl/Yfqrld9BAgQIECAAAECBKZRQHrnNI56t8/N+Ue7D+v4u8zy9lqx+0EBXx3a6iBAgAABAgQIECDwnoCZvin+JORZeVco6wHopnOeXFq0Omc95GohQIAAAQIECBAgsC4g6JviD0LWWftwyAYLkBZraedz/2J2b7DOSidAgAABAgQIECCwlYD0zq1kJvz1w4cPF3kWrhtkNztZsdoqFh4S8A1SWdkECBAgQIAAAQIEri5gpu/qPhP77ku3PfW5RuedgfWvk8+8EULjTumcAyNWMAECBAgQIECAAIGeBAR9PTE5qVeB9XTOYu6ZlaX9D/R6jfMIECBAgAABAgQIEBicgPTOwdlOXcmX0jkFfFM39jpMgAABAgQIECAwugJm+kZ3bAbasjLPvhU6/auinc8eP7F88y39K1FJBAgQIECAAAECBAj0Q8BMXz8Ux7CMk48vvpD2zava9JTO2Sp2PS3gqyrpegIECBAgQIAAAQKDERD0DcZ1LEotQ/GNKg1dT+dsLPzGytK+x6qU41oCBAgQIECAAAECBAYnMOBd2gbXcCVXF0jbNnznwJ+dzcv23HZLk865XTHnEyBAgAABAgQIEBiOgJm+4biPRK3PPfdcu53PP5JSNHtt0Ho6Z76wJJ2zVzHnESBAgAABAgQIEBiugJm+4fqPRO17vrjy63n7/NeKcu0DV2tQO585nYXGwdeW95262nneI0CAAAECBAgQIEBgdAQEfaMzFkNvyeLRV5fzvHwk66zdmIVyNjWonTXPhCz/n6y19gev/ekv/evQG6kBBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhcXeD/AZC+2HSmqsFvAAAAAElFTkSuQmCC";

// src/pages/termsofuse.js
var TermsOfUse = class extends AbstractPage {
  constructor(domElem2) {
    super(domElem2);
  }
  enter() {
    let theHtml = html`

<div class="sect-white" style="text-align:left">

<h1>Terms of Use</h1>
<img src=${legal_default} alt="" style="width:20%" >

<h3>Identification:</h3>
<p>
    AXONTEAM, SA (referred to as “Axonteam”), Calle Bruc, 59 - PR PTA 2, 08009 Barcelona, España. (legal@evidenceledger.eu). All rights reserved. Holder of the NIF (tax identification number) A-65580888 and registered in the Commercial Registry of Barcelona.
</p>

<h3>Terms:</h3>
<p>
The access and use of the website “evidenceledger.eu” (referred to as “Website”) implies the express acceptance without reserves of all the terms and conditions included in the Terms of Use. These terms regulate the access and use of the Website, provided by Axonteam fully free.
</p>

<p>
Axonteam, at any moment and without the need of previous notice, has the capacity to: Interrupt the access to the Website and the Applications and of modifying the terms of use.
</p>

<p>
The user agrees to use the Website and its contents comping with the Law, the Terms of Use, morality, best practices, and the requirements of good faith and public order. The user agrees not to use the contents of the Website in any way that could damage the interests or rights of third parties or Axonteam.
</p>

<p>
The user will be the sole responsible of his/her use of the Website and its contents.
</p>

<h3>Disclaimer of liability:</h3>
<p>
Axonteam does not grant any sort of warranty, express or implied, with the Website or its contents. The software “Evidence Ledger” is provided AS IS and hereby disclaims all implied warranties, “Evidence Ledger” is under the Apache License, Version 2.0: <span style="word-break:break-word">“https://www.apache.org/licenses/LICENSE-2.0”</span>.
</p>

<p>
The user will use the Website and its contents under his/her responsibility and knows that Axonteam does not assume any responsibility, including but not limited to any of the following: (i) the presence of viruses or any other damaging component in the Website, its elements or in the server; (ii) the accuracy of the information in the Website; (iii) the functionality of the Website and its elements; (iv) the lack of availability or continued operability of the Website; (v) damages that may be caused or derived from the Website such as: interferences, informational or operational errors, interruptions, viruses or faults.
</p>

<h3>Intellectual and Industrial Property:</h3>
<p>
Axonteam has the exclusive intellectual property rights of the Website (such as the source code, design, navigation structures).
</p>

<p>
This Website may include references to brands or trademarks registered by Axonteam. The use of any brand or trademark without the express consent of Axonteam is forbidden. Any other brand or trademark belongs to the respective owner and their reference on the Website does not confer any right over them.
</p>

<h3>Data Protection:</h3>
<p>
For the simple use of the current Website, Axonteam will not store any personal data from the users, therefore it is expressly stated that there will not be any personal data processing for the simple use of the Website.
</p>
<p>
If the user of the Website contacts Axonteam there will be a data processing in accordance with the privacy policy included on the Website.
</p>

<p>
It is important to note that by sending a simple query email through the system established on the Website, the user and holder of the given data, necessary to attend the query, consents expressly the data process.
</p>

<h3>Applicable legislation and jurisdiction</h3>
<p>
Any dispute arising or related to the Webiste will be governed by the Spanish Law and, the parties waiver any other forum to which they may be entitled, and will submit to the jurisdiction of the courts of the city of Barcelona (Spain).
</p>

</div>



`;
    this.render(theHtml);
  }
};

// src/pages/privacypolicy.js
var PrivacyPolicy = class extends AbstractPage {
  constructor(domElem2) {
    super(domElem2);
  }
  enter() {
    let theHtml = html`

<div class="sect-white" style="text-align:left">

<h1>Privacy Policy</h1>
<img src=${legal_default} alt="" style="width:20%" >

<h1>Privacy Policy</h1>
<p>
The user of the Website that contacts AXONTEAM, S.A. (referred as Axonteam) to issue a query through the system established on the Website, acknowledges that Axonteam will process the data in accordance with the privacy policy.
</p>
<p>
It is important to note that by sending a simple query email through the system established on the Website, the user and holder of the given data, necessary to attend the query, consents expressly the data process.
</p>

<p>
Therefore, Axonteam considers as personal data any information provided by the user while contacting with Axonteam via email. The user must provide truthful information about his/her personal data.
</p>

<p>
In the following, Axonteam provides the users of the Website the basic information of the data process (privacy policy).
</p>

<h3>1.- Identification:</h3>

<p>
AXONTEAM, SA (referred to as “Axonteam”), Calle Bruc, 59 - PR PTA 2, 08009 Barcelona, España. (legal@evidenceledger.eu). All rights reserved. Holder of the NIF (tax identification number) A-65580888 and registered in the Commercial Registry of Barcelona.
</p>

<h3>2.-Purpose</h3>

<p>
The purpose of the data process is to attend any query done by the user of the Website through the established system. There will not be any data processing of special categories.
</p>

<h3>3.-Legitimation</h3>

<p>
The legitimation of the data process is the express consent given by the user in the moment that emails Axonteam. Therefore, by sending the email, the user consents expressly that Axonteam process the personal data in accordance with the Privacy Policy.
</p>

<h3>4.-Recipients</h3>

<p>
There will not be any recipients of the provided personal data, and neither will be the data be transferred.
</p>

<h3>5.-Rights</h3>

<p>
At any moment the user will be able to modify his/her data and perform their rights of access, rectification or deletion of data, request that processing be restricted, oppose it or request data portability in accordance with the RGPD and the LOPD-GDD. For this purpose, the user will be able to contact by sending an email to the provided email of AXONTEAM’s data protection delegate.
</p>

<h3>6.-Duration of the process</h3>

<p>
The duration of the process will be the necessary to attend the different queries issued by the users of the Website and after resolving the query any data provided by the user will be delated.
</p>

<h3>7.-Additional Information</h3>

<p>
The data protection delegate of AXONTEAM S.A. is Accent Jurídic, S.L. and can be contacted directly by email at dpo@accentjuridic.com.
</p>

<p>
If there were a breach of security in the activities related to the data process, the internal procedure will be activated.
</p>
​​​​​​​
<p>
If the user would like to obtain more information of the Website’s Privacy Policy, he/she must direct the query to the data protection delegate of Axonteam by writing an email to
</p>
<a href="mailto:dpo@accentjuridic.com">dpo@accentjuridic.com</a>

</div>



`;
    this.render(theHtml);
  }
};

// src/app.js
var homePage2 = "intro";
var pageDefs = [
  {
    name: "intro",
    className: Intro
  },
  {
    name: "displayhcert",
    className: DisplayHcert
  },
  {
    name: "demo",
    className: DemoPage
  },
  {
    name: "verifier",
    className: ScanQrPage
  },
  {
    name: "swnotify",
    className: SWNotify
  },
  {
    name: "spinner",
    className: Spinner
  },
  {
    name: "page404",
    className: Page404
  },
  {
    name: "displayNormalQR",
    className: displayNormalQR
  },
  {
    name: "selectLanguage",
    className: SelectLanguage
  },
  {
    name: "termsOfUse",
    className: TermsOfUse
  },
  {
    name: "privacyPolicy",
    className: PrivacyPolicy
  }
];
document.body.innerHTML = "";
HeaderBar();
for (let i = 0; i < pageDefs.length; i++) {
  let name = pageDefs[i].name;
  let className = pageDefs[i].className;
  let classInstance = new className(name);
  document.body.append(classInstance.domElem);
  route(name, classInstance);
}
var mypathname = window.location.pathname;
if (window.location.search.length > 0) {
  let searchParams = new URLSearchParams(window.location.search);
  if (searchParams.get("home") !== null) {
    homePage2 = "passenger";
  } else if (searchParams.get("verifier") !== null) {
    homePage2 = "verifier";
  } else if (searchParams.get("demo") !== null) {
    homePage2 = "demo";
  } else if (searchParams.get("admin") !== null) {
    homePage2 = "admin";
  } else if (searchParams.get("pubcred") !== null) {
    homePage2 = "pubcreds";
  } else {
    log.mywarn("URL parameter not recognised", window.location.search);
  }
}
console.log("Home_page:", homePage2);
setHomePage(homePage2);
var MY_SERVER = "https://safeislandtest.hesusruiz.org";
var UNIVERSAL_RESOLVER = MY_SERVER + "/api/did/v1/identifiers/";
var VERIFY_CREDENTIAL = MY_SERVER + "/api/verifiable-credential/v1/verifiable-credential-validations";
var FAKE_ISSUER_GET_CREDENTIALS = MY_SERVER + "/api/verifiable-credential/v1/credentials";
var FAKE_ISSUER_GET_PUBLIC_CREDENTIALS = MY_SERVER + "/api/verifiable-credential/v1/public/credentials";
var ISSUER_GET_CREDENTIAL = "https://api.lanzarotesafe.org/sms/";
var ISSUER_GET_PUBLIC_CREDENTIAL = MY_SERVER + "/api/verifiable-credential/v1/public/";
var ST_PASSENGER_SCAN = "fromPassengerScan";
var INSTALL_SERVICE_WORKER = true;
window.addEventListener("load", async (event) => {
  if (runmode === "development") {
    console.log("In development");
    INSTALL_SERVICE_WORKER = false;
  } else {
    console.log("In production");
  }
  await performOneTimeInitialization();
  if (INSTALL_SERVICE_WORKER && "serviceWorker" in navigator) {
    const {Workbox} = await Promise.resolve().then(() => require_workbox_window_prod_es5());
    const wb = new Workbox("./sw.js");
    wb.addEventListener("message", (event2) => {
      if (event2.data.type === "CACHE_UPDATED") {
        const {updatedURL} = event2.data.payload;
        console.log(`A newer version of ${updatedURL} is available!`);
      }
    });
    wb.addEventListener("activated", async (event2) => {
      if (event2.isUpdate) {
        console.log("Service worker has been updated.");
        await performAppUpgrade();
      } else {
        console.log("Service worker has been installed for the first time.");
        await performAppUpgrade();
      }
    });
    wb.addEventListener("waiting", (event2) => {
      console.log(`A new service worker has installed, but it can't activateuntil all tabs running the current version have fully unloaded.`);
    });
    wb.register();
  }
  let paramsString = window.location.search;
  let searchParams = new URLSearchParams(paramsString);
  let credId = searchParams.get("id");
  if (credId) {
    var targetURLRead = ISSUER_GET_CREDENTIAL + credId;
    await requestQRAndDisplay(targetURLRead, "displayCredentialPage", ST_PASSENGER_SCAN);
    return;
  }
  credId = searchParams.get("pubid");
  if (credId) {
    var targetURLRead = ISSUER_GET_PUBLIC_CREDENTIAL + credId;
    console.log("Public Credential", targetURLRead);
    await requestQRAndDisplay(targetURLRead, "displayCredentialPage", ST_PASSENGER_SCAN);
    return;
  }
  await goHome();
});
async function performAppUpgrade() {
  console.log("Performing Upgrade");
  try {
    let response = await fetch("/VERSION.txt");
    let newVersion = await response.text();
    console.log(`Upgrading application to version ${newVersion}`);
    if (newVersion) {
      window.localStorage.setItem("VERSION", newVersion);
    }
  } catch (error) {
    console.log("ERROR updating version", error);
  }
  gotoPage("swnotify");
}
async function performOneTimeInitialization() {
}
